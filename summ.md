
<!-- vim-markdown-toc GFM -->

* [数据结构和语言基本类型](#数据结构和语言基本类型)
	* [线性表](#线性表)
		* [顺序表/连续表](#顺序表连续表)
		* [链表](#链表)
			* [单链表](#单链表)
			* [静态链表](#静态链表)
			* [循环链表](#循环链表)
* [语言中的数据结构](#语言中的数据结构)
	* [数组](#数组)

<!-- vim-markdown-toc -->
## 数据结构和语言基本类型
### 线性表
1. 最重要的概念是位置,因此有了索引,可以通过下标访问,可以插入指定位置

2. 线性表是一种典型的线性结构。头结点无前驱有一个后继，尾节点无后继有一个前驱。
链表只能顺序查找，定位一个元素的时间为O(N)，删除一个元素的时间为O(1)

3. 栈和队列是两种是操作受限的线性表.

#### 顺序表/连续表
1. 线性表的顺序存储结构
	把线性表的结点按逻辑顺序依次存放在一组地址连续的存储单元里。

2. 用这种方法存储的线性表简称顺序表。
	- 是一种随机存取的存储结构。
	- 顺序存储指内存地址是一块的
	- 随机存取指访问时可以按下标随机访问，存储和存取是不一样的。
	- 如果是存储，则是指按顺序的，
	- 如果是存取，则是可以随机的，可以利用元素下标进行。
	
3. 数组比线性表速度更快的是：原地逆序、返回中间节点、选择随机节点。
	* 便于线性表的构造和任意元素的访问
	* 插入：插入新结点，之后结点后移。平均时间复杂度:O(n)
	* 删除：删除节点，之后结点前移。平均时间复杂度:O(n)

#### 链表
1. 用一组任意的存储单元来依次存放线性表的结点，这组存储单元即可以是连续的，
也可以是不连续的，甚至是零散分布在内存中的任意位置上的。

2. 因此，链表中结点的逻辑次序和物理次序不一定相同。

3. 为了能正确表示结点间的逻辑关系，在存储每个结点值的同时，还必须存储指示其后继结点的地址。
data域是数据域，用来存放结点的值。next是指针域（亦称链域），用来存放结点的直接后继的
地址（或位置）。不需要事先估计存储空间大小。

##### 单链表
1. 每个结点的存储地址是存放在其前趋结点next域中，而开始结点无前趋，

2. 故应设头指针head指向开始结点。同时，由于最后一个结点无后继，故结点的指针域为空，即NULL。

3. 头插法建表(逆序)、尾插法建表(顺序)。增加头结点的目的是算法实现上的方便，但增大了内存开销

4. 操作:
	- 查找：只能从链表的头指针出发，顺链域next逐个结点往下搜索，直到搜索到第i个结点为止。
	因此，**链表不是随机存取结构**。
	
	- 插入：先找到表的第i-1的存储位置，然后插入。新结点先连后继，再连前驱。

	- 删除：首先找到a<sub>i-1</sub>的存储位置p。然后令p–>next指向a<sub>i</sub>的直接
	后继结点，即把a<sub>i</sub>从链上摘下。最后释放结点a<sub>i</sub>的空间.
	r=p->next;p->next=r->next;delete r。
	
	- 判断一个单向链表中是否存在环的最佳方法是快慢指针。
	用两个指针,第一个指针每次前进两部,第二个指针每次前进异步,两个指针的步差每次加1,
	如果有环第一个指针会追上第二个指针.

##### 静态链表
1. 用一维数组来实现线性链表，这种用一维数组表示的线性链表，称为静态链表。

2. 静态：体现在表的容量是一定的。（数组的大小）；

3. 链表：插入与删除同前面所述的动态链表方法相同。静态链表中指针表示的是下一元素在数组
中的位置。

4. 静态链表是用数组实现的，是顺序的存储结构，在物理地址上是连续的，而且需要预先分配大小。

5. 动态链表是用申请内存函数（C是malloc,C++是new）动态申请内存的，所以在链表的长度上没有限制

6. 动态链表因为是动态申请内存的，所以每个节点的物理地址不连续，要通过指针来顺序访问。

7. 静态链表在插入、删除时也是通过修改指针域来实现的，与动态链表没有什么分别

##### 循环链表
> 是一种头尾相接的链表。其特点是无须增加存储量，仅对表的链接方式稍作改变，
即可使得表处理更加方便灵活。

1. 在单链表中，将终端结点的指针域NULL改为指向表头结点的或开始结点，就得到了单链形式的循环链表
，并简单称为**单循环链表**。

2. 由于循环链表中没有NULL指针，故涉及遍历操作时，其终止条件就不再像非循环链表那样判断p
或p—>next是否为空，而是判断它们是否等于某一指定指针，如头指针或尾指针等。

3. 双向链表:在单链表的每个结点里再增加一个指向其直接前趋的指针域prior。这样就形成的链表中
有两个方向不同的链。

4. 双链表一般由头指针唯一确定的，将头结点和尾结点链接起来构成循环链表，并称之为双向链表。

5. 设指针p指向某一结点，则双向链表结构的对称性可用下式描述：
p—>prior—>next=p=p—>next—>prior。

6. 从两个方向搜索双链表，比从一个方向搜索双链表的方差要小。
	- 插入：先搞定插入节点的前驱和后继，再搞定后结点的前驱，最后搞定前结点的后继。

	- 在有序双向链表中定位删除一个元素的平均时间复杂度为O(n)

	- 可以直接删除当前指针所指向的节点。而不需要像单向链表中，删除一个元素必须找到其前驱。
	因此在插入数据时，单向链表和双向链表操作复杂度相同，而删除数据时，双向链表的性能
	优于单向链表

## 语言中的数据结构
### 数组
1. 顺序表: 
	- 固定长度:
		1. 申请时指明长度
		2. 判断长度
		3. 判断空

	- 有序
		1. 根据索引取值: a[0]
		2. 添加到指定位置: insert
		3. 

	- 数据几种存储在统一段地址空间内:
		1. 随机读取: a[0]
		2. 指针的加减取值: int *a = arr; a+= 1; *a = 2;

2. 链表(list, vector, 
		
3. queue, dequeue, stack)
