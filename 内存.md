
<!-- vim-markdown-toc GFM -->

* [c语言](#c语言)
	* [C语言内存结构](#c语言内存结构)
	* [内存分页机制](#内存分页机制)
	* [C语言0长度数组(可变数组/柔性数组)](#c语言0长度数组可变数组柔性数组)
		* [概念](#概念)
		* [变长结构体](#变长结构体)
		* [0长度数组不占用存储空间/绑定struct 末尾原理](#0长度数组不占用存储空间绑定struct-末尾原理)
		* [地址优化](#地址优化)
* [linux 系统](#linux-系统)
	* [clone 系统函数](#clone-系统函数)
* [cpp](#cpp)
	* [new](#new)
	* [cpp类对象内存](#cpp类对象内存)
	* [类内存空间 1387](#类内存空间-1387)

<!-- vim-markdown-toc -->
## c语言
### C语言内存结构 
1. 正文段（代码段）——CPU执行的机器指令部分；一个程序只有一个副本；只读，防止程序由于
意外事故而修改自身指令； 

2. 初始化数据段（数据段）——在程序中所有赋了初值的全局变量，存放在这里。 

3. 非初始化数据段（bss段）——在程序中没有初始化的全局变量；内核将此段初始化为0。
（这就是为什么全局内置类型变量会初始化，而局部变量就为未初始化的未知值） 

4. 栈——增长方向：自顶向下增长；自动变量以及每次函数调用时所需要保存的信息（返回地址；环境信息）。 

5. 堆——动态存储分。 
	
6. 程序在内存中申请了代码段，全局数据段（初始化和未初始化），栈和堆.

7. 程序代码放于代码段

8. 全局变量和静态变量存放在全局数据段中，一直存在直到程序结束，而局部变量都放于临时的栈中，
随着作用域的结束随着出栈操作而销毁。

9. malloc和new出来的内存不属于上面提到的程序申请的内存中，而是在系统中申请到的内存，所以如果在程序
中没有明确free和delete的话，程序结束后该内存仍不会被释放，造成内存泄漏。例如： 
```
int test() 
{ 
	int * p=new int(3); 
} 
```

	则test函数结束后，p指针本身被销毁，因为它是存在于函数栈中的局部变量，而p指向的int整型内容仍存在于内容堆中，没有被释放，造成内存泄漏。 

10. malloc size指定的空间大小:
	malloc时申请内存大小都是malloc(sizeof(`*entry``))
(.这里代表时entry所指向对象的大小,而不是申请一个指针的大小.)
﻿## sizeof
1. sizeof 返回对象的内存长度
2. sizeof 数组名返回数组的长度
3. sizeof 指针返回指针的长度，和指针所指的对象没有关系，32为4字节，64为8字节
4. 数组名当做参数传递退化成为指针，所以sizeof参数的数组名，返回的指针的长度。
5. sizeof具有常量性，在c99中可以当做在运行时确定，在其他编译器当做在编译期间运行
    
```
int n;
n = 10; 
char ary[n];
printf("%d\n", sizeof(ary))//c99输出10，其他编译器不可以。
```

6. 数组的sizeof值等于数组所占用的内存字节数：

```
char a1[] = "abc"; int a2[3]; sizeof(a1) == 4, sizeof(a2) == 12;
```
7. 总之一句话：
    <font color=red>sieof(val)的值只跟val有关，val是指针，得出的就是指针的大小，val是数组，就是数组的大小。*ptr得出的是指针所指对象的大小</font>
﻿## 柔性数组/零长度数组
### 内存分页机制
1. 最小存储单位是一个字节（1B），最小管理单位是一页（4KB）

2. getpagesize()可以获取当前内存页的大小。

3. 硬盘也是如此（硬盘上称为Block块）：即使一个.txt文件中只有一个“a”字母，
其大小为1B而其占用大小为4K。

4. 第一次malloc(0)时一次性映射33个内存页。不管第一次malloc是多少，都分配至少33个页。
即使malloc(1)、malloc(4)都是分配了33个内存页。

5. malloc分配的额外数据信息：
	1. malloc(sizeof(int))申请了4字节，系统却给它33页，

	2. 而malloc()给变量分配给变量内存时，除了数据区域外，还额外需要保存一些信息。
	底层有一个双向链表保存额外信息。

	3. malloc()给指针了12个字节，其中4个字节存放数据，另外8个存放其他信息或者空闲，
	如果将12个字节中前（低位）几个字节清空或者进行修改，free就可能出错，因为free只有首地址
	不能释放，还得需要额外附加信息（如malloc分配的长度）。
	（低八位是附加数据，高四位是int型数据）

6. 所以malloc返回的指针是一个const的指针，不能改变指针本身。

7. ![内存6](内存6.png)
	1. 如果我们将低八位的数据进行清空或者修改（修改任意个字节），free就有可能失败，测试如下： 
	2. 代码:p-4 还是正确的，p-5出现段错误。
	```
		#include<stdio.h>
		#include<stdlib.h>
		
		int main(){
			int *p = malloc(sizeof(int));
			*(p-5) = 3;
			printf("hello");
			free(p);
			return 0;
		}
	```
  
8. 下次malloc不会真正申请内存，还是从上一次分配的32页内存申请空间，
只有上一次32页内存用完了，才会重新申请内存空间。

### C语言0长度数组(可变数组/柔性数组)
1. [柔性数组详解](https://blog.csdn.net/gatieme/article/details/64131322)

#### 概念
1. GUN/GCC在标准的C/C++基础上做了实用性扩展,零长度数组(Arrays of length Zero)就是其中一
个知名的扩展

2. 柔性数组/0长度数组
	1. 用途: 长度为0的数组的主要用途是为了满足需要变长的结构体

	2. 用法:
		- <font color=red>必须: 在一个结构体的最后</font>,申明一个长度为0的数组,
		就可以使得这个结构体是可变长的

		- <font color=green>对于编译器来说,此时长度为0的数组并不占用空间,因为数组名本身不
		占空间,它只是一个偏移量,数组名这个符号本身代表了一个不可修改的地址常量.</font>

#### 变长结构体
1. 代码:
```
struct buffer {
	int len;
	char data[0];
} 
```

#### 0长度数组不占用存储空间/绑定struct 末尾原理
1. Programming Abstraction in c: arr is defined to be identical to &arr[0].它只是一个符号,
绑定到了arr[0]的地址.而指针是申请了8个字节的空间,保存了一个地址值的.

2. 通过汇编查看数组名和指针的区别:
	- 对于cahr s[0]来说,汇编代码用了addq指令,addq $4, %rax

	- 对于char* s来说,汇编代码用了movq指令,movq 8(%rax), %rax

3. addq 对 %rax + sizeof(struct str),即str结构的末尾是char s[0]的地址,这一步只是拿到了其
地址,而movq则是把地址里的内容放进去,因此有时也翻译做leap指令

4. <font color=red>这是最重要的地方:0长度数组名绑定的地址是struct 结构体的末尾,
这样,才可以使用malloc申请大空间,使用数组保存另外的信息</font>

#### 地址优化
> 注意:0长度数组是GUN c的扩展,不被任何标准库认可,那么一些巧妙编写的诡异代码,其执行结果
就是依赖于编译器和优化器策略的实现.

1. 比如程序中有两个0长度数组,他们地址被优化到一处

2. 编译器对于相同字符串常量,往往地址也是优化到一处,减少空间占用.

## linux 系统
### clone 系统函数
1. clone 第二个参数只传递一个指针，就可以为子进程创建栈空间。是因为: 

    1. 在2.6以前内核中，各个进程的task_struct存放在它们内核栈的尾端，
    这样是为了让那些像x86那样的寄存器较少的硬件体系结构只要通过栈指针就能
    计算出它的位置，从而避免使用额外的寄存器专门记录。

    2. 由于现在使用slab分配器动态生成task_struct,
        1. 所以只需要在栈底（对于向下增长的栈来说）

        2. 或栈顶（对于像上增长的栈来说）创建一个新的struct_thread_info.
        这个结构体有task_struct的指针。

    3. 内存中不同的内存页有不同的访问权限和拥有这个页的进程ID。
    ```
    struct page {
        unsigned long flags; //是否为脏页，是否锁定在内存中... 
        atomic_t  _count;
        atomic_t _mapcount;
        unsigned long private; 
        struct addree_space *mapping;
        pgoff_t index;
        struct list_head lru;
        void *virtual;
    }   
    ``` 

    4. linux 系统栈是向下增长（高地址向低地址增长），堆是向上增长。
    但数组内的元素是从低地址像高地址增长的。

    5. clone 第二个参数给定了栈底就可以申请子进程内存栈空间了，
    它会一直向下增长，直到溢出报核心转储错误。 

## cpp
### new
1. 有些构造函数使用：new 初始化对象成员，这是因为new返回的是一个指针，
用在成员是一个指针的情况下，用来复制一个新的new 对象。
```
class A {
public:
	int *pointer;
	A(): pointer(new int(1)){}
}
```	
### cpp类对象内存
1. c++ 类对象在内存的位置和虚指针虚表的详解：

	1. [虚表，内存位置](https://www.cnblogs.com/jerry19880126/p/3616999.html)

2. 类的普通成员函数以及静态成员函数不占内存

3. 类的成员函数实际上与普通的全局函数类似，只不过在编译的时候会在成员函数上加
一个指针（this）形参，（这非常重要）比如上面的方法可以理解为Show（&a）;
这   样调用Show的时候就传入了a的地址。

4. 成员函数的地址是全局已知的，对象内存无需保存，对象也并不知道它各个函数的地
址（这里理解是其他的途径先调用该函数，再把对象传入函数的形参中）

5. 有虚函数的类中会有一个维护虚函数表的指针，这样会占4个字节，64位编译器是可能是8个字节。
		
6. 类的属性（成员变量），在实例化一个对象时就为这些数据成员分配了内存，而且他们是相互独立的。
		
7. 静态成员函数与一般成员函数的区别是没有this指针，因此不能访问非静态的数据成员。
		
8. 程序中的所有函数位于代码区（C语言内存分配中有代码区用于存放CPU执行的机器指令与代码等，
其中还有data数据区，BSS区，堆栈）
		
9. 静态数据成员不属于某个对象（未初始化的存储在bss区，初始化的存储在data区）
		
10. 成员变量所占大小存在内存对齐机制（在Struct中也是一样的）
		
	比如上面的a,b,c分别是int，char，double类型，sizeof（int）+sizeof（char）< sizeof（double）。

11. 这里简单说一下对齐机制，首先第一个成员变量是int，所以先申请4个字节的大小，
接下来是一个char，一个字节紧跟在int后面，然后double来了，
<font color=green>它以为内存是按照自己的整数倍来分配的（每个关键字都是这么认为的）</font>,

所以会直接空出8个字节（也就是char后面空出来3个字节），再进行添加。
最后要以double类型为基础单位来占用内存（必须是double大小的整数倍）。
		
12. 空类占一个字节
	空类也需要实例化，实例化必须要在内存中分配一块地址，编译器一般会默认添加一个字节	

### 类内存空间 1387
1. 派生类的内存空间
    1. 类的非虚函数其实不占用类对象的内存（函数编译后形成二进制文件放在内存中的代码段区）
    2. 如果类含有虚函数，则编译结果 在类开始位置插入了一个虚函数指针。
    3. 内存中，派生类的内存空间是：前面是基类的对象空间，后面是派生类新定义的对象。但内存不一定是连续的存储的。
    4. 类所占内存的大小是由成员变量（静态变量除外）决定的，成员函数是不计算在内的。

2. 总结：
    1. 空的类是会占用内存空间的，而且大小是1，原因是C++要求每个实例在内存中都有独一无二的地址。

    2. 类内部的成员变量：
        1. 普通的变量：是要占用内存的，但是要注意对齐原则（这点和struct类型很相似）。
        2. static修饰的静态变量：不占用内容，原因是编译器将其放在全局变量区。

    3. 类内部的成员函数：
        1. 普通函数：不占用内存。
        2. 虚函数：要占用4个字节，用来指定虚函数的虚拟函数表的入口地址。所以一个类的虚函数所占用的地址是不变的，和虚函数的个数是没有关系的
