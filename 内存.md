### C语言内存结构 
1. 正文段（代码段）——CPU执行的机器指令部分；一个程序只有一个副本；只读，防止程序由于
意外事故而修改自身指令； 

2. 初始化数据段（数据段）——在程序中所有赋了初值的全局变量，存放在这里。 

3. 非初始化数据段（bss段）——在程序中没有初始化的全局变量；内核将此段初始化为0。
（这就是为什么全局内置类型变量会初始化，而局部变量就为未初始化的未知值） 

4. 栈——增长方向：自顶向下增长；自动变量以及每次函数调用时所需要保存的信息（返回地址；环境信息）。 

5. 堆——动态存储分。 
	
6. 程序在内存中申请了代码段，全局数据段（初始化和未初始化），栈和堆.

7. 程序代码放于代码段

8. 全局变量和静态变量存放在全局数据段中，一直存在直到程序结束，而局部变量都放于临时的栈中，
随着作用域的结束随着出栈操作而销毁。

9. malloc和new出来的内存不属于上面提到的程序申请的内存中，而是在系统中申请到的内存，所以如果在程序
中没有明确free和delete的话，程序结束后该内存仍不会被释放，造成内存泄漏。例如： 
```
int test() 
{ 
	int * p=new int(3); 
} 
```

	则test函数结束后，p指针本身被销毁，因为它是存在于函数栈中的局部变量，而p指向的int整型内容仍存在于内容堆中，没有被释放，造成内存泄漏。 

10. malloc size指定的空间大小:
	malloc时申请内存大小都是malloc(sizeof(`*entry``))
(.这里代表时entry所指向对象的大小,而不是申请一个指针的大小.)
﻿## sizeof
1. sizeof 返回对象的内存长度
2. sizeof 数组名返回数组的长度
3. sizeof 指针返回指针的长度，和指针所指的对象没有关系，32为4字节，64为8字节
4. 数组名当做参数传递退化成为指针，所以sizeof参数的数组名，返回的指针的长度。
5. sizeof具有常量性，在c99中可以当做在运行时确定，在其他编译器当做在编译期间运行
    
```
int n;
n = 10; 
char ary[n];
printf("%d\n", sizeof(ary))//c99输出10，其他编译器不可以。
```

6. 数组的sizeof值等于数组所占用的内存字节数：

```
char a1[] = "abc"; int a2[3]; sizeof(a1) == 4, sizeof(a2) == 12;
```
7. 总之一句话：
    <font color=red>sieof(val)的值只跟val有关，val是指针，得出的就是指针的大小，val是数组，就是数组的大小。*ptr得出的是指针所指对象的大小</font>
﻿## 柔性数组/零长度数组
### 内存分页机制
1. 最小存储单位是一个字节（1B），最小管理单位是一页（4KB）

2. getpagesize()可以获取当前内存页的大小。

3. 硬盘也是如此（硬盘上称为Block块）：即使一个.txt文件中只有一个“a”字母，
其大小为1B而其占用大小为4K。

4. 第一次malloc(0)时一次性映射33个内存页。不管第一次malloc是多少，都分配至少33个页。
即使malloc(1)、malloc(4)都是分配了33个内存页。

5. malloc分配的额外数据信息：
	1. malloc(sizeof(int))申请了4字节，系统却给它33页，

	2. 而malloc()给变量分配给变量内存时，除了数据区域外，还额外需要保存一些信息。
	底层有一个双向链表保存额外信息。

	3. malloc()给指针了12个字节，其中4个字节存放数据，另外8个存放其他信息或者空闲，
	如果将12个字节中前（低位）几个字节清空或者进行修改，free就可能出错，因为free只有首地址
	不能释放，还得需要额外附加信息（如malloc分配的长度）。
	（低八位是附加数据，高四位是int型数据）

6. 所以malloc返回的指针是一个const的指针，不能改变指针本身。

7. ![内存6](内存6.png)
	1. 如果我们将低八位的数据进行清空或者修改（修改任意个字节），free就有可能失败，测试如下： 
	2. 代码:p-4 还是正确的，p-5出现段错误。
	```
		#include<stdio.h>
		#include<stdlib.h>
		
		int main(){
			int *p = malloc(sizeof(int));
			*(p-5) = 3;
			printf("hello");
			free(p);
			return 0;
		}
	```

### C语言0长度数组(可变数组/柔性数组)
1. [柔性数组详解](https://blog.csdn.net/gatieme/article/details/64131322)

#### 概念
1. GUN/GCC在标准的C/C++基础上做了实用性扩展,零长度数组(Arrays of length Zero)就是其中一
个知名的扩展

2. 柔性数组/0长度数组
	1. 用途: 长度为0的数组的主要用途是为了满足需要变长的结构体

	2. 用法:
		- <font color=red>必须: 在一个结构体的最后</font>,申明一个长度为0的数组,
		就可以使得这个结构体是可变长的

		- <font color=green>对于编译器来说,此时长度为0的数组并不占用空间,因为数组名本身不
		占空间,它只是一个偏移量,数组名这个符号本身代表了一个不可修改的地址常量.</font>

#### 变长结构体
1. 代码:
```
struct buffer {
	int len;
	char data[0];
} 
```

#### 0长度数组不占用存储空间/绑定struct 末尾原理
1. Programming Abstraction in c: arr is defined to be identical to &arr[0].它只是一个符号,
绑定到了arr[0]的地址.而指针是申请了8个字节的空间,保存了一个地址值的.

2. 通过汇编查看数组名和指针的区别:
	- 对于cahr s[0]来说,汇编代码用了addq指令,addq $4, %rax

	- 对于char* s来说,汇编代码用了movq指令,movq 8(%rax), %rax

3. addq 对 %rax + sizeof(struct str),即str结构的末尾是char s[0]的地址,这一步只是拿到了其
地址,而movq则是把地址里的内容放进去,因此有时也翻译做leap指令

4. <font color=red>这是最重要的地方:0长度数组名绑定的地址是struct 结构体的末尾,
这样,才可以使用malloc申请大空间,使用数组保存另外的信息</font>

#### 地址优化
> 注意:0长度数组是GUN c的扩展,不被任何标准库认可,那么一些巧妙编写的诡异代码,其执行结果
就是依赖于编译器和优化器策略的实现.

1. 比如程序中有两个0长度数组,他们地址被优化到一处

2. 编译器对于相同字符串常量,往往地址也是优化到一处,减少空间占用.
