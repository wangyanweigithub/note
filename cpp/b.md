### template
1. template实例化时，只要是实例对象能唯一确定模板的所有形参就可以实例化模板。
	1. 特别是用函数指针实例化模板时，编译器会对照函数定义和模板的定义一一比较确定类型。
2. template 实例类型的推导：

### 对象声明
1. 数组声明时的类型：
	1. int a[10]
		2. int [10] 是类型，a式变量名
		3. 所以声明一个指针是， int (*a) [10]。a本来就是变量名。

2. 函数的声明：
	1. int fn(int a, int b);
		1. int (*)(int a, int b) 是类型，fn是变量名
		2. 所以声明一个函数指针是 int (*fn) (int a, int b),定义了一个名为fn的指针，
			指向一个函数类型。

### 内存
1. 分配时间：
	1. 大部分式定义时分配空间
	2. malloc一次分配32页内存，所以int a = malloc(sizeof(int))虽然只申请4字节内存，实际分配类32页内存。
	3. 下次malloc不会真正申请内存，还是从上一次分配的32页内存申请空间，
		只有上一次32页内存用完了，才会重新申请内存空间。

### 数据类型
1. 数据之所以要确定类型是因为：
	1. 确定内存空间大小
	2. 确定这个类型所定义的操作，就是这个类型可以执行什么操作

### 头文件
1. 一般而言，当调用函数时候，编译器只需要看到函数的声明。类似地，定义类类型的对象时，类定义必须可用，但成员函数的定义不是必须存在的。因此，应该将类定义和函数声明放在头文件中，而普通函数和类成员函数的定义放在源文件
2. 内存中，类成员方法在代码区，堆栈区存放的类对象只有类成员变量，所有对象共用一套类成员方法。所以，生成类对象时，只需要知道类成员变量，就知道对象空间的大小。

3. 模板：要进行实例化，编译器必须能够访问定义模板的源代码。当调用函数模板或类模板成员函数的时候，编译器需要知道函数定义，需要哪些通常放在源文件中的代码，详见模板。