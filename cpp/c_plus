### 操作重载与类型转换

### 面向对象
1. 面向对象设计基于三个基本概念：
    1. 数据抽象：可以将类的接口与实现分离
    2. 继承:  可以定义相似的类型并对其相似关系建模
    3. 动态绑定：可以在一定程度上忽略相似类型的区别

2. 继承
    1. 虚函数
        > 对于某些函数，基类希望它的派生类个自定义适合自己的版本，此时基类就将这些函数声明成为虚函数

        1. 派生类必须在其内部对所有重新定义的虚函数进行声明。
        2. 动态绑定发生在程序运行时，因为只有运行时才知道到底绑定了那个版本的虚函数。
        3. 必须为每一个虚函数都提供定义，而不管它是否被调用到，因为连编译器而已无法确定到底会使用哪个虚函数。
        4. 动态绑定只有当我们通过指针或引用调用虚函数时才会发生。
        5. note: p563

    2. 派生类使用类派生列表明确指定它是从哪个(哪些)基类继承而来。格式，先是一个冒号，后面紧跟逗号分隔的基类列表，每个基类前可以有访问说明符

    3. 动态绑定
        > 在C++语言中，当我们使用基类的引用(或指针)调用一个虚函数时，将发生动态绑定。

3. 定义基类和派生类
    1. 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。
    
    2. 定义基类
        1. 基类两种成员函数
            1. 希望派生类覆盖的函数，将其定义为虚函数。当使用指针或引用调用虚函数时，该调用将被动态绑定，根据引用或指针所绑定对象的类型不同，该调用执行不同的派生或者基类版本。
            2. 希望派生类继承不要改变的函数。

        2. virtual只能出现在类内部的声明语句之前。
        3. **成员函数如果没被声明为虚函数，则其解析过程发生在编译时而非运行时。**
        4. protected，派生类可以访问，其他对象不可访问，private对象，派生类也不可以访问。

    4. 定义派生类
        1. 派生类必须通过类派生列表指定基类
        2. 每个基类前可以有一下三种说明符：public、protected、private
        3. 派生类必须将继承来的成员函数中需要覆盖的那些重新声明。这些函数前面可以加上virtual，但不强制这样做。C++11允许在重写的成员函数后添加override关键字
        4. 内存中，派生类的内存空间是：前面是基类的对象空间，后面是派生类新定义的对象。但内存不一定是连续的存储的。
        5. 因为在派生类对象中含有基类对应的部分，所以我们可以把派生类当成基类对象来使用。而且也可以把基类的指针或引用绑定到派生类对象中的基类部分上。
        6. 派生类构造函数
            1. 派生类不能直接初始化基类的成员，必须使用基类的构造函数来初始化它的基类部分。
            2. 每个类控制它自己的成员的初始化过程。
            3. 派生类同样是通过构造函数初始化列表来将实参传递给基类构造函数的：
                
                    quote(const std::string& book, double p, std::size_t qty, double disc):Base(book, p), min_qty(qty), discount(disc) {}

            4. 首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。
                1. 始化列表的顺序要跟你在类声明的顺序要一致，否则可能出现问题。
                2. 只要成员变量的初始化不依赖其他成员变量，即使顺序不同也能正确的初始化
                3. **成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关**
    5. 静态成员
        1. 如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。无论派生多少类，每个静态成员都只存在唯一的实例。 

    6. 派生类的声明
        1. 派生类的声明包含类型但是不包含它的派生列表：
            
                class quote: base;   //错误，派生列表不能出现在这里
                class quote;         //正确

    7. 派生类的基类必须是已经定义而非是仅仅声明的。一次，一个类不能派生它本身。

    8. 不能继承的类：在类名后跟一个关键字final。

    9. 类型转换
        1. 智能指针和内置指针一样都支持指向基类的指针可以绑定到派生类。

    10. 权限
        1. 类体内的修饰
            1. private ：只能被定义的类本身的成员函数所访问，即使是类的对象都不能访问，它只能被定义类的类体内的成员访问。
            2. protected：只能被类和类的子类所访问，即使是定义它的类的对象都不可以访问。它的访问范围就是类定义体内的成员函数、子类定义体内的成员函数。
            3. public：所有对象都可以访问。
            4. 总结
                1. private、protected都只能被类本身的成员函数所访问，而不能被对象所访问。只有public才可以被对象访问。

        2. 派生访问说明符：
            1. 公有继承    继承自父类的成员保持不变。
            2. 私有继承    继承自父类的成员全部变为私有成员。
            3. 保护继承    继承自父类的公有成员变为保护成员，其余不变。
            4. 总结：
                1. 这里的公有、私有指的是派生类里面对象的权限，而不是访问base类里的权限。
                2. 所以即使是private继承，原来base类里的protected和public，派生类里定义的方法也是可以访问的。

    11. 派生类向基类转换的可访问性
        1. 派生类向基类转换时，只会使用派生类继承的那部分成员，只要保证对象访问那部分基类的部分权限不变就可以。
        2. 一句话就是：原来可以访问基类成员的对象(类对象、类成员、派生类成员)的权限没有被改变就可以由派生类向基类转换。
            1. 类对象: 派生类的类对象只能访问public的成员，所以，派生向基类转换过程中，派生类的类对象还是能访问基类public成员。只有public继承基类，派生类对象才可以访问基类的public成员。
            2. 类成员函数: 类成员函数可以访问所有类属性，不管是public、protected还是private，类成员都能访问，所以派生类成员函数访问所有的派生类从base继承过来的成员。
            3. D继承B，则D的派生类E只能访问D中protected和public成员，所以对派生类成员函数来说，可以使用这两种的继承方式。E不能访问D中的private，所以D的private继承不能转换。
            4. 友元和类方法是一致的。

