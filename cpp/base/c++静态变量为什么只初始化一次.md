# C++ 静态变量之为什么只初始化一次

1. 首先问题来自这个函数:

```
int fun() 
{ 
    static int i=0; 
    i++; 
    return i; 
} 
```

2. 当这个函数被反复调用时,i的值是会一直加的,也就是静态变量只被初始化了一次.

3. 我对此产生了疑惑.不知道大家有没有.当改为:
```
int fun() 
{ 
    int i=0; 
    i++; 
    return i; 
} 
```

4. 反复调用时都返回的是1,这个例子很明白,
	1. 虽然i这个变量时同名的,但是地址是不一样的,这是一个新的变量,因为在作
	用域后,原变量被销毁了.接着创建一个新的变量.

	2. 那么这里我们就知道了一件事情:就是静态变量是全局的,和程序的生命周期是一样的.

	3. 那么原来的staic的i依然存在. 但是它的可访问区域就只能是定义的作用域,而不一定能全局访问,
	这是全局变量的一个差别.

5. 而静态变量的必须初始化,如果没有显示初始化,则初始化为0 ,'0'或者其他.

6. <font color=red>初始化在程序第一次加载中开始.并设置了相应的标志位!</font>
	1. 所以当变量重复时,编译器忽略了重复初始化的代码,到这里就算是C++只能初始化一次的原因了!

## 另外参考:
1. 操作系统在加载程序时会根据程序中的声明部分为程序分配内存空间(这部分数据是由编译器生成的)。
程序所支配的内存空间分为两大部分：
	1. 静态区域和动态区域(至于为什么这样区分涉及到硬件知识，建议LZ不要深究)：
	2. 动态区域用于存储经常会变动的数据
	3. (动态区域又分为两大部分：栈和堆，关于这两个部分大家应该都很熟悉了)；
	4. 静态区域(Java里称为永久区域)用于存储不会经常变化的数据，例如程序的指令代码(C/C++里就是各个函数
	编译后得到的代码)、用户类型(结构体、类)的声明代码、全局变量、静态变量……PS：有些例子提到用静态变
	量来做递归的计数器，那只是为了说明静态变量的特性。实际上不推荐这种用法，因为这样会
	对程序性能造成轻微的影响。

	5. 静态区域内的数据会在程序加载时进行初始化，生存期为程序运行的全部时间。

	6. 另外，纠正LZ的一个误解：任何变量都只进行一次初始化。局部变量在程序块结
	束时生存期就结束了，下次再调用这个程序块时从原理上说声明的是另一个变量了(分配到的地址也不一定一样)

	PS：在不同编译器的不同编译情况时，实际的内存分区可能不同。例如TC的Small模式下堆和栈区是重合的，
	而Tiny模式下连静态区域和动态区域都是重合的。
