### C++ 11/14 高速上手教程 - 语言级线程支持
1. 本节内容包括：
    1. 对标准库的扩充: 语言级线程支持
        - std::thread
        - std::mutex/std::unique_lock
        - std::future/std::packaged_task
        - std::condition_variable

    2. 提示：本节代码编译需要使用 -pthread 选项，例如：

			g++ main.cpp -std=c++14 -pthread

### std::thread
> 用于创建一个执行的线程实例，所以它是一切并发编程的基础，使用时需要包含<thread>头文件，
> 它提供了很多基本的线程操作，例如get_id()来获取所创建线程的线程 ID，例如使用 join() 来加入一个线程等等，例如：

		#include <iostream>
		#include <thread>
		void foo() {
			std::cout << "hello world" << std::endl;
		}
		int main() {
			std::thread t(foo);
			t.join();
			return 0;
		}

### std::mutex, std::unique_lock
> C++11引入了 mutex 相关的类，其所有相关的函数都放在 <mutex> 头文件中。

1. std::mutex 是 C++11 中最基本的 mutex 类，通过实例化 std::mutex 可以创建互斥量，
	而通过其成员函数 lock() 可以仅此能上锁，
	unlock() 可以进行解锁。

2. 但是在在实际编写代码的过程中，最好不去直接调用成员函数，
	因为调用成员函数就需要在每个临界区的出口处调用 unlock()，当然，还包括异常。
	
3. 这时候 C++11 还为互斥量提供了一个 RAII 语法的模板类std::lock_gurad。
	RAII 在不失代码简洁性的同时，很好的保证了代码的异常安全性。

4. 在 RAII 用法下，对于临界区的互斥量的创建只需要在作用域的开始部分，例如：

		void some_operation(const std::string &message) {
			static std::mutex mutex;
			std::lock_guard<std::mutex> lock(mutex);

			// ...操作

			// 当离开这个作用域的时候，互斥锁会被析构，同时unlock互斥锁
			// 因此这个函数内部的可以认为是临界区
		}

	由于 C++保证了所有栈对象在声明周期结束时会被销毁，所以这样的代码也是异常安全的。
	无论 some_operation() 正常返回、还是在中途抛出异常，都会引发堆栈回退，也就自动调用了 unlock()。

5. 而 std::unique_lock 则相对于 std::lock_guard 出现的，std::unique_lock 更加灵活，
	std::unique_lock 的对象会以独占所有权
	（没有其他的 unique_lock 对象同时拥有某个 mutex 对象的所有权）的方式管理 mutex 对象上的上锁和解锁的操作。
	所以在并发编程中，推荐使用 std::unique_lock。例如：

		#include <iostream>
		#include <thread>
		#include <mutex>

		std::mutex mtx;

		void block_area() {
			std::unique_lock<std::mutex> lock(mtx);
			//...临界区
		}
		int main() {
			std::thread thd1(block_area);

			thd1.join();

			return 0;
		}

### std::future, std::packaged_task
> std::future 则是提供了一个访问异步操作结果的途径，这句话很不好理解。

1. 而 C++11 提供的 std::future 可以用来获取异步任务的结果。我们很容易能够想象到把它作为一种简单的线程同步手段。

2. 此外，std::packaged_task 可以用来封装任何可以调用的目标，从而用于实现异步的调用。例如：

		#include <iostream>
		#include <future>
		#include <thread>

		int main() {
			// 将一个返回值为7的 lambda 表达式封装到 task 中
			// std::packaged_task 的模板参数为要封装函数的类型
			std::packaged_task<int()> task([](){return 7;});
			// 获得 task 的 future
			std::future<int> result = task.get_future();    // 在一个线程中执行 task
			std::thread(std::move(task)).detach();    
			std::cout << "Waiting...";
			result.wait();
			// 输出执行结果
			std::cout << "Done!" << std:: endl << "Result is " << result.get() << '\n';
		}

	1. 在封装好要调用的目标后，可以使用 get_future() 来获得一个 std::future 对象，以便之后事实线程同步。

### std::condition_variable
1. std::condition_variable 是为了解决死锁而生的。
	- 当互斥操作不够用而引入的。
	- 比如，线程可能需要等待某个条件为真才能继续执行，而一个忙等待循环中可能会导致所有其他线程都无
		法进入临界区使得条件为真时，就会发生死锁。
	- 所以，condition_variable 实例被创建出现主要就是用于唤醒等待线程从而避免死锁。
	- std::condition_variable的 notify_one() 用于唤醒一个线程；
	- notify_all() 则是通知所有线程。
	
2. 下面是一个生产者和消费者模型的例子：

		#include <condition_variable>
		#include <mutex>
		#include <thread>
		#include <iostream>
		#include <queue>
		#include <chrono>

		int main()
		{
			// 生产者数量
			std::queue<int> produced_nums;
			// 互斥锁
			std::mutex m;
			// 条件变量
			std::condition_variable cond_var;
			// 结束标志
			bool done = false;
			// 通知标志
			bool notified = false;

			// 生产者线程
			std::thread producer([&]() {
				for (int i = 0; i < 5; ++i) {
					std::this_thread::sleep_for(std::chrono::seconds(1));
					// 创建互斥锁
					std::unique_lock<std::mutex> lock(m);
					std::cout << "producing " << i << '\n';
					produced_nums.push(i);
					notified = true;
					// 通知一个线程
					cond_var.notify_one();
				}   
				done = true;
				cond_var.notify_one();
			}); 

			// 消费者线程
			std::thread consumer([&]() {
				std::unique_lock<std::mutex> lock(m);
				while (!done) {
					while (!notified) {  // 循环避免虚假唤醒
						cond_var.wait(lock);
					}   
					while (!produced_nums.empty()) {
						std::cout << "consuming " << produced_nums.front() << '\n';
						produced_nums.pop();
					}   
					notified = false;
				}   
			}); 

			producer.join();
			consumer.join();
		}