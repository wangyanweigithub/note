##  智能指针和引用计数
- RAII 与引用计数
- std::shared_ptr
- std::unique_ptr
- std::weak_ptr

### RAII 与引用计数
> 基本想法是对于动态分配的对象，进行引用计数，每当增加一次对同一个对象的引用，那么引用对象的引用计数就会增加一次，
> 每删除一次引用，引用计数就会减一，当一个对象的引用计数减为零时，就自动删除指向的堆内存。

1. 在传统 C++ 中，『记得』手动释放资源，总不是最佳实践。因为我们很有可能就忘记了去释放资源而导致泄露。
2. 所以通常的做法是对于一个对象而言，我们在构造函数的时候申请空间，而在析构函数（在离开作用域时调用）的时候释放空间，
	也就是我们常说的** RAII 资源获取即初始化技术**。

3. 注意：引用计数不是垃圾回收，引用技术能够尽快收回不再被使用的对象，同时在回收的过程中也不会造成长时间的等待，
	更能够清晰明确的表明资源的生命周期。

### std::shared_ptr
> std::shared_ptr 是一种智能指针，它能够记录多少个 shared_ptr 共同指向一个对象，
> 从而消除显示的调用 delete，当引用计数变为零的时候就会将对象自动删除。

1. 但还不够，因为使用 std::shared_ptr 仍然需要使用 new 来调用，这使得代码出现了某种程度上的不对称。

	1. std::make_shared 就能够用来消除显示的使用 new，所以std::make_shared 
		会分配创建传入参数中的对象，并返回这个对象类型的std::shared_ptr指针。例如：

			#include <iostream>
			#include <memory>

			void foo(std::shared_ptr<int> i)
			{
			(*i)++;
			}
			int main()
			{
			// auto pointer = new int(10); // 非法, 不允许直接赋值
			// 构造了一个 std::shared_ptr
			auto pointer = std::make_shared<int>(10);
			foo(pointer);
			std::cout << *pointer << std::endl; // 11

			// 离开作用域前，shared_ptr 会被析构，从而释放内存
			return 0;
			}

	2. std::shared_ptr 可以通过 get() 方法来获取原始指针
	3. 通过 reset() 来减少一个引用计数
	4. 并通过get_count()来查看一个对象的引用计数。例如：

			auto pointer = std::make_shared<int>(10);
			auto pointer2 = pointer;    // 引用计数+1
			auto pointer3 = pointer;    // 引用计数+1
			int *p = pointer.get();             // 这样不会增加引用计数

			std::cout << "pointer.use_count() = " << pointer.use_count() << std::endl;      // 3
			std::cout << "pointer2.use_count() = " << pointer2.use_count() << std::endl;    // 3
			std::cout << "pointer3.use_count() = " << pointer3.use_count() << std::endl;    // 3

			pointer2.reset();
			std::cout << "reset pointer2:" << std::endl;
			std::cout << "pointer.use_count() = " << pointer.use_count() << std::endl;      // 2
			std::cout << "pointer2.use_count() = " << pointer2.use_count() << std::endl;    // 0, pointer2 已 reset
			std::cout << "pointer3.use_count() = " << pointer3.use_count() << std::endl;    // 2

			pointer3.reset();
			std::cout << "reset pointer3:" << std::endl;
			std::cout << "pointer.use_count() = " << pointer.use_count() << std::endl;      // 1
			std::cout << "pointer2.use_count() = " << pointer2.use_count() << std::endl;    // 0
			std::cout << "pointer3.use_count() = " << pointer3.use_count() << std::endl;    // 0, pointer3 已 reset

### std::unique_ptr
> std::unique_ptr 是一种独占的智能指针，它禁止其他智能指针与其共享同一个对象，从而保证了代码的安全：

		std::unique_ptr<int> pointer = std::make_unique<int>(10);   // make_unique 从 C++14 引入
		std::unique_ptr<int> pointer2 = pointer;    // 非法

1. make_unique 并不复杂，C++11 没有提供 std::make_unique，可以自行实现：

		template<typename T, typename ...Args>
		std::unique_ptr<T> make_unique( Args&& ...args ) {
			return std::unique_ptr<T>( new T( std::forward<Args>(args)... ) );
		}

	1. 至于为什么没有提供，C++ 标准委员会主席 Herb Sutter 在他的博客中提到原因是因为『被他们忘记了』。

2. 既然是独占，换句话说就是不可复制。但是，我们可以利用 std::move 将其转移给其他的 unique_ptr，例如：

### std::weak_ptr
> 如果你仔细思考 std::shared_ptr 就会发现依然存在着资源无法释放的问题。看下面这个例子：

		#include <iostream>
		#include <memory>

		class A;
		class B;

		class A {
		public:
		std::shared_ptr<B> pointer;
		~A() {
			std::cout << "A 被销毁" << std::endl;
		}
		};
		class B {
		public:
		std::shared_ptr<A> pointer;
		~B() {
			std::cout << "B 被销毁" << std::endl;
		}
		};
		int main() {
		std::shared_ptr<A> a = std::make_shared<A>();
		std::shared_ptr<B> b = std::make_shared<B>();
		a->pointer = b;
		b->pointer = a;

		return 0;
		}

1. 运行结果是 A, B 都不会被销毁，这是因为 a,b 内部的 pointer 同时又引用了 a,b，
	这使得 a,b 的引用计数均变为了 2，而离开作用域时，a,b 智能指针被析构，却智能造成这块区域的引用计数减一，
	这样就导致了 a,b 对象指向的内存区域引用计数不为零，而外部已经没有办法找到这块区域了，也就造成了内存泄露

2. 解决这个问题的办法就是使用弱引用指针 std::weak_ptr
> std::weak_ptr是一种弱引用（相比较而言 std::shared_ptr 就是一种强引用）。
> **弱引用不会引起引用计数增加，当换用弱引用时候，最终的释放流程如下图**所示：


3. 在上图中，最后一步只剩下 B，而 B 并没有任何智能指针引用它，因此这块内存资源也会被释放。

4. std::weak_ptr 没有 * 运算符和 -> 运算符，所以不能够对资源进行操作，它的唯一作用就是用于检查 std::shared_ptr 是否存在，expired() 方法在资源未被释放时，会返回 true，否则返回 false。

正确的代码如下：

		#include <iostream>
		#include <memory>

		class A;
		class B;

		class A {
		public:
		// A 或 B 中至少有一个使用 weak_ptr
		std::weak_ptr<B> pointer;
		~A() {
			std::cout << "A 被销毁" << std::endl;
		}
		};
		class B {
		public:
		std::shared_ptr<A> pointer;
		~B() {
			std::cout << "B 被销毁" << std::endl;
		}
		};
		int main() {
		std::shared_ptr<A> a = std::make_shared<A>();
		std::shared_ptr<B> b = std::make_shared<B>();
		a->pointer = b;
		b->pointer = a;

		return 0;
		}

### 总结
1. 智能指针这种技术并不新奇，在很多语言中都是一种常见的技术，C++1x 将这项技术引进，
	在一定程度上消除了 new/delete 的滥用，是一种更加成熟的编程范式。

### 进一步阅读的参考资料
1. stackoverflow 上关于『C++11为什么没有 make_unique』的讨论
