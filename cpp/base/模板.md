
<!-- vim-markdown-toc GFM -->

* [模板与泛型编程]
	* [模板定义]
	* [实例化]
	* [模板编译模型]
	* [类模板成员]
	* [一个泛型句柄类]
	* [模板特化]
	* [重载与函数模板]

<!-- vim-markdown-toc -->
## 模板与泛型编程
> c++primer 5 16：

1. 所谓泛型编程就是以独立与任何类型的方式编写代码。使用泛型程序时，
我们需要提供具体程序实例所操作的类型或值。

2. 泛型编程与面向对象编程一样，都依赖于某种形式的<font color=green>多态性</font>

3. 模板是泛型编程的基础，模板是创建类的蓝图或公式。

### 模板定义
1. 定义：
	1. 定义函数模板
		> 模板定义以关键字 templte开始，后接**模板形参列表**(template paramter list),
		**模板**形参列表式用尖括号括住的一个或多个**模板形参**的列表，形参之间以逗号分隔。

		> <font color=green>模板形参表不能为空</font>
		> <font color=green>但是模板特化的时候,模板形参列表可以为空,但函数名后要加上尖括号,
		并在尖括号中写入特化的类型,如:template<> int add<int, float>(){...}</font>

		1. 模板形参表
			> 模板形参可以是表示类型的**类型形参**,也可以是表示常量表达式的**非类型形参**.

			1. **非类型形参**跟在类型说明符之后声明
			2. **类型形参**跟在关键字class或typename之后定义。class和typename在这里没有区别。

		2. 使用函数模板
			> 使用函数模板时，编译器推断哪些模板实参绑定到模板形参，这就是实例化

			1. 编译器将确定用什么类型代替每个类型形参，以及非类型形参。编译器使用实参代替相应的模板形参产生并并编译该版本的函数。
			
					int main()
					{
						//T is int; compiler instaniates int compare(const int&, const int&)
						cout << compare(1, 0) << endl;
						//T is string; compiler instaniates int compare(const string&, const string&)
						string s1 = "hi", s2 = "world";
						cout << compare(s1, s2) << endl;
					}

		3. inline:
			> 说明符放在模板形参表之后，返回类型之前，不能放在template之前

					template <typename T> inline T min(const T&, const T&);

	2. 定义类模板
		> 类模板也是模板，以以关键字template开头，后接模板形参表。

				template <class T> class Queue {
				pubic:
					Queue();
					T &front();
					const T &fonst() const;
				privte:
					//...
				};

		1. 使用类模板
			
				Queue<int> qi;
				Queue<vector<double>> qc;
				Queue<string> qs;

			1. 编译器使用实参来实例化这个类的特定类型版本。
			2. 实际上编译器用用户提供的实际特定类型代替类T，重新编写了Queue类。这里编译器实例化类三个类。

		2. 模板可以只声明不定义：
			
				template <class T> int compare(const T&, const T&);
2. 模板形参
	> 模板形参的唯一含义是区分形参是类型形参还是非类型形参。
	> <font color=green>每个模板类型形参前面都必须带上关键字class或typename，每个非类型形参前面必须带上类型名字，省略关键字或类型说明符都是错误的</font>

	1. 模板类型形参
		1. 在模板定义内部指定类型
			
				template <class Param, class U>
				Param fcn(Param* array, U value){
					typename Param::size_type *p;
				}

			1. 之所以在param前面加上typename，是因为不知道size_type是Param的数据成员还是类型成员。
				而默认情况下，编译器假定这样的名字指定数据成员，而不是类型.

			2. 所以在成员名之前加上typename作为前缀，可以告诉编译器将成员当作类型
				这样也导致了实例化fcn的类型必须具有size_type的成员。

			3. 在类型前加typename没有害处，即使是不必要的也没有关系，所以拿不定的时候就加上。

					template <class Param, class U>
					Param fcn(Param* arry, U value)
					{
						Param::size_type *p;//这里不指导size_type 到底是类型名还是对象名，可以有多重定义
					}


					如果希望编译器将size_type当作类型，则必须显示告诉编译器这样做：
					template <class Param, class U>
					Param fnc(Param* array, U value)
					{
						typename Param::size_type *p;
					}

	2. 模板非类型形参
		> 在调用函数时非类型形参将用值代替，值得类型在模板形参表中指定

		1. 模板非类型形参值式模板定义内部的常量值，再需要常量表达式的时候，可使用非类型形参指定数组长度（应用场景）

				template <class T, size_t N> void array_init(T (&param)[N])
				{ 
					for (size_t i = 0; i != N; i++)
					  param[i] = 0;
				}

		2. 当调用array_init实例化具体类型时，编译器会从数组实参计算非类型形参的值：

				int x[42];
				double y[10];
				array_init(x);
				array_init(y);

			1. 编译器将为array_init调用中用到的每种数组实例化一个array_init版本。
				</font color = red>注意编译器实例化函数版本时没有调用尖括号来确定具体类型，
				而是通过调用实参来确定所有的模板形参。</font>
		3. <font color=red>模板非类型形参最常用与确定数组长度，注意模板中的形参也是形参，所有数组形参在函数中都是一个指针。
				所以如果实例化模板时传进来的是一个数组名或者指针，都会退化成为一个指针，编译器推断不出来数组长度，会报错。
				只有模板形参那里是一个引用，实例化时才会将实参引用传递过去，才可以推断处数组长度。</font>

### 实例化
1. 概述
	> 模板是一个蓝图，它本身不是类或函数，编译器用木板产生指定的类或函数特定类型版本。产生模板的特定类实例的过程称为</font color=green>实例化</font>
	> </font color=red>模板在使用时将进行实例化，类模板在引用实际模板类类型时实例化，函数模板在调用它或用它对函数指针进行初始化或者赋值时实例化。</font>

	1. 类的实例化
		1. 类模板的每次实例化都会产生一个独立的类类型。为int类型实例化的Queue与任意其他Queue类型没有关系，对其他Queue类型的成员也没有特殊访问权限。

	2. 类模板形参是必须的
		1. </font color=red>想要使用类模板，就必须显示指定模板实参： Queue<int>.Queue 不是类型，Queue<int>才是类型</font>

	3. 函数模板实例化
		1. 使用函数模板时，编译器通常会为我们推断模板实参

2. 模板实参推断
	1. 多个类型形参的实参必须完全匹配
	2. 类型实参的受限转换
		1. 不会转换实参以匹配已有的实例化，相反，会产生新的实例。只有两种情况会发生转换
		2. 两种转换
			1. const转换
			2. 数组或函数到指针的转换
	
	3. 应用于非模板实参的常规转换		
		1. </font color=green>类型转换的限制只适用于类型为模板形参的那些实参，如果形参不是模板类型，可以自动转换</font>

				template <class Type> Type sum(const Type &op1, int op2){
				
					return op1 + op2;
				}

				double d = 3.14;
				sum(1024, d); ok

	4. 模板实参推断与函数指针
	> 可以使用函数模板对函数指针进行初始化或赋值，
	> 这样做的时候，编译器使用指针的类型实例化具有适当模板实参的模板版本。	
	
		1. 例子
				
				template <typename T> int compare(color T&, const T&);
				int (*pf1) (const int&, const int&) = compare;

		1. 获取函数模板实例化的地址的时候，上下文必须是这样的：它允许为每个模板形参确定唯一的类型或值
		2. 如果不能从函数指针确定模板实参，就会出错。
			1. 例子：重载两个同名函数，不能唯一确定模板实参，实例化时会失败

3. 函数模板的显式实参
> 某些情况，不能推断模板实参，最常出现在:函数的返回类型必须和形参表中所用的所有类型都不想同。
> 这种情况下，有必要覆盖模板实参推断机制，并显式指定**为模板形参所用的类型或值**

	1. 指定显示模板实参
		1. template <typename T, typename U> ??? sum(T, U);   返回结果肯定是T和U里范围最大的类型，int、long……
			但是不能确定返回类型到底式T还是U。

		2. 解决办法： 强制sum调用者将较小的类型强制转换为希望作为结果使用的类型：

				int (static_cast<int>(s), i); //这样不管返回类型是T还是U都正确

		3. <font color=gray>调用时，调整调用实参类型，使得返回类型可以预测**</font>

	2. 在返回类型中使用类型形参
		1. 指定返回类型的一种方式是引入第三个模板形参，它必须由调用者显示指定：
			
				//T1 cannot be deduced:it doesn't appear in the funccion paramer list
				template <typename T1, typename T2, typename T3> 
				T1 sum(T2, T3);

		2. 问题：没有实参可用来推导形参的类型，所以调用者必须在每次调用sum时为该形参显式提供实参。
		3. </font color=red>为调用者提供显示实参和定义模板类相似：在以逗号分隔、用尖括号括住的列表中指定显式模板实参</font>

				//T1 explicitly specified;T2 and T3 inferred from arguent types
				long val3 = sum<long>(i, lng);

			1. </font color=red>注意：显示模板实参从左至右与对应模板形参相匹配，第一个模板实参与第一个模板形参匹配，以此类推。</font>
				
					template <class T1, class T2, class T3>
					T3 alternative_sum(T2, T1);
				
			2. </font color=red>则必须为三个所有形参指定实参</font>
				
					long val3 = alternative_sum<long, int, long>(i, lng);

					编译器只会对模板形参一个一个对照，如果尖括号里实参数目和模板形参不一样，则后面几个模板形参根据函数调用实参确定。

	3. 显式实参与函数模板的指针
		1. 有二义性的程序，通过使用显式模板实参能够消除二义性：

				template <typename T> int compare(const T&, const T&);
				void func(int(*) (const string&, const string&);
				void func(int(*) (const int&, const int&);
				func(compare<int>);

### 模板编译模型
1. 产生实例的阶段：
	1. 编译器看到模板定义不会立即产生代码，只有看到使用模板时，如调用函数模板或者类模板的对象时候，编译器才会产生模板实例。

2. 普通函数定义和类方法定义在源文件中。但模板实例化时需要提前知道模板函数定义。  

3. 两种编译模型
> 所有编译器都支持第一种包含模型，少部分编译器支持分别编译模型，这里需要查看编译器指南
	1. 包含编译模型
	> 在这种编译模型中，编译器必须能看到用到的所有模板的定义
		
		1. 一般而言，可以在声明函数模板或类模板的头文件中加一条#include，添加定义了相关模板的源文件，等于说是在声明的头文件中#include 定义的源文件。

		2. 这样可以保持头文件和实现文件的分离，但是需要编译器在编译使用的模板时必须能看到两种文件。
		3. 可能在不同的源文件中使用同一个模板却生成多个实例，编译器优化查看文档。

	2. 分别编译模型
	> 编译器会为我们跟踪相关的模板定义，但是必须让编译器知道要记住给定的模板定义，可以使用**export 关键字**来做这件事。
		1. 头文件一般不包含变量、结构和类对象定义，因为这样可能导致重复定义的编译错误，
			解决办法是，在某个代码文件中进行定义，在其他用户代码文件用extern来引用它们。

		2. 对模板类型，可以在头文件中声明模板类和模板函数;					
			在代码源文件中，使用extern来定义具体的模板类和模板函数; 
			然后在其他用户代码文件中，包含声明头文件后，就可以使用这些对象和函数了。

		3. export 不必在模板声明中出现

		4. 定义
			1. 在函数模板定义中指明函数模板为导出，通过在template前面包含export

					export template <typename Type>
					Type sum(Type t1, Type t2);

				1. 这个函数模板的申明像通常一样应放在头文件中，声明不必指定export

			2. 类模板使用export
				1. 头文件中的类定义体不应该使用关键字export，如果在头文件中使用了export，
					则该文件只能被程序中的一个源文件使用

				2. 相反，应该在类的实现文件中使用export。

			2. 

### 类模板成员
1. 类模板成员函数
2. 非类型形参的模板实参
3. 类模型中的友元声明
4. Queue和QueueItem的友元声明
5. 成员模板
6. 完整的Queue类
7. 类模板的static 成员

### 一个泛型句柄类
1. 定义句柄类
2. 使用句柄类

### 模板特化
1. 函数模板的特化
2. 类模板的特化
3. 特化成员而不特化类
4. 类模板的部分特化

### 重载与函数模板
