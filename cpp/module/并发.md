## 并发
	- task: async 包装可调用对象返回future，task在async内部解决
	- future
	- eventLoop(单线程异步)/thread(多线程)

## 高级接口
### async
1. async():
> 尝试将其所获得的函数立刻异步启动一个分离线程内
	1. 调用async()并不保证传入的函数一定会被启动和结束，如果不能启动线程，那么这一调用会被推迟到
		- 明确需要结果时执行(get 调用)
		- 或者希望目标函数完成其任务(wait调用)

				future<int> result(async(func1));
				int result2 = func2();
				int result = result1.get() + result2;

	2. 如果无法并行，则在get时一定会被循序调用，get执行一定会调用func1,不是异步就是同步。
	3. async早调用而晚返回： 应将async()和调用get()之间的距离最大化
		
			future<int> result1(async(func1));
			result = result1.get() + func2;
			这样还是同步，等result1执行完了以后才启动func2.

2. launch(发射) 策略
	1. 强迫async()绝不推延目标函数的执行，值哟传入一个launch策略用以指挥async

			future<int> result1 = async(launch::async, func1); 
			如果异步调用在此处无法实现，抛出一个std::system_error，错误码：resource_unavailable_try_again,相当于POSIX的EAGIN

		1. **在生存周期结束前，主线程会自动等待async启动的task完成**
		2. **如果不把async返回的future赋值给别的别量，会阻塞在这里直到目标函数结束，相当于一个完完全全的同步调用**

	2. 强制延缓执行：延缓目标函数执行直到调用get获取返回结果时执行

			future<...> f(async(launch::deferred, func1));

		1. **这保证func1()绝不会在没有get()或者wait()的情况下启动，懒加载/缓式求值 时使用**


3. 异常
> "对future调用get()"也能处理异常。async的后台线程出现异常不会在此线程内被处理，
> 而是会再次传播出去，因此处理后台异常，只需要偕同get()做出"以同步方式调用该操作"所做的相同动作即可。

4. 等待和轮询
> 一个future只能被调用get()一次，之后future就处于无效状态.
> 这种状态只能借由"对future调用valid()"来检测。此情况下对它的任何调用(析构除外)会导致不可预期行为。

	1. 强制启动异步任务
		- wait(): 只要对future调用wait/get，就可以强制启动该future象征的线程并等待这一后台操作终止。

	2. 不强制启动线程(如果线程尚未启动的话)
		1. 函数
			1. wait_for(): 给定一个时间段，可以等有限的时间，但是不强制启动线程。

					future<...> f(async(func));
					f.wait_for(chrono::seconds(10));

			2. wait_until(): 等到某个特定时间点：
			
					f.wait_until(system_clock::now()+chrono::minutes(1));

		2. wait_for()和wait_until()返回一下三个东西之一：
			- std::future_status::deferred：  没启动，async延缓启动而又没有调用get/wait.
			- std::future_status::timeout:    被异步启动但是尚未结束
			- std::future_status::ready:      操作已完成

		3. 例子：

				int quickComputation();
				int accurateComputation();

				std::future<int> f;

				int bestResultInTime()
				{
					auto tp = std::chrono:system_clock::now() + std::chrono::minutes(1);
					f = std::async(std::launch::async, accurateComputation);
					int guess = quickComputation();

					std::future_status s = f.wait_until(tp);

					if (s == std::future_status::ready)
					  return f.get();
					else
					  return guess;
				}

		4. 注意：
			1. <font color=red>future f 不能声明于bestResultInTime()内的local对象，那样的话时间太短以至于无法完成accurateComputation()，
				future析构函数会停滞(block)直到异步操作结束</font>

			2. 这就是为什么不调用get()/wait()，主线程结束前会等async的线程完成，是future的析构函数在起作用。

		5. 循环不会结束情况
			1. 例子: 例如在单线程环境中，这一调用将被推迟直至get()被调用，因此循环不会结束。

					future<...> f(async(task));
					while (f.wait_for(chrono::seconds(0) != future_status::ready)) {
						...
					}
				
			2. 正确循环调用
				- 调用async()并以其第一实参指定发射策略为std::launch::async
				- 明确检查是否wait_for()返回std::future_status::deffered 而不是直接检查ready

			3. 无线循环的另一个可能原因：运行此循环的线程完全占用处理器，其他线程无法获得丝毫时间来备妥future
				1. 最简单的修正就是在循环内调用yield()

						std::this_thread::yield() // hint to reschedule to the thread

				2. 睡眠一小段时间

		6. 传递实参
			1. 使用一个lambda并让它调用后台函数，这是调用函数肯定会传递实参

					auto f1 = async([]{ doSomething('.');});

			2. 使用在调用async()之前存在的实参，by value 或者by reference

					char c = '@';
					auto f = async([=]{doSomething(c);});

			3. async 第一个参数是可调用对象，后面参数将成为被调用那个函数的参数

					char c = '@';
					auto f = std::async(doSomething, c);

			4. by reference 调用风险：被传递的实参可能在后台任务执行前就已经失效了。 

			5. 如果可以控制实参寿命，使他超越后台生命周期，就可以使用传引用：

					void doSomething(const char& c);
					...
					char c = '@';
					auto f = async([&]{ doSomething(c); });

				const 改变对象声明周期，查一下，const对象在内存中的位置
				**这里不是防止实参改变，而是防止实参已经释放导致函数调用无意义。**

			6. 总结：
				1. 传递给lambda by value，lambda实参实在定义时拷贝的，by reference是个指针，在调用时的的准确值
				2. 如果使用async(), 就应该以by value 方式传递所有"用来处理目标函数"的必要object，使用async()只需要局部拷贝。
				3. 如果复制成本太高，可以使用const reference形式传递，且不适用mutable。
				4. 可以可传给aysnc()一个<font color=red>指向成员函数</font>的pointer，
					此时第二个实参(第一个参数)必须是一个reference或者pointer，指向某个object，后者将调用该成员函数。self/this。

### Shared Future
1. 场景
	future只能调用一次get(),shared_future 可以多次调用get(),导致相同的结果，或导致抛出同一个异常
	
2. 调用
	- shared future可以用寻常的future为初值： shared_future<int> f = async(queryNumber);
	- 可以调用future的成员函数share(): auto f = async(querNumber).share();

3. shared_future的get声明不同与future
	- Class future<> 的get
		- T future<T>::get();
		- T& future<T&>::get();
		- void future<void>::get();
		- 第一种形式返回move之后的结果或该结果的一份拷贝

	- Class shared_future<> 的get
		- const T& shared_future<T>::get();
		- T& shared_future<T&>::get();
		- void shared_future<void>::get();
		- 第一种形式返回一个reference，指向存放于"被共享之shared state"的结果

## 底层接口：Thread和Promise
### Class std::thread

## 总结
1. 如果循环内部没有做任何事，则这只是所为的"忙于等待"(busy waiting), 这意味着这个问题能够以**条件变量**更好的解决。
2. 右值不能绑定到左值引用，但可以绑定到右值引用和常量左值引用

## 问题
1. 后台任务传递引用有风险，但是为什么const & 没有风险，const & 栈内存回收？
	1. const 对象是约束编译器和程序员的，它修饰的对象还存在原来的内存区。
	2. static存储在全局变量区。
	3. const对象可能被编译器优化为字面量