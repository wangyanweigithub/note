### 对象声明
1. 数组声明时的类型：
	1. int a[10]
		2. int [10] 是类型，a式变量名
		3. 所以声明一个指针是， int (*a) [10]。a本来就是变量名。

2. 函数的声明：
	1. int fn(int a, int b);
		1. int (*)(int a, int b) 是类型，fn是变量名

		2. 所以声明一个函数指针是 int (*fn) (int a, int b),
		定义了一个名为fn的指针,指向一个函数类型。

	3. 下次malloc不会真正申请内存，还是从上一次分配的32页内存申请空间，
	只有上一次32页内存用完了，才会重新申请内存空间。

### 数据类型
1. 数据之所以要确定类型是因为：
	1. 确定内存空间大小
	2. 确定这个类型所定义的操作，就是这个类型可以执行什么操作

### 头文件
1. 一般而言，当调用函数时候，编译器只需要看到函数的声明。
类似地，定义类类型的对象时，类定义必须可用，但成员函数的定义不是必须存在的。
因此，应该将类定义和函数声明放在头文件中，而普通函数和类成员函数的定义放在
源文件

2. 内存中，类成员方法在代码区，堆栈区存放的类对象只有类成员变量，
所有对象共用一套类成员方法。所以，生成类对象时，只需要知道类成员变量，
就知道对象空间的大小。

3. 模板：要进行实例化，编译器必须能够访问定义模板的源代码。
当调用函数模板或类模板成员函数的时候，编译器需要知道函数定义，需要哪些通常放在
源文件中的代码，详见模板。

### 构造函数：
1. explict
	1. C++中的explicit关键字只能用于修饰**只有一个参数**的类构造函数, 
	它的作用是表明该构造函数是显示的, 而非隐式的, 跟它相对应的另一个关键字是implicit,
	意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式).

	2. explicit关键字只对有一个参数的类构造函数有效, 如果类构造函数参数大于或等于两个时, 
	是不会产生隐式转换的, 所以explicit关键字也就无效了

	3. 也有一个例外, 就是当除了第一个参数以外的其他参数都有默认值的时候,
	explicit关键字依然有效, 此时, 当调用构造函数时只传入一个参数,
	等效于只有一个参数的类构造函数

2. c++中字符串、字符串指针、const 字符串指针的区别

3. 类对象在内存中的存储位置：
	1.	一种是在栈上创建，形式如下： CSomeClass someObject;
	2. 一种是在堆上创建(动态分配)，形式如下： CSomeClass *pSomeObject = new CSomeClass();

