
<!-- vim-markdown-toc GFM -->

* [对象声明](#对象声明)
* [内存](#内存)
* [数据类型](#数据类型)
* [头文件](#头文件)
* [new](#new)
* [clone](#clone)
* [构造函数：](#构造函数)
* [类对象内存](#类对象内存)

<!-- vim-markdown-toc -->

### 对象声明
1. 数组声明时的类型：
	1. int a[10]
		2. int [10] 是类型，a式变量名
		3. 所以声明一个指针是， int (*a) [10]。a本来就是变量名。

2. 函数的声明：
	1. int fn(int a, int b);
		1. int (*)(int a, int b) 是类型，fn是变量名

		2. 所以声明一个函数指针是 int (*fn) (int a, int b),
		定义了一个名为fn的指针,指向一个函数类型。

### 内存
1. 分配时间：
	1. 大部分定义时分配空间

	2. malloc一次分配32页内存，所以int a = malloc(sizeof(int))虽然
	只申请4字节内存，实际分配类32页内存。

	3. 下次malloc不会真正申请内存，还是从上一次分配的32页内存申请空间，
	只有上一次32页内存用完了，才会重新申请内存空间。

### 数据类型
1. 数据之所以要确定类型是因为：
	1. 确定内存空间大小
	2. 确定这个类型所定义的操作，就是这个类型可以执行什么操作

### 头文件
1. 一般而言，当调用函数时候，编译器只需要看到函数的声明。
类似地，定义类类型的对象时，类定义必须可用，但成员函数的定义不是必须存在的。
因此，应该将类定义和函数声明放在头文件中，而普通函数和类成员函数的定义放在
源文件

2. 内存中，类成员方法在代码区，堆栈区存放的类对象只有类成员变量，
所有对象共用一套类成员方法。所以，生成类对象时，只需要知道类成员变量，
就知道对象空间的大小。

3. 模板：要进行实例化，编译器必须能够访问定义模板的源代码。
当调用函数模板或类模板成员函数的时候，编译器需要知道函数定义，需要哪些通常放在
源文件中的代码，详见模板。

### new
1. 有些构造函数使用：new 初始化对象成员，这是因为new返回的是一个指针，
用在成员是一个指针的情况下，用来复制一个新的new 对象。
```
class A {
public:
	int *pointer;
	A(): pointer(new int(1)){}
}
```	

### clone
2. clone 第二个参数只传递一个指针，就可以为子进程创建栈空间。是因为:
	1. 在2.6以前内核中，各个进程的task_struct存放在它们内核栈的尾端，
	这样是为了让那些像x86那样的寄存器较少的硬件体系结构只要通过栈指针就能
	计算出它的位置，从而避免使用额外的寄存器专门记录。

	2. 由于现在使用slab分配器动态生成task_struct,
		1. 所以只需要在栈底（对于向下增长的栈来说）

		2. 或栈顶（对于像上增长的栈来说）创建一个新的struct_thread_info.
		这个结构体有task_struct的指针。

	3. 内存中不同的内存页有不同的访问权限和拥有这个页的进程ID。
	```
	struct page {
		unsigned long flags; //是否为脏页，是否锁定在内存中...
		atomic_t  _count;
		atomic_t _mapcount;
		unsigned long private; 
		struct addree_space *mapping;
		pgoff_t index;
		struct list_head lru;
		void *virtual;
	}
	```	

	4. linux 系统栈是向下增长（高地址向低地址增长），堆是向上增长。
	但数组内的元素是从低地址像高地址增长的。

	5. clone 第二个参数给定了栈底就可以申请子进程内存栈空间了，
	它会一直向下增长，直到溢出报核心转储错误。

### 构造函数：
1. explict
	1. C++中的explicit关键字只能用于修饰**只有一个参数**的类构造函数, 
	它的作用是表明该构造函数是显示的, 而非隐式的, 跟它相对应的另一个关键字是implicit,
	意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式).

	2. explicit关键字只对有一个参数的类构造函数有效, 如果类构造函数参数大于或等于两个时, 
	是不会产生隐式转换的, 所以explicit关键字也就无效了

	3. 也有一个例外, 就是当除了第一个参数以外的其他参数都有默认值的时候,
	explicit关键字依然有效, 此时, 当调用构造函数时只传入一个参数,
	等效于只有一个参数的类构造函数

2. c++中字符串、字符串指针、const 字符串指针的区别

3. 类对象在内存中的存储位置：
	1.	一种是在栈上创建，形式如下： CSomeClass someObject;
	2. 一种是在堆上创建(动态分配)，形式如下： CSomeClass *pSomeObject = new CSomeClass();

### 类对象内存
1. c++ 类对象在内存的位置和虚指针虚表的详解：

	1. [虚表，内存位置](https://www.cnblogs.com/jerry19880126/p/3616999.html)

2. 类的普通成员函数以及静态成员函数不占内存

3. 类的成员函数实际上与普通的全局函数类似，只不过在编译的时候会在成员函数上加
一个指针（this）形参，（这非常重要）比如上面的方法可以理解为Show（&a）;
这   样调用Show的时候就传入了a的地址。

4. 成员函数的地址是全局已知的，对象内存无需保存，对象也并不知道它各个函数的地
址（这里理解是其他的途径先调用该函数，再把对象传入函数的形参中）

5. 有虚函数的类中会有一个维护虚函数表的指针，这样会占4个字节，64位编译器是可能是8个字节。
		
6. 类的属性（成员变量），在实例化一个对象时就为这些数据成员分配了内存，而且他们是相互独立的。
		
7. 静态成员函数与一般成员函数的区别是没有this指针，因此不能访问非静态的数据成员。
		
8. 程序中的所有函数位于代码区（C语言内存分配中有代码区用于存放CPU执行的机器指令与代码等，
其中还有data数据区，BSS区，堆栈）
		
9. 静态数据成员不属于某个对象（未初始化的存储在bss区，初始化的存储在data区）
		
10. 成员变量所占大小存在内存对齐机制（在Struct中也是一样的）
		
	比如上面的a,b,c分别是int，char，double类型，sizeof（int）+sizeof（char）< sizeof（double）。

11. 这里简单说一下对齐机制，首先第一个成员变量是int，所以先申请4个字节的大小，
接下来是一个char，一个字节紧跟在int后面，然后double来了，
<font color=green>它以为内存是按照自己的整数倍来分配的（每个关键字都是这么认为的）</font>,

所以会直接空出8个字节（也就是char后面空出来3个字节），再进行添加。
最后要以double类型为基础单位来占用内存（必须是double大小的整数倍）。
		
12. 空类占一个字节
	空类也需要实例化，实例化必须要在内存中分配一块地址，编译器一般会默认添加一个字节	
