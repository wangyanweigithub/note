## 广度优先算法 
1. 首先添加起点到队列，这里用了队列的先进先出 
2. 添加起点的所有直接相连的节点 
3. 检查直接相连节点是否满足条件，如果不满足，推出此节点，并将此节点的所有子节点添加到队列的后面，
	这样会先检查起点的所有子节点，然后在检查各个子节点子节点，实现广度优先。

## 最短路径：迪克拉斯算法
1. 步骤：
	1. 找出最便宜的节点，即可在最短时间内到达的节点
	2. 更新该节点的邻居的开销，找出到达邻居节点的最短时间，如果后面有更小的值，更新这个开销
	3. 重复这个过程，直到对图中的每一个节点都这样做了。
	4. 计算最终路径。

2. 总结：
	1. 因为每次更新节点邻居的开销时，邻居节点的父节点肯定是在路径列表中的，所以肯定是一条完整的链路。
	2. 图中每个节点计算一次，这个节点计算完后就认为此节点到邻居的最短路径确定了
	3. 因为２，所以有负权值的边无法使用这个算法。
## 有负权值的最短路径：贝尔德－福德算法
