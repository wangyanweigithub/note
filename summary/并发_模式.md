
<!-- vim-markdown-toc GFM -->

* [并发 43]
	* [并发模式  44]
		* [服务访问和配置模式 46]
			* [包装器模式 49]
			* [组件配置器 51]
			* [截取器 52]
			* [扩展接口 53]
		* [事件处理模式 55]
			* [反应器(Reactor)/分配器/通知器 56]
			* [主动器(Proactor) 88]
			* [异步完成标记(Asynchronous Completion Token, ACT) 98]
			* [接收器-连接器(Acceptor-Connector) 99]
		* [同步模式 101]
			* [定界加锁(Scoped Locking) 102]
			* [策略花加锁(strategized Locking) 103]
			* [线程安全接口 104]
			* [双检查加锁优化 105]
		* [并发模式 107]
			* [主动对象 108]
			* [监视对象 109]
			* [半同步/半异步 110]
			* [领导者/追随者 111]
			* [线程特定的存储器 112]
	* [python asyncio 114]
		* [高级接口 115]
			* [Tasks 117]
			* [队列集 118]
			* [子进程集 119]
			* [流 121]
				* [protocol/协议 122]
				* [只读协议 123]
				* [只写协议 124]
				* [读写协议 125]
			* [同步 127]
			* [异常 128]
	* [c++ 原生async 130]
	* [boost asyncio 132]

<!-- vim-markdown-toc -->
# 并发 43
## 并发模式  44
> 面向模式的软件体系结构卷2: p5
### 服务访问和配置模式 46
> 设计模式把现有的非面向对象的API所提供的函数和数据,封装在更加简洁/健壮,可移植,可维护的内聚的面向对象类接口中.

#### 包装器模式 49
> 设计模式允许应用程序不必修改,重新编译,静态的重连接应用程序的情况下,在运行...
#### 组件配置器 51
#### 截取器 52
#### 扩展接口 53

### 事件处理模式 55
#### 反应器(Reactor)/分配器/通知器 56
0. 概述:
	- 事件驱动的应用可以多路分解并分配从一个或者多个客户机发送给应用的服务请求.
	- 反应器模式引入的机构"逆转"了应用总的控制流,这就是所说的好莱坞规则:不要打电话给我们,我们会给你打电话

1. 情景:
	同时接收多个服务请求,并且依次同步地处理它们的事件驱动应用程序.

2. 怎样应用反应器:
	由指定的组件"反应器",而不是应用程序负责同步等待指示事件,将它们多路分解给负责处理这些事件的事件处理程序,
然后在实践处理程序上分配合适的钩子方法.尤其是,由反应器分配对某一**事件做出反应**的事件处理程序.
这样开发人员只负责实现具体事件处理程序并重用反应器的多路分解和分配机制.

3. 缺陷:
	它不能同时支持大量的客户机或耗时长的客户机请求,因为它在事件多路分解层<font color=green>串行化</font>了
所有的事件处理程序的处理过程,主动器可以有效减小这种限制.

4. 细节
	- 对于应用程序提供的每个服务,引入一个**单独的事件处理程序**处理某一事件源的某一类型的事件.(!某个socket的某个事件的handler处理程序)
	-  在**反应器**中注册所有的事件处理程序,反应器使用一个**同步事件多路分解器**等待一个或多个事件源的指示事件.(!epoll/select事件循环)
	- 发生指示事件后,同步事件多路分解器通知反应器,后者同步分配与事件相关的事件处理程序,
		以便这些事件处理程序可以执行请求的服务.(!反应其不是epoll,是否是IOLoop)
	
5. 结构: 反应器模式有5个主要组成部分
	- 句柄: 用来识别像网络连接或打开文件这样的事件源,事件源产生指示事件并对它们进行排队
		- 指示事件可以来自外部像connect事件或READ事件,也可以来源与内部,如**超时事件**
		- 一旦一个事件源产生了一个指示事件,该指示事件就被送入相关句柄的队列中,句柄被标示为"就绪"
		- 这样,就可以在句柄中执行一个像accept或者read这样的操作而不会阻塞调用程序.

	- 同步事件多路分解器:一个函数,阻塞,select/epoll
	- 事件处理程序:定义一个或多个钩子方法组成的接口,钩子方法代表了**处理反应器就收并分配的指示事件时可用的服务集**
	- 具体事件处理程序: 实现应用程序所提供的特定服务的事件处理程序
		- 
	- 反应器: 定义了一个接口,允许应用程序注册或删除事件处理程序及其相应的句柄,并运行应用程序的事件循环.

	- 总结:
		1. 网络io中socket是句柄
		2. select/epoll是同步事件多路分解器
		3. get/post/connect/before/after/finally 等等固定的钩子,将某些固定的操作绑定到具体的事件处理程序
		4. 事件handler是具体事件处理程序
		5. IOLoop是reactor,注册,删除事件处理程序,运行epoll事件循环.

6. 控制流倒置:
	- 等待指示事件,多路分解这些事件给它们的具体事件处理程序,**向具体事件处理程序分配相应的钩子方法**,
		所有这些是**反应器**而不是应用程序的责任.

	- 特别是,具体事件处理程序并不调用反应器,而是由反应器分配一个具体处理程序,
		具体事件处理程序对某个指定的事件发生做出反应.这种"控制逆转"又称为"好莱坞原则"

7. 实现: 
	1. 反应器各个部分分两层
		1. 多路分解/分配基础设施层的组件:
			本层执行一个通用的,与应用程序无关的策略,用于将指示事件多路分解到事件处理程序,然后分配相应的事件处理程序钩子方法.

		2. 应用层组件
			本层定义具体事件处理程序,再具体事件处理程序的钩子方法中进行与应用有关的处理.

	2. 步骤
		1. 定义事件处理程序接口: 
		> 事件处理程序具体指定了由一个或几个钩子方法组成额接口,这些钩子方法代表了处理由反应器接收并分配的指示事件时可用的服务集.

			1. 确定分配目标的类型:
				1. 事件处理程序对象
				> 将事件处理程序与句柄结合起来建立一个事件处理程序对象.

				2. 事件处理程序函数: 向反应器而不是对象注册函数指针

				3. 可以使用**适配器**模式同时支持对象和指针.

			2.确定事件处理程序分配接口策略: 
				1. 单方法分配接口策略
				> 事件处理对象只包括一个事件处理方法.放映器用此方法分配事件,将所发生事件的类型作为参数传递给方法.
				> 这样会导致事件处理方法会有大量switch匹配事件类型.

				2. 多方法分配借口策略:
				> 为处理每一类事件(如输入,超时)创建一个单独的钩子方法.
				> 这样更具扩展性,因为是由反应器实现而不是具体事件处理程序handle_event()方法来进行多路分解.

		2. 定义反应器接口: 
		> 应用程序使用放映器借口注册或者删除事件处理程序及相应的句柄,并调用应用程序的事件循环.
		> 通常使用单实例访问反应器借口,因为一个应用进程有一个反应器就够了.
		> 为了将应用程序和不同操作系统平台所具有的复杂,不可移植的多路分解和分配机制分开,反应器模式可以使用**桥(bridge)模式**.
			1. register_handler/remove_handler
			2. instance(单实例)
			3. `handle_events`:
				- 主入口点方法,调用同步事件多路分解器,等待事件发生,分解事件到它们对应的处理方法
				- 可以使用timeout参数限制等待指示事件的时间.
				- 一旦句柄集上发生一个或者多个事件,同步事件多路分解器函数就会返回,此时handler_event()方法做出"反应",
					将指示事件多路分解到与每个句柄相关的已就绪的事件处理程序,然后分配处理程序的钩子方法来处理事件.

		3. 实现反应器接口
			1. 开发反应器的实现层次:
				
			2. 选择一种同步事件多路分解器机制

			3. 实现一个多路分解表:
				- 格式: <句柄,事件处理程序,指示事件类型>的三元组

			4. 定义反应器的具体实现: 
				- 反应器接口中有一个指向反应器具体实现的指针,并将所有的方法调用传给该指针.
				- 反应器的私有部分中有一个事件处理程序多路分解表

		4. 确定应用程序所需要的反应器数量

		5. 实现具体事件处理程序
			1. 确定维护具体事件处理程序状态的策略
				一个事件处理程序需要维护与特定请求有关的状态信息.

			2. 实现用一个句柄配置各具体事件处理程序的策略: 具体事件处理程序对句柄执行有关操作. 两个策略:
				1. 硬编码
				2. 类属方法

			3. 实现具体事件处理程序的功能.
				

#### 主动器(Proactor) 88
1. 概述
	- 在主动器模式中,客户机和完成处理程序多代表的应用组件称为**主动性实体**.
	- 和被动地等待<font color=green>指示事件的到达并作出响应的反应器模式不同</font>, 
	<font color=red>主动器模式中的客户机和完成处理程序通过在一个异步操作处理器中主动地初始化
	一个或者多个异步操作请求,引起应用程序内部的控制流和数据.</font>
	
	- 异步操作完成后,异步操作处理器和指定的主动器组件协作,将产生的完成事件多路分解给相关的完成处理程序,
	并分配这些处理程序的钩子方法.

#### 异步完成标记(Asynchronous Completion Token, ACT) 98
#### 接收器-连接器(Acceptor-Connector) 99

### 同步模式 101
#### 定界加锁(Scoped Locking) 102
#### 策略花加锁(strategized Locking) 103
#### 线程安全接口 104
#### 双检查加锁优化 105

### 并发模式 107
#### 主动对象 108
#### 监视对象 109
#### 半同步/半异步 110
#### 领导者/追随者 111
#### 线程特定的存储器 112

## python asyncio 114
### 高级接口 115
> asyncio/api.md
#### Tasks 117
#### 队列集 118
#### 子进程集 119

#### 流 121
##### protocol/协议 122
##### 只读协议 123
##### 只写协议 124
##### 读写协议 125

#### 同步 127
#### 异常 128

## c++ 原生async 130

## boost asyncio 132
