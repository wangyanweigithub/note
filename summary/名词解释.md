### 一、名字解释

1. 常量：

	1. 保存在data区
	
2. 变量：

	1. 声明一个变量只是将变量名标识符的有关信息告诉编译器，使编译器"认识"该标识符.
	2. 但是声明并不一定引起内存的分配！
	3. 而定义一个变量意味着给变量分配内存空间，用于存放对应类型的数据，变量名就是对相应的内存单元的命名！
	4. 变量必须有自己的类型。

3. 对象：

	1. 内存中具有类型的区域 

4. 池化：

5. 声明和定义：

### 二、关键字

1. final、static、const：
 
	1. final：修饰常量或类，所修饰的类不可做父类，原子类 
	2. const：修饰常量 
	3. static：修饰类方法

2. external：

3. new、delete：
 
  	1. delete应该只用来删除new创建的指针。
	2. 只有new创建的变量用堆的内存 
	3. delete删除内存后，指针还存在，要把它置为0


### 四、特殊类型

1. 数组：
	1. 数组类型变量有三个重要限制： 
	
		1. 数组长度固定不变
		1. 在编译时必须知道其长度
		1. 数组只在定义它的块语句内存在

2. 动态数组： 

	1. 数组长度固定，但是动态分配的数组不必在编译时知道其长度，可以再运行时才确定长度
	
	2. <font color=red>与数组变量不同，动态分配的数组将一直存在，直到程序显示释放它</font>。

	3. 在堆中分配： c使用malloc和free， c++使用new和delete
	
	4. 创建： int *pia = new int[10]
	
	5. 初始化： 可以使用()来初始化：  
		
			int  *pia  =  new  int[10]()
	
	6. const 动态数组必须初始化
	
	7. 释放空间： delete [] eg、delete [] pia; [] 必不可少，他告诉编译器该指针指向的是自由存储区中的数组，而不是单个对象。如果少了[],将导致运行时出错。

	8. **<font color=green>注意：</font>**
		1. 自由存储区（堆）中创建的数组对象是没有名字的，程序员只能通过其地址间接地访问堆中的对象
		2. c++ 的数组不能复制


### 语句
1. 一元操作符 二元操作符 三元操作符: 
	1. 操作符的结合性：左结合和右结合：连等的实现，和连着输出的实现 

### 函数

1. 函数是一个作用域 
2. 每次调用函数，都会重新创建该函数所有的形参，此时传递的实参将会初始化对应的形参 
3. 传递给函数的实参是字符串的话，类型是const char *
4. 注意：
	1. 形参具有非引用类型，则复制实参的值，如果形参为引用类型，则它只是实参的别名。 
		1. 非引用形参： 普通的非引用类型的参数通过复制对应的实参实现初始化 
			1. 指针形参 ：指针是复制，但可改变指针指向的值
			2. const形参 ：
	
				1. 指针初始化规则：可以将指向const对象的指针初始化为指向非const对象，但不可以让指向非const对象的指针指向const对象
				
				2. <font color=green>**解释**</font> 定义严格的数据可以由不严格的数据初始化，因为类型决定在其上进行的所有操作，严格的类型操作比不严格的少切严格，所以不会进行非法操作，反之则不行。除非可以隐式转换。所有的变量类型，可以有不严格的转换为严格的，可能损失精度、操作方法不能相反。
				
			3. 复制实参的局限性
				1. 需要在函数中修改实参的值
				2. 需要传递大型对象作为实参，时间和空间成本太高
		  		3. 没有办法实现对象的复制
		  		4. **解决**：将形参定义为引用或指针类型

		2. 引用形参 
			0. c语言使用指针来操作，c++用引用来操作
		
			1. 使用引用形参返回额外的信息 
				1. 函数只能返回一个值，如果要返回多个值，就可以给函数传入一个额外的引用参数
				
			2. 利用const引用避免复制 
				1. 如果使用引用形参的唯一目的是避免复制实参，则应将形参定义为const引用
			 
			3. 更灵活的指向const的引用 
				1. 应该讲不需要修改的引用形参定义为const引用，普通的非const引用形参在使用时不太灵活。这样的形参既不能用const对象初始化，也不能用字面值或产生右值的表达式实参初始化。（字面值相当于const  char  *）

			4. 传递指向指针的引用
			
	2. vecotr形参，
		1. 通常，函数不应该有vector或其他标准库容器类型的形参，因为调用含有普通的非引用vector形参的函数将会复制vector的每一个元素。
		2. C++程序员倾向于通过传递指针向容器中需要处理的元素的迭代器来传递容器。

	3. 数组形参：
		1. 数组的两个特殊性质：
			1. 不能复制数组
			2. 使用数组名字时，数组名会自动转化为指向其第一个元素的指针。
		2. 所以数组形参不能是复制整个数组，只能是指针
		3. 编译器忽略为任何数组形参指定的长度，仅仅表示为一个指针
		4. 当编译器检查数组形参关联的实参时，他只会检查实参是不是指针、指针的类型和数组元素的类型是否匹配，而不会检查数组的长度。所以可能会有错误输出或者运行时错误。
		5. 数组以普通的非引用类型传递，此时数组会悄悄的转换为指针。非引用类型的形参会初始化为其相应实参的副本。不需要修改数组形参时，函数应该讲形参定义为指向const对象的指针。
		6. 通过引用传递数组如果形参是数组的引用，编译器不会将数组实参转化为指针，而是传递数组的引用本身。在这种情况下，数组大小成为形参和实参类型的一部分，编译器检查数组实参的大小与形参的大小是否匹配。
			1. eg.
			
					void  printValues(int  (&arr)  [10])  {}
					&arr两边的圆括号是必须的，因为下标操符作具有更高的优先级
		7. 非引用数组形参的类型检查只是确保实参是和数组元素具有同样类型的指针，而不会检查实参实际上是否指向指定大小的数组。
		8. 任何处理数组的程序都要确保程序停留在数组的边界内。
		9. 有三种常见的编程技巧确保函数的操作不超出数组实参的边界。
			1. 在数组本身放置一个标记来检测数组的结束，如c风格字符串空字符
			2. 标准库规范，传递指向数组第一个和最后一个元素的下一个位置的指针。
			3. 显示传递表示数组大小的形参。
			
	2. 函数返回值不能是函数和数组，但可以是指向他们的指针 
	3. 函数只能返回单个值，如果要返回多个值，需要加上引用形参来实现，或者实现一种新类型，注意不能是数组。

5. 局部作用域（static）： 
	1. 自动对象：局部变量的生命周期局限于所在函数的每次执行期间，只有当定义它的函数被调用时才存在的对象称为自动对象，自动对象在每次调用函数时创建和撤销。 
	2. 一个变量如果位于函数的作用域内，但生命周期却跨越了这个函数的多次调用，则应该将这样的对象定义为static(静态的).

6. static 局部对象：
	1. 确保不迟于在程序执行流程第一次经过该对象的定义语句时进行初始化。 
	2. 这种对象一旦被创建，在程序结束前都不会被撤销。
	3. 当定义静态局部对象的函数结束时，静态局部对象不会撤销。
	4. 在该函数被多次调用的过程中，静态局部对象会持续存在并保持它的值。

7. 内联函数 
	1. 调用函数比解等价表达式要慢得多。
	2. 在大多数机器上，调用函数都要做很多工作：
		1. 调用前要先保存寄存器，并在返回时恢复；
		2. 复制实参；
		3. 程序还必须转向一个新的位置执行。 
	3. 内联函数应该在头文件中定义，是定义不是声明，编译器必须能看到，以便在调用点内联展开该函数的代码。此时，仅有函数原型是不够的。

	4. 在头文件中加入或修改内联函数时，使用了该头文件的所有源文件都必须重新编译。

8. main

		int  main()
		int  main(int  argc,  char  *argv[])
		int  main(int  argc,  char  **argv)

9. 可变形参函数
 
		void  foo(param_list,  ...);
		void  foo(...);
		常用第一种，由第一个参数决定后面会含有哪些参数


### 三、 注意
1. 类型决定了分配给变量的大小和其上可以进行的操作。
2. 千万不能返回局部变量的引用。
3. 默认实参：如果有一个形参具有默认实参，那么它后面所有的形参都必须有默认实参，否则会区分不清楚实参是绑定到那个形参。java  没有默认实参。