### 程序是怎样跑起来的
#### 1. cpu
1. CPU 内部结构解析
	1. 内部寄存器
	2. 控制器
	3. 运算器
	4. 时钟

2. CPU是寄存器的集合体
	1. 累加寄存器
	2. 标志寄存器
	3. 程序计数器
	4. 基址寄存器
	5. 变址寄存器
	6. 通用寄存器
	7. 指令寄存器
	8. 栈寄存器

3. 决定程序流程的程序计数器

4. 条件分支和循环机制
	1. 顺序执行
	2. 条件分支
	3. 循环
	4. jump 实现了2 和3

5. 函数的调用机制
	1. 将程序计数器设置为函数的存储地址
	2. 执行完函数后，将程序计数器设置为函数调用指令的下一个地址
	3. jump 不能记录函数执行完后的地址，所以函数调用用call和return
		1. 在将函数的入口地址设定到程序计数器之前，call指令会把调用函数后要执行的指令地址存储在名为栈的主存中
		2. 函数处理完毕后，通过函数的出口来执行return命令。return命令的功能是把存储在栈中的地址设定到程序计数器中

6. 通过地址和索引实现数组

7. CPU的处理其实很简单

#### 2. 数据是用二进制数表示的

#### 3. 计算机进行小数运算时出错的原因
1. 将0.1累加100次也得不到10（python 验证）
2. 用二进制数表示小数
3. 计算机运算出错的原因
4. 什么是浮点数
5. 正则表达式和EXCESS系统
6.在实际的程序中进行确认
7. 如何避免计算机出错
8. 二进制数和十六进制数

#### 4. 熟练使用有棱有角的内存
1. 内存的物理机制很简单
	1. 内存IC 中有电源、地址信号、数据信号、控制信号等用于输入输出的大量**引脚**
	
	2. 引脚：
		1. VCC、GND 是电源
		2. A0~A9是地址信号的引脚
		3. D0~D7是数据信号的引脚
		4. RD和WR是控制信号的引脚

	3. 容量
		1. 数据信号决定了一次输入输出的数据的位的个数
		2. 地址信号引脚个数决定了可寻址的大小
		3. 容量等于 一次输出位数 * 寻址空间大小

2. 内存的逻辑模型是楼房
3. 简单的指针
4. 数组是高效使用内存的基础
5. 栈、队列以及环形缓冲区
6.链表使元素的追加和删除更容易
7. 二叉查找树使数据搜索更有效

#### 5. 内存和磁盘的亲密关系
1. 不读入内存就无法运行
2. 磁盘缓存加快了磁盘访问速度
3. 虚拟内存把磁盘作为部分内存来使用	
4. 节约内存的编程方法
	1. 使用动态链接库dll，在程序执行时，多个程序可以动态调用dll。将函数编译进各个独立的执行文件的是静态连接。
	2. 使用_stdcall 来减少程序文件的大小。清理栈的动作由调用方执行换成由被调用方执行清理栈。

5. 磁盘的物理结构
	1. 扇区是对磁盘进行物理读写的最小单位，一般一个扇区512字节。
	2. 逻辑方面对磁盘进行读写的是扇区的整数倍:簇。软盘的一簇等于一扇区，硬盘都是整数倍。
	3. 不同的文件不能存储在同一个簇中，否则就会导致一方的文件不能被删除。不管多小的文件，都会占用一簇的空间。
	4. 以簇为单位进行读写，1簇中没有被填满的区域会保持不被使用的状态浪费掉。

#### 6. 亲自尝试压缩数据
1. 文件以字节为单位保存

2. RLE算法的机制

3. RLE算法的缺点
	1. 每个字符跟着字符重复的次数，对图片格式压缩比较好，对文本文件不友好，压缩有可能扩大了。

4. 通过莫尔斯编码来看哈夫曼算法的基础

5. 用二叉树实现哈夫曼编码
	1. 通过构造二叉树来构造哈夫曼树，就可以不需要间隔符来区分各个字符的编码。

6. 哈夫曼算法能够大幅度提升压缩比率

7. 可逆压缩和非可逆压缩
	1. 图片的格式jpeg是不可逆压缩，不需要和原来的一样。

#### 7. 程序是在何种环境中运行的
1. 运行环境 = 操作系统 + 硬件
2. Windows克服了CPU以外的硬件差异
	1. 不同的CPU拥有不同的指令集。所以需要将代码编译为本地代码（机器语言代码）。
	2. 所以所有的代码都要根据cpu来决定编译的结果。

3. 不同操作系统的API不同

4. FreeBSD Port帮你轻松使用源代码
	1. 因为不同的CPU的本地代码不同，导致不能移植，直接将程序源码发送到本地，然后根据本地代码（机器语言代码），编译源文件。

5. 利用虚拟机获得其他操作系统环境

6. 提供相同运行环境的java虚拟机
	1. 不同系统的java虚拟机不同，因为虚拟机的功能是将字节码编译为本地代码。不同的CPU架构，虚拟机可能不一样。
	2. 所以可能出现在一种虚拟机可以运行的代码在另外平台的java虚拟机不能运行。
	
7. BIOS 和引导

#### 8. 从源程序到可执行文件
1. 计算机只能运行本地代码
	1. CPU能直接解析并运行的不是源代码而是本地代码的程序。
	2. 本地(native)有“母语的”意思，对CPU来说，母语就是机器语言，而转换成机器语言的程序就是本地代码。
	3. 用任何编程语言编写的源代码，最后都要翻译成为本地代码，否则CPU不能理解。

2. 本地代码的内容
	1. 将EXE文件内容Dump一下就是每个字节用2位十六进制的数来表示，发现本地的代码内容全是各种数值的罗列
	2. 每个数值代表一个命令或者数据。例如A这个字符就是十六进制的41.

3. 编译器负责转换源代码
	1. 能够把C语言等高级编程语言编写的源代码转换成本地代码的程序成为编译器。
	2. 每个编写源代码的编程语言都需要其专用的编译器
	3. 根据CPU类型的不同，本地代码的类型也不相同。因此，编译器不仅和编程语言种类有关，和CPU类型也是相关的。
	4. 交叉编译，它生成的是和运行环境中的CPU不同的CPU所使用的本地代码。

4. 仅靠编译器无法得到可执行文件
	1. 编译后生成的不是EXE文件，而是扩展名为".obj"的目标文件
	2. 目标文件是本地代码，但是却无法直接运行，原因是当前程序还处于未完成状态。
	3. 将代码中所引用的库函数文件的目标文件结合才得到完整的程序本地代码。
	4. 将多个目标文件结合，生成1个EXE文件的处理就是链接。运行连接的程序就称为链接器。
	
5. 启动及库文件
	1. 像import32.lib及cw32.lib这样的文件称为库文件。
	2. 库文件指的是把多个目标文件集合保存到一个文件中的形式，链接器指定库文件后，就会从中把需要的目标文件抽取出来，
	并同其他目标文件结合生成EXE文件。
	3. 将标准函数使用库一起链接，是为了简化为链接器的参数指定多个目标文件这一过程。
	4. 库文件可以将许多标准函数的目标文件集合成为库文件。
	5. 库文件有保密的作用。

6. DLL文件及导入库
	1. DLL文件是程序运行时动态结合的文件。
	2. 导入库，在库文件中并不实际存在目标函数的实体，而是保存了
		1. 这个函数实体在那个DLL文件中
		2. 这个存储着DLL文件的文件夹信息。
	3. 与导入库相反，存储着目标文件的实体，并直接和EXE文件结合的库文件形式成为静态连接库。
	4. 源码 -> 目标文件(.obj) -> 静态连接 -> 从导入库中抽取DLL函数信息 -> EXE 可执行文件 -> 运行时结合DLL文件的动态链接。

7. 可执行文件运行时的必要条件
	1. EXE文件中，变量和函数的内存地址是如何来表示的？
		1. EXE文件中给变量及函数分配了虚拟的内存地址
		2. 在程序运行时，虚拟的内存地址会转换成实际的内存地址。
		3. 编译器会在EXE文件的开头，追加转换内存地址所需的必要信息，这个信息称为再配置信息。
		4. EXE文件的再配置信息，就成为了变量和函数的相对地址。相对地址表示的是相对于基点地址的偏移量。
		5. **在源代码中，虽然变量及函数是在不同位置分散记述的，但是在链接后的EXE文件中，变量及函数就会变成一个连续排列的组**
		6. 这样，各变量的内存地址就可以用相对于变量组其实位置这一基点的偏移量来表示，
		同样，各函数的内存地址也可以用相对于函数组起始位置这一基点的偏移量表示。
		7. 而各组基点的内存地址则是在程序运行时被分配的。
		8. ![链接后的EXE文件的构造](G:\picture\program_graph\EXE_file_construct.PNG)

8. 程序加载时会产生栈和堆
	1. EXE 文件内容分为：
		1. 再配置信息
		2. 变量组
		3. 函数组
	
	2. 程序加载到内存中，除此之外还会额外生成两个组：栈和堆
		1. 栈是用来存放函数内部临时使用的变量(局部变量)，以及函数调用时所用的参数的内存区域。
		2. 堆是用来存放程序运行时的任意数据及对象的内存领域。

	3. EXE 文件并不存在栈及堆的组。

	4. 堆和栈都是在程序运行时得到申请分配的。

	5. 在内存使用上，二者不同。
		1. 栈中对数据进行存储和舍弃(清理处理)的代码，是有编译器自动生成的
		2. 使用栈的数据的内存空间，每当函数被调用时都会得到申请分配，并在函数处理完毕后自动释放。
		3. 堆的内存空间，则要根据程序员编写的程序，来明确进行申请分配或释放。

	6. 对堆用的内存空间进行申请分配和释放
		1. c：malloc() 和free()
		2. c++: new和delete

9. 有点难度的Q&A
	1. 将多个目标文件结合生成EXE文件的工具是链接器
	2. CPU可以解析和运行的程序形式成为机器代码（本地语言代码）
	3. 扩展名为.obj的目标文件是本地代码
	4. 把多个目标文件收录在一起的文件成为库文件
	5. 仅包含Windows的DLL文件中存储的函数信息的文件称为导入库
	6. 在程序运行时，用来动态申请分配的数据和对象的内存区域的形式成为堆
	7. 不适用导入库，通过使用LoadLibrary()及GetProcAddress()这些API，即使不链接导入库，也可以在程序运行时调用DLL文件的函数。但使用导入库更简单一些。

10. 编译过程
	1. 通过编译源代码得到本地代码
	2. 通过编译和链接，得到EXE文件
	3. 通过对原文件进行编译，得到目标文件。例如将Sample.c编译后得到Sample.obj目标文件，目标文件是本地代码。
	4. 链接器会从库文件中抽取出必要的目标文件并将其结合到EXE文件中。此外，还存在一种程序运行时结合的DLL形式的库文件。
	5. 把导入库信息结合到EXE文件中，这样程序在运行时就可以利用DLL内的函数了。
	6. 堆的内存空间会根据程序的命令进行申请及释放。

11. 内存五大区域
	1. 栈---局部变量，当局部变量的作用域，被执行完毕之后，这个局部变量就会被系统立即回收
	2. 堆---程序猿手动申请的字节空间，Malloc calloc?realloc
	3. BBS段----未被初始化的全局变量和静态变量 ?一般初始化就回收，并转存到数据段中
	4. 数据段（常量区）----已经被初始化的全局静态变量常量数据，知道程序结束的时候才会被回收
	5. 代码段----存储代码，存储程序的代码

12. 类加载
	1. 在程序运行期间，当某个类第一次被访问到的时候，会将这个类存储到内存中的代码段区域，这个过程，叫做类加载。代码段
	2. new函数实际申请对象
	3. 在堆内存中申请合适的空间，在申请的堆空间中，根据类的模板，创建对象。
	4. 类模板中定义了什么属性，就把这些属性声明再这些对象之中 
	5. 对象还有个属性叫做isa，是一个指针，指向对象属性的类，再代码中的地址。
	6. 初始化对象的属性
		1. 如果属性的类型是基本数据类型，那么就是赋值
		2. 如果属性是C语言中的指针类型，那么就是NULL
		3. 如果属性是OC语言中的，那么是nil
	7. 返回对象的地址。
	8. 注意：对象中只有属性，没有方法，自己类的属性，外加一个isa指针，指向代码段中的类。
		1. 如何访问对象的属性：指针名字->属性名（根据指针，找到指针指向的对象，再找到对象中的属性来访问）
		2. 如何调用方法：现根据指针的找到对象，对象发现要调用方法，在分局对象的isa指针找到类，然后调用类里面的方法
		3. 为什么不把方法存储在对象之中：因为一个对象的方法代码实现是一模一样，就没必要为每个对象保存一个方法，这样提浪费空间，所以只保留1分就行了

#### 9. 操作系统和应用的关系
1. 操作系统功能的历史
2. 要意识到操作系统的存在
3. 系统调用和高级编程语言的移植性
4. 操作系统和高级编程语言使硬件抽象化
5. Windows 操作系统的特征

#### 10. 通过汇编语言了解程序的实际构成
1. 汇编语言和本地代码是一一对应的
2. 通过编译器输出汇编语言的源代码
3. 不会转换成本地代码的伪指令
4. 汇编语言语法是"操作码 + 操作数"
5. 最常用的mov指令
6. 对栈进行push和pop
7. 函数调用机制
8. 函数内部的处理
9. 始终确保全局变量用的内存空间
10.  临时确保局部变量的内存空间
11. 循环处理的实现方法
12. 条件分支的实现方法
13. 了解程序运行方式的必要性

#### 11. 硬件控制方法
0. 热身
	1. 在x86系列CPU用的汇编语言中，通过IN指令来实现I/O输入，OUT指令来实现I/O的输出
		1. IN指令通过指定端口号的端口输入数据，并将其存储在CPU内部的寄存器中
		2. OUT指令则是把CPU寄存器中存储的数据，输出到指定端口号的端口。

	2. 用来实现计算机主机和外围设备输入输出交互的IC称为I/O控制器或简称I/O。
	3. 所有连接到计算机的外围设备都会分配一个I/O地址编号。
	4. DMA指的是，不经过CPU中介处理，外围设备直接同计算机的主内存进行数据传输。
	5. 像磁盘这样用来处理大量数据的外围设备都具有DMA功能。

1. 应用和硬件无关？
2. 支撑硬件输入输出的IN指令和OUT指令
3. 编写测试用的输入输出程序
4. 外围设备的中断请求
5. 用中断来实现实时处理
6. DMA可以实现短时间内传送大量数据
7. 文字及图片的显示机制

#### 12. 让计算机“思考”
1. 作为"工具"的程序和为了”思考”的程序
2. 用程序来表示人类的思考方式
3. 用程序来表示人类的思考习惯
4. 程序生成随机数的方法
5. 活用记忆功能以达到更接近人类的判断
6. 用程序来表示人类的思考方式
