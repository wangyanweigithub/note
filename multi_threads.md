## condition
###使用场景
1. 某一个数据暂时没有,程序可以阻塞或者异步的等待这个数据,当数据完成时**需要主动通知程序**.

### 一般用法
1. 在共享的数据里面:
	- 定义condition
	- 定义需要通知事件循环的地方,也就是notify_one或者notify_all
	- <font color=green>一般在共享数据里面没有使用wait的地方,
	一般是程序其它地方使用wait,然后当数据准备好后,notify通知程序继续执行.</font>

2. 使用condition的地方是共享变量,其他读取共享变量的地方需要wait等待,而共享变量本身只需要知道什么时候唤醒等待的程序即可(notify)

### 有了锁还要condition
1. 只有锁而没有condition的话,那些等待共享变量的地方需要先加锁,
然后判断共享变量是否满足条件,如果不满足,需要在释放锁,
然后在定时获得锁再判断,非常麻烦.

2. 使用condition后,从获得锁改为等待某个共享状态满足才继续执行.
而定时获得锁也改为notify更加节省cpu.

3. 为什么需要使用Condition(什么时候需要使用await/signalAll/signal方法)？

	因为有时候获得锁的线程发现其某个条件不满足导致不能继续后面的业务逻辑，
此时该线程只能先释放锁，等待条件满足。

	那可不可以不释放锁的等待呢？比如将await方法替换为sleep方法(这也是面试经常
问的await和sleep的区别)？

	显然不行，因为等待的条件显然和共享的资源是有关的，在这个例子里，
take方法会等待notEmpty条件，notEmpty指的是items不为空，意味着此时items是空的，
那么就只有对items执行add操作，即其它线程调用put方法才有机会达到notEmpty的条件，
所以如果使用sleep(不释放锁)来等待而不是await(释放锁)来等待，
则会导致notEmpty这个条件永远满足不了。
    总结起来，就是获得锁的线程发现某个条件不满足而不能继续执行，而且该条件需要其它线程对共享资源进行操作才能触发，所以必须释放锁。

