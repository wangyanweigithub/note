
<!-- vim-markdown-toc GFM -->

* [一. 概念 166](#一-概念-166)
	* [1. 声明 169](#1-声明-169)
* [二. 输入输出和基础 362](#二-输入输出和基础-362)
	* [printf和scanf 363](#printf和scanf-363)
		* [3. scanf 375](#3-scanf-375)
		* [4. 易混淆 380](#4-易混淆-380)
		* [5. 读写字符串 384](#5-读写字符串-384)
		* [6. 流 425](#6-流-425)
		* [7. 文件操作 435](#7-文件操作-435)
	* [2. 基本数据结构 527](#2-基本数据结构-527)
	* [3. 基本语法 532](#3-基本语法-532)
		* [1. 表达式 533](#1-表达式-533)
		* [2. 语句 578](#2-语句-578)
		* [2. 重复语句 617](#2-重复语句-617)
		* [3. 跳转语句 634](#3-跳转语句-634)
		* [4. 复合语句 645](#4-复合语句-645)
		* [5. 空间语句 648](#5-空间语句-648)
		* [3. 函数 654](#3-函数-654)
		* [3. 函数声明 661](#3-函数声明-661)
		* [5. 实际参数 667](#5-实际参数-667)
		* [4. 程序终止 735](#4-程序终止-735)
		* [5. 问答 743](#5-问答-743)
	* [3. 主要语言构造 764](#3-主要语言构造-764)
		* [1. 指令	 765](#1-指令-765)
		* [3. 语句 773](#3-语句-773)
		* [4. 注释 779](#4-注释-779)
		* [1. //单行 780](#1-单行-780)
		* [2. ```/*  */```可以有多种方式。 781](#2---可以有多种方式-781)
		* [5. 变量和赋值 783](#5-变量和赋值-783)
		* [1. 类型： 784](#1-类型-784)
		* [2. 声明 791](#2-声明-791)
		* [3. 赋值 801](#3-赋值-801)
		* [4. 初始化 804](#4-初始化-804)
		* [5. 读入输入 817](#5-读入输入-817)
		* [6. 定义常量的名字 823](#6-定义常量的名字-823)
		* [7. 标识符 829](#7-标识符-829)
		* [6. C89关键字  832](#6-c89关键字--832)
		* [5. 有关语句的类型： 890](#5-有关语句的类型-890)
		* [7. C99关键字 893](#7-c99关键字-893)
		* [1. _Bool 894](#1-_bool-894)
		* [2. _Complex 899](#2-_complex-899)
		* [3. _Imaginary 907](#3-_imaginary-907)
		* [4. inline 910](#4-inline-910)
		* [5. restrict 928](#5-restrict-928)
		* [8. C11关键字 948](#8-c11关键字-948)
		* [1. _Alignas 949](#1-_alignas-949)
		* [2. _Alignof 980](#2-_alignof-980)
		* [3. _Atomic 986](#3-_atomic-986)
		* [4. _Generic 1006](#4-_generic-1006)
		* [5. _Noreturn 1033](#5-_noreturn-1033)
		* [6. _Static_assert 1049](#6-_static_assert-1049)
		* [7. _Thread_local 1057](#7-_thread_local-1057)
		* [9. 程序结构 1065](#9-程序结构-1065)
		* [1. 局部变量 1066](#1-局部变量-1066)
		* [2. 外部变量 1081](#2-外部变量-1081)
		* [3. 程序块  1086](#3-程序块--1086)
		* [4. 作用域 1098](#4-作用域-1098)
* [三.高级数据结构  1100](#三高级数据结构--1100)
	* [1. 数组 1101](#1-数组-1101)
		* [1. 一维数组 1107](#1-一维数组-1107)
		* [2. 多维数组 1142](#2-多维数组-1142)
		* [3. 常量数组 1157](#3-常量数组-1157)
		* [4. 变长数组 1162](#4-变长数组-1162)
	* [2. 结构、联合、枚举 1187](#2-结构联合枚举-1187)
		* [1. 结构 1188](#1-结构-1188)
		* [2. 结构类型 1231](#2-结构类型-1231)
		* [3. 联合 1300](#3-联合-1300)
		* [3. 枚举 1361](#3-枚举-1361)
* [四. 字符串处理：替换，查找、截断 1403](#四-字符串处理替换查找截断-1403)
	* [1. 字符基础 1404](#1-字符基础-1404)
		* [1. 字符字面量 1405](#1-字符字面量-1405)
		* [2. 字符串变量 1431](#2-字符串变量-1431)
		* [3. 字符串的库函数 1451](#3-字符串的库函数-1451)
	* [2. Regex 1511](#2-regex-1511)
	* [3. Parser 1512](#3-parser-1512)
	* [<font color=green>4. 字符编码</font> 1513](#font-colorgreen4-字符编码font-1513)
* [五. 基本面向对象或函数式编程的特征 1515](#五-基本面向对象或函数式编程的特征-1515)
	* [1. 继承 1516](#1-继承-1516)
	* [2. 多态 1517](#2-多态-1517)
	* [3. Lambda 函数 1518](#3-lambda-函数-1518)
* [六. 调试：TDD技能 1520](#六-调试tdd技能-1520)
	* [1. 异常 1521](#1-异常-1521)
	* [2. 错误处理 1522](#2-错误处理-1522)
	* [3. 断言 1523](#3-断言-1523)
	* [4. 日志 1524](#4-日志-1524)
	* [5. 调试支持 1525](#5-调试支持-1525)
	* [<font color=green>6. 单元测试</font> 1526](#font-colorgreen6-单元测试font-1526)
* [<font color=green>七. 运行时</font> 1528](#font-colorgreen七-运行时font-1528)
	* [1. 程序代码和可执行代码的组织机制 1529](#1-程序代码和可执行代码的组织机制-1529)
	* [2. 运行时模块加载 1530](#2-运行时模块加载-1530)
	* [3. 符号查找机制 1531](#3-符号查找机制-1531)
* [八. 流 1533](#八-流-1533)
	* [1. 基本输入输出 1534](#1-基本输入输出-1534)
	* [2. 文件处理 1535](#2-文件处理-1535)
	* [3. 输入输出流类的组织 1536](#3-输入输出流类的组织-1536)
* [九. 事件驱动 1538](#九-事件驱动-1538)
	* [1. callback 方法调用 1539](#1-callback-方法调用-1539)
	* [2. 如何支持事件驱动编程模型 1540](#2-如何支持事件驱动编程模型-1540)
* [十. 序列化和反序列化 1543](#十-序列化和反序列化-1543)
	* [1. 缺省机制 1544](#1-缺省机制-1544)
* [十一. regex和XML处理问题，可以跳过 1546](#十一-regex和xml处理问题可以跳过-1546)
* [十二. 并发 1548](#十二-并发-1548)
	* [1. 线程 1549](#1-线程-1549)
	* [2. 进程 1550](#2-进程-1550)
	* [3. 并发 1551](#3-并发-1551)
	* [4. 异步调用 1552](#4-异步调用-1552)
* [十三. <font color=green>动态编程</font> 1554](#十三-font-colorgreen动态编程font-1554)
	* [1. 反射 1555](#1-反射-1555)
	* [2. 元数据编程 1556](#2-元数据编程-1556)
	* [3. 数据和程序之间的相互转化机制 1557](#3-数据和程序之间的相互转化机制-1557)
	* [4. 运行时编译和执行的机制 1558](#4-运行时编译和执行的机制-1558)
* [十四. 语言常用的特色feature 1560](#十四-语言常用的特色feature-1560)
	* [1. 指针 1561](#1-指针-1561)
		* [1. 指针变量 1562](#1-指针变量-1562)
		* [2. 指针变量的声明 1568](#2-指针变量的声明-1568)
		* [3. 取地址符 1572](#3-取地址符-1572)
		* [4. 指针赋值 1581](#4-指针赋值-1581)
		* [8. const int *p 和 int * const p: 1594](#8-const-int-p-和-int--const-p-1594)
	* [2. 指针与数组 1599](#2-指针与数组-1599)
		* [2. 指针用于数组处理 1610](#2-指针用于数组处理-1610)
		* [3. 用数组名作为指针 1623](#3-用数组名作为指针-1623)
		* [4. 指针和多维数组 1632](#4-指针和多维数组-1632)
		* [5. C99 中的指针和变长数组 1677](#5-c99-中的指针和变长数组-1677)
		* [6. 问答 1700](#6-问答-1700)
	* [3. 指针的高级应用 1707](#3-指针的高级应用-1707)
		* [1. 动态存储分配 1709](#1-动态存储分配-1709)
		* [2. 动态分配字符串 1722](#2-动态分配字符串-1722)
		* [4. 指向函数的指针 1763](#4-指向函数的指针-1763)
		* [5. 受限指针 1770](#5-受限指针-1770)
		* [6. 灵活的数组成员 1779](#6-灵活的数组成员-1779)
		* [7.问答 1814](#7问答-1814)
	* [4. 预处理器 1819](#4-预处理器-1819)
		* [1. 预处理器的最主要能力：](#1-预处理器的最主要能力)
		* [2. 宏定义 1821](#2-宏定义-1821)
		* [3. 条件编译 1944](#3-条件编译-1944)
		* [4. 其他指令 1981](#4-其他指令-1981)
		* [5. 问答 1988](#5-问答-1988)
	* [5. 大型程序源文件结构 1991](#5-大型程序源文件结构-1991)
		* [1. 源文件 1992](#1-源文件-1992)
		* [2. 头文件 1998](#2-头文件-1998)
		* [3. 把程序划分为多个文件 2022](#3-把程序划分为多个文件-2022)
	* [6. 其他 2025](#6-其他-2025)
		* [1. c程序通常包含3个步骤 2026](#1-c程序通常包含3个步骤-2026)
		* [3. 宏 2033](#3-宏-2033)
		* [4. 代码规范 2040](#4-代码规范-2040)
* [十六. C/C++ 需要考虑内存模型 2047](#十六-cc-需要考虑内存模型-2047)
	* [1. 字面值的内存位置 2048](#1-字面值的内存位置-2048)
	* [c语言多态需要两个元素 2065](#c语言多态需要两个元素-2065)
	* [c语言实现 2069](#c语言实现-2069)
	* [原理 2096](#原理-2096)
	* [static:  2129](#static--2129)
	* [extern 2174](#extern-2174)
	* [note 2295](#note-2295)

<!-- vim-markdown-toc -->
## 一. 概念 166
> 快速掌握一个语言的50%

### 1. 声明 169
1. 声明语法
    1. [声明] 声明说明符 声明符;
    2. 声明说明符
        1. 存储类型： auto、static、extern、register
        2. 类型限定符：const、volatile、C99：restrict
        3. 类型说明符：int、long、void ...
        4. C99有第四种声明说明符：函数说明符，它只用于函数： inline。

2. 存储类型
    1. 变量的性质

        1. 存储期限: 变量的存储期限决定了为变量预留和内存被释放的时间。
            1. 自动存储期限：在所属的块被执行时获得内存单元，并在块终止时释放内存单元，从而导致变量失去值。
            2. 静态存储期限：在程序运行期间占有同一个存储单元，也就是允许变量无限期的保留它的值。

        2. 作用域
            1. 块作用域：
            2. 文件作用域：

        3. 链接：变量的链接确定了程序的不同部分可以共享此变量的范围。
            1. 外部链接：可以被程序中的几个(或全部)文件共享
            2. 内部链接：只能属于单独一个文件，但是文件中的函数可以共享这个变量
            3. 无链接：单独一个函数的变量，不能被共享

        4. 变量的默认情况依赖于变量声明的位置
            1. 再块(包含函数体)内部声明的变量具有自动存储期限、块作用域、无链接。
            2. 在程序的最外层(任意块外部)声明的变量具有静态存储期限、文件作用域、外部链接。

    2. auto：只对块内变量有效。它是默认的。
        1. 自动存储期限、块作用域、无链接。

    3. static
        1. 块外部声明：
            1. 说明变量具有外部内部链接。
            2. 本质上是使变量只在声明它的文件内可见。

        2. 块内部声明：
            1. 变量的存储期限从自动变成了静态的。

            2. 性质
                1. 块内的static变量只在程序执行前进行一次初始化，而auto变量会每次出现时进行初始化。
                    1. <font color=green>可能是编译器会确定程序中代码段、数据段等的内存分配，这时static变量就在全局变量段，程序装入内存时初始化一次，以后就会跳过static的初始化</font>

                2. 每次函数被递归调用时，它都会获得一组新的auto变量，但是如果是static变量，每次调用都可以共享这个static变量。
                3. 函数不应该返回指向auto变量的指针，但是函数返回指向static变量的指针没有错误

    4. extern：extern存储类型使几个源文件可以共享同一个变量。
        1. extern 是声明
            1. extern int i;
            2. 这样编译器不会为变量i分配存储单元，上述是声明不是定义。

        2. 变量extern是声明不是定义有一个例外：对变量进行初始化的extern声明是变量的定义。
            1. extern int i = 0； 等效于  int i = 0；
           
        3. extern声明的变量始终具有静态存储期限，作用域依赖于声明的位置。

        4. 如果变量在任何函数之外声明为static，那么它具有内部链接，否则，变量具有外部链接。

    5. register：要求编译器把变量保存在寄存器中。
        1. register是一种请求而不是命令，编译器可以选择把变量保存在内存中
        2. register只对声明在块内的变量有效。
        3. register变量具有和auto变量一样的内存期限、作用域、链接。
        4. register变量缺乏一种auto变量所具有的性质：寄存器没有地址，所以对register变量使用取地址运算符&是非法的。
        5. 最好用在需要频繁进行访问或更新的变量。

    6. 函数的存储类型
        1. 只能使用extern 和static
        2. 使用extern和auto一样，都是默认行为，可以不显示声明
        3. static 将链接变为内部链接。static不能阻止函数指针的调用。

3. 类型限定符
    1. const ：说明变量是只读的，程序可以访问const型的对象，但是无法改变它的值。
        1. const对象不可以用于常量表达式，例如数组边界必须是常量表达式，所以不能写成 

                const int n = 10；
                int a[n];  Wrong;

                在C99中如果a具有自动存储期限，那么这个例子是合法的，它会被视为变长数组
                但如果a具有静态存储期限，那么这个例子是不合法的。
    2. volatile
    3. restrict：只用于指针。

4. 声明符: 声明符包含标识符(声明的变量或函数的名字)，标识符前可能有符号*，后边可能有[]或().
    1. 例子
        1.  * 是指针：int *p;  // * 指示指针
        2. [] 是数组： 
            1. int a[10]; //如果数组是形式参数、数组有初始化、数组的存储类型是extern，那么方括号里面可以为空。
            2. extern int a[] // 因为a是在其他地方定义的。**多维数组只有第一维可以为空**
            3. int a[]C99数组有两种额外选项：
                1. static，后面跟着的表达式指明数组的最小长度
                2. 符号 * ，只是变长数组。

        3. () 是函数： int a(int) // ()指示是函数
        
    3. 解释复杂声明
        1. 规则
            1. 始终从内往外读声明符。定位声明的标识符，并且从此处开始解释。
            2. 在做选择时，始终使[] 和()优先于 *。
                1. 如果*在标识符前，标识符后跟着[]，那么标识符表示数组而不是指针
                2. 如果*在标识符前，而标识符后跟着()，囊额标识符时函数而不是指针。
                3. 圆括号可以使以上两条规则无效。
                
        2. 小陷阱
            1. void （*pf）（int）;
                1. *pf包含在圆括号里，所以pf一定是指针。
                2. pf后跟着（int），所以pf必须指向函数

            2. int *（*x[10]）(void);
                1. *x[10]: 是数组，又是指针类型的数组
                2. (void)是函数
                3. int * :返回值是int *
                4. 所以是一个以int为参数，以int * 为返回值，的函数指针数组。
        
    4. C语言不能声明的内容
        1. 函数不能返回数组：
            1. int f(int) [];  //WRONG

        2. 函数不能返回函数
            1. int g(int)(int);

        3. 函数型的数组也是不可能：
            1. int a[10](int);

        4. 以上三种都可以用指针来实现：
            1. 返回指向数组的指针
            2. 返回指向函数的指针
            3. 函数型数组不可发，但是数组可以包含指向函数的指针。

    5. 使用类型定义来简化声明
        1. int *（*x[10]）(void);

        2. 类型定义简化

                typedef int *Fcn(void)   //typedef 声明函数时，类型的别名就是函数名本身，后边不用再加上那个名字了。
                typedef Fcn *Fcn_ptr;
                typedef Fcn_ptr Fcn_ptr_array[10];
                Fcn_ptr_array x;

                简化时，从外向里进行。

    6. 初始化式
        1. 如果类型不匹配，类型转换
        2. 指针变量的初始化式必须是具有和变量形同类型或者void *类型的指针表达式。
        3. 数组、结构、联合的初始化式通常应是一串括在花括号里的值。
        4. 额外规则
            1. 具有静态存储期限的变量的初始化式必须是常量
                
                    #define FIRST 1
                    #define LAST 100
                    
                    static int i = LAST - FIRST + 1;
                    因为宏替换，所以上式合法，但如果LASt和FIRST是变量，那么初始化式就是非法的。
                    大概是 因为变量是在程序运行时确定的，但是静态存储期限的值是数据段的值，在编译器会编译好确定的值。

            2. 如果变量具有自动存储期限，那么它的初始化时不需要是常量，大概是因为存储在栈空间里吧。

            3. 包含在花括号中的数组、结构、联合的初始化式必须只包含常量表达式，不允许有变量或者函数调用。
                1. C99中，当且仅当变量具有静态存储期限时，这一限制才生效。

            4. 自动类型的结构、联合的初始化式可以是另外一个结构或联合：

                    void g(struct part part1){
                        struct part part2 = part2;
                        ...
                    }

        5. 未初始化的变量
            1. 变量的初始化值依赖于变量的存储期限。
                1. 具有自动存储期限的变量没有默认的初始值，不能预测自动变量的初始值，而且每次变量变为有效值时可能不同。   初始化应该是编译器做的，栈中临时申请是在运行时申请的，所以编译器不知道类型。
                2. 具有静态存储期限的变量默认为零。

5. 内联函数
    1. 内联定义
        
            inline double average(double a, double b){
                return (a + b) / 2;
            }
    2. 内联函数是内联定义的，所以由外部链接的函数，会出错，两种方法避免
        1. 加static，这样函数就是确定是内联的的，其他文件不能调用

                static inline double average(double a, double b){
                    return (a + b)  / 2;
                }
        2. 为函数提供外部链接
            1. 将该函数重新写一遍，并放在另一个源文件，但有两个版本的函数了
            2. 将内联函数放到头文件，外部调用包含这个头文件就好。

        3. 最好是用static inline。

6. 问答：
    1. 自动存储期限的变量在所在的块开始执行时才分配空间，但变长数组不是变长数组是在块开始执行是分配的，而是在块执行到达变长数组时才会为其分配空间。

## 二. 输入输出和基础 362
### printf和scanf 363
1. 打印浮点数时:%f,默认显示小数点后6位，如果强制%f显示小数点后p位数字，可以把.p放置在%和f之间。：%.2f 388
2. %m.pX格式：m和p都是可选的。如果省略p，m和p之间的小数点也要去掉。 389
	1.  m是最小字段宽度，如果要显示的数值所需的字符小于m，那么值在字段内是右对齐的，就是在值前面放置额外的空格
	2.  如果大于m，则会自动扩展所需尺寸。
	3. %-m.pX中，值是左对齐的，空格加在后面。
	4. 精度
		1. 如果X是d，p指明最小显示的数字个数，如果p省略，默认p为1
		2. 如果X是e，p指明小数点后应该出现的数字的个数，默认为6，如果p为0，不显示小数点。
		3. 如果X是f，“定点十进制”形式浮点数，没有之术。与e一样
		4. 如果X是g，“定点十进制”或者指数形式，p表示可以显示的有效数字，不显示尾随的0.

#### 3. scanf 375
1. scanf第二个参数是一个指针，一定要注意。
2. scanf会忽略所有空白字符。
3. scanf 输入字符串时不会忽略空白字符。？？？

#### 4. 易混淆 380
1. printf的参数没有指针
2. scanf中的格式串不能包含逗号，scanf(%d, %d, &i, &j)。如果输入第一个整数后没有跟着一个逗号，scanf会出现异常。

#### 5. 读写字符串 384
1. printf函数会逐个写字符串中的字符，知道遇到空字符才停止(如果空字符丢失，printf函数会越过字符串的末尾继续写，直到最终在内存的某个地方找到空字符为止。)

        char str[] = "abcd";
        printf("%s\n", str);

2. 如果指向显示字符串的一部分，可以使用转换说明符 %.ps,这里p是要显示的字符数量。

        printf("%.6s\n", str);

3. 字符串的打印也适用于: %m.px 模式

4. puts(str):puts只有一个参数，即需要显示的字符串，会自动加一个换行符

5. 转换说明%s允许scanf函数把字符串读入字符数组：
        
        scanf("%s", str);

    1. str不需要加&运算符，因为str是数组名，编译器把它传递给函数时会把它当做指针来处理。
    2. scanf函数会跳过空白字符，然后读入字符并存储到str中，知道遇到空白字符为止，scanf始终会在字符串末尾存储一个空字符
    3. 用scanf函数读入字符串永远不会包含空白字符，因此，scanf函数通常不会读入一整行输入。
    4. <font color=green>换行符会使scanf停止读入，空格符或制表符也会产生同样的结果</font>

6. 为了一次读入一整行输入，可以使用gets函数，gets把读入的字符放到数组中，然后添加空字符。
7. gets和scanf的区别：
    1. gets函数不会在开始读入字符串之前跳过空白字符(scanf函数会跳过)
    2. gets函数会持续读入直到找到换行符才停止(scanf函数会在任意空白字符出停止).此外，gets函数会忽略掉换行符，不会存储到字符数组，并用空字符代替。

8. 输入越界
    1. <font color=red>再把字符读入数组时，scanf和gets都无法检测数组何时被填满，scanf可以通过%ns替换%s来制定可以存储的最多的字符数。但gets天生不安全，fgets函数则是一种好选择</font>
9. 逐个字符读字符串。
    
        int read_line(char str[], int n){
            int ch, i = 0;
            while (i < n)
                if ((ch = getchar()) != '\n')
                  str[i++] = ch;
           str[i] = '\0';
           return i;
        }

#### 6. 流 425
1. 文件指针
2. 标准流和从定向
3. 文本文件和二进制文件
    1. 文本文件具有的两种二进制没有的特性
        1. 文本文件分为若干行。文本文件的每一行通常以一两个特殊字符结尾。
        2. 文本文件可以包含一个特殊的"文件末尾"标记。

    2. 读写文本程序时，遇到"文件末尾"就会停止，所以如果一个文件是二进制文件并且包含"文件末尾",就可能出现没有完全读取文件，在无法确定文件是文本形式还是二进制形式时，安全的做法是把文件假定为二进制文件。

#### 7. 文件操作 435
1. 打开文件
    
        FILE *fopen(const char * restrict filename, const char * restrict mode)；
        restrict 表示所指向的字符串的内存单元不共享。

2. 当无法打开文件时，fopen函数会返回空指针。永远不要假设可以打开文件，每次都要测试fopen函数的返回值以确保不是空指针。

3. 模式
    1. 模式类型：

            "r"
            "w"
            "a"
            "r+"
            "w+"
            "a+"
    2. 使用fopen打开二进制文件时，需要在模式字符串中包含字幕b。
        1. 打开文件用于读和写(模式字符串包含字符+)时，有一些特殊规则
            1. 如果没有先调用文件定位函数，那么就不能从读模式转换为写模式。除非读操作遇到了文件末尾
            2. 类似的，如果既没有调用fflush函数，也没有调用文件定位函数，那么就不能从写模式转换成读模式。

            3. 如果文件可以读写，那么读的时候正在读的内容肯定不能直接往后写，要先定位一下，从那里开始写，或者到了末尾了，后续可以直接往后面接着写。
            4. 这在写的时候，文件定位正在写的内容，这时候不知道从那里读。这时文件内定位的问题。

4. 关闭文件：
        
        int fclose(FILE *stream);

        关闭成功，函数返回零，否则，它将会返回错误代码EOF(在<stdio.h>中定义的宏)

5. 为打开的文件流附加文件：
    
        FILE *freopen( const char * restrict filename, const char * restrict mode, FILE * restrict stream);

    1. 最常用的方式是把文件和一个标准流(stdin, stdout, stderr)相关联。

            if (freopen("foo", "w", stdout) == NULL){
                /* error; foo can't be opened */
            }

    2. 先关闭流之前关联的所有文件，然后freopen函数打开文件foo，并将其与stdout 相关联。
        1. freopen函数的返回值是第三个参数(一个文件指针)
        2. 如果无法打开新文件，freopen返回空指针。

6. 临时文件：只在程序运行时存在的文件。
    1. 原型
        1. FILE *tmpfile(void);
            1. 创建一个临时文件(用“wb+”模式打开)，该临时文件将一直存在，除非关闭它或程序终止。
            2. mpfile函数的调用会返回文件指针
            3. 例子

                    FILE *tempptr；
                    ...
                    tempptr = tmpfile();
            4. 缺点
                1. 无法知道tmpfile函数创建的文件名是什么
                2. 无法在以后决定成为永久性的文件。

        2. char *tmpnam(char *s); 为临时文件产生名字。
            1. 如果它的实际参数是空指针，那么tmpnam函数会把文件名存储到一个静态变量中，并且返回指向此变量的指针：
                    char *filename；
                    ...
                    filename = tmpnam(NULL)

            2. 否则，tmpnam函数会把文件名复制到程序员提供的字符数组中

                    char filename[L_tmpnam];
                    ...
                    tmpnam(filename);

7. 文件缓冲
    1. 函数原型
        
            int fflush(FILE *stream);
            void setbuf(FILE * restrict stream, char * restrict buf);
            int setvbuf(FILE * restrict stream, char * restrict buf, int mode, size_t size);
            
    1. 当向文件写输出时，数据通常是先放入缓冲区中，当缓冲区满了或者关闭文件时，缓冲区会自动清洗。然而，通过调用 fflush函数，程序可以按照我们所希望的频率来清洗文件的缓冲区。

            fflush(fp);  //为和fp相关联的文件清洗了缓冲区

            fflush(NULL); // 清洗了全部输出流。

            如果调用成功，fflush会返回零；如果发生错误，则返回EOF。

    2. setvbuf 允许改变缓冲流的方式，并且允许控制缓冲区的大小和位置。函数的第三个实际参数指明了期望的缓冲区。该参数是一下三个宏之一。在<stdio.h>中定义。
        1. _IOFBF（满缓冲）。当缓冲区为空时，从流读入数据；当缓冲区满时，向流写入数据。
        2. _IOLBF（行缓冲）。每次从流读入一行数据或者向流写入一行数据。
        3. _IONBF（无缓冲）。直接从流读入数据或直接向流写入数据，而没有缓冲区。


### 2. 基本数据结构 527
1. 整数：int，unsigned int，long，long long，char 552

2. float， double 553

### 3. 基本语法 532
#### 1. 表达式 533
> 表达式是表示如何计算值的公式。

1. <font color=red>运算符</font>
    1. 算术运算符
        1. 加减乘除、求余、正负。
        2. /：当两个操作数都是整数时，运算符/会丢掉分数部分来“截取”结果。
        3. %：两个操作数都必须是整数，如果有一个不是整数，无法通过编译。
        3. / 和% 的分母不能为0.
        4. **当/和% 用于负数操作数时，C99规定，除法的结果总是向零截取的。**
    2. 关系运算符
    3. 逻辑运算符
    4. 逗号云算法
        1. 语法： 表达式1， 表达式2
        2. 解释：
            1. 逗号表达式的计算要通过两步来实现：
               1. 计算表达式1并且扔掉计算出的值。
               2. 计算表达式2，把这个值作为整个表达式的值。
               3. 对表达式1的计算应该始终会有副作用，如果没有，那么表达式1就没有了存在的意义。

2. 运算符的优先级和结核性
    1. 最高：正负
    2. 最低： + - 
    3. <font color=green>二元算术符是左结合的</font>
    4. <font color=green>一元算术符是右结合的，复制操作符=也是右结合的。</font>
    5. <font color=red>赋值运算符=在C中是运算符，换句话说，复制操作符产生结果，就像如果两个数相加产生结果一样。赋值表达式v=e的值就是赋值运算后v的值。这个表达式是产生一个结果的，所以可以连等就是这个原因。</font>
    6. 关系运算符低于算术运算符，关系运算符是左结合的。
    7. 判等运算符，==。左结合，优先级低于关系运算符。
    8. 逻辑运算符：!, &&, ||.
        1. 结果为0或者1
        2. 将任何非零操作数作为真值来处理，同时将任何零值操作数当做假来处理。
        3. && 和|| 都对操作数进行“短路”计算。短路操作的副作用是不计算右边的表达式时，如果右边的表达式改变了变量的值，就没有计算这个表达式
        4. ! 的优先级和一元正负号一样。&& 和||优先级低于 关系运算符好判等运算符。

3. 左值
    > 左值表示存储在计算机内存中的对象，而不是常量或计算的结果，变量时已知的唯一左值。

    1. 赋值运算符要求左操作数必须是左值。 

4. 自增自减
    1. i++：先用i的原始值，稍后再自增i。稍后是指在校一条指令执行之前。  
    2. ++i：立即自增i。
    3. <font color=red>后缀++和后缀--比一元的正号和负号优先级高而且都是左结合的</font>
    4. <font color=red>前缀++和前缀--和一元的正号和负号优先级相同而且都是右结合的</font>
    
#### 2. 语句 578
1. 选择语句
    1. if
        1. 级联式if。 if …… else if …… else
        2. 避免悬空式else。最好加上大括号。
        3. 条件表达式： 表达式1 ? 表达式2 : 表达式3
            1. 条件运算符的优先级低于前面介绍过的所有运算符。

        4. 布尔值：C99 定义了一个_Bool类型，其实是int但只能赋值0和1.
            1. 一般来说，往_Bool变量中存储非零值会导致变量赋值为1；
                
                    flag = 5; /*flag is assigned 1*/
            2. 除了_Bool这个类型外，C99还提供了一个新的头文件<stdbool.h>,这使得操作布尔值更加容易。该头文件提供了bool宏，用来代表_Bool.

                    #include<stdbool.h>
                    flag = false
                    flag = true

    2. switch
        1. 语法：
        
                switch (表达式) {
                    case 常量表达式: 语句；
                            语句；
                            语句；
                            break；
                    case 常量表达式: 语句；
                            语句：语句；
                            语句；
                            break；
                            ……
                    default：语句；
                             语句；
                             break；
                }

    2. switch 表达式必须是整形表达式，C语言吧字符也当成字符，所以字符也可以。浮点数和字符串不可以。
    3. 常量表达式不能包含变量和函数调用，也必须是整数。

#### 2. 重复语句 617
1. while

        while （表达式） 语句

2. do

        do 语句 while (表达式);  注意这里有分隔号。

3. for
    1. 语法
            for （表达式1；表达式2；表达式3） 语句

    2. for 条件表达式可以省略其他语句。但分号要保留。

    3. for语句声明的变量不可以在循环外访问。在循环外不可见。

#### 3. 跳转语句 634
1. break
2. continue
3. goto
    1. 语法：
        
            标识符 : 语句
            goto 标识符；

    2. 一般不用，在多层循环嵌套时，因为break跳不出最外层循环，可以使用。

#### 4. 复合语句 645
> 几条语句组合成一条语句

#### 5. 空间语句 648
> 不执行任何语句

1. 和python 的pass类似。 仅仅只有一个 分号： ；。
2. 空语句要单独一行写，否则阅读时会混淆。

#### 3. 函数 654
1. 调用函数时，是将实参的值复制给形参的。所以函数如果想改变函数体外的变量需要使用引用或者指针。 678
2. 函数定义 679
	1. 函数的返回类型
		1. 函数不能返回数组，但关于返回类型没有其他限制。
		2. 如果省略返回类型，C89会假定为int，但C99是不合法的。

#### 3. 函数声明 661
> 在调用一个函数前，需要先声明函数或者定义函数。

1. 语法：   [函数声明]  返回类型  函数名 (形式参数)
2. 函数声明和函数定义一定要一致。

#### 5. 实际参数 667
1. 数组型实际参数
    1. 当形式参数是一维数组时，可以不说明数组的长度

            int f(int a[])
            {
                ……
            }
    2. <font color=red>C语言没有为函数提供任何简便的方法来确定传递给它的数组的长度；如果函数需要，我们必须把长度作为额外的参数提供出来</font>                    

            int sum_array(int a[], int n)
            {
                int i, sum = 0;
                for (i = 0; i < n; i++)
                    sum += a[i];
                return sum;
            }

    3. 在调用函数时，把数组名传递给函数时，不要在数组名的后边放置方括号，形参需要加。
    4. 在调用函数时，数组型实际参数的元素可以修改。值传递不包括数组名是因为数组名实际是一个指针。
    5. 如果形式参数是多维数组，生命参数时只能省略第一维的长度。

            #define LEN 10
            int sum_two_dimensional_array(int a[][LEN], int n)
            {
            }

    6. 变长数组形式参数
        > C99 增加的变长数组允许我们使用非常量表达式指定数组的长度，变长数组也可以作为参数。

        1. eg

                int sum_array(int n, int a[n])
                {
                }

        2. 注意:确定数组长度的变量一定要出现在数组前面，因为运行时当执行到为数组分配空间时，数组长度需要确定，所以n的值当时应该已经知道。而且，如果n在后面会引起使用未定义的变量。
        3. 函数声明(函数原型)有好几种写法：
            1. int sum_array(int n, int a[n]);
            2. int sum_array(int n, int a[*]); //星号的使用告诉编译器--数组的长度与形式参数列表中前面的参数相关。
            3. int sum_array(int, int [*]);
            4. int sum_array(int n, int a[])
            5. int sum_array(int, int []);

        4. 变长数组形式参数的长度可以是任意表达式
            1. int sum_two_dimensional_array(int n, int m, int a[n][m]);

    7. <font color=red>在数组参数声明中使用static</font>
        1. C99允许在数组参数声明中使用关键字static。
        2. 例子：将static放在数字3之前表明数组a的长度至少可以保证是3：
            
                int sum_array(int a[static 3], int n)
                {
                }
        3. static 不会对程序的行为有任何影响，static的存在只不过是一个“提示”，C编译器可以据此生成更快的指令来访问数组。
        4.例如如果编译器知道数组总是具有某个最小值，那可他可以在函数调用时预先从内存中取出这些元素值，而不是在遇到函数内部实际需要用到这些元素的语句时采取出相应的值。
        5. <font color=red>如果数组名参数是多维的，static仅可用于第一维。</font>

    8. 复合字面量
        > 复合字面量是通过制定其包含的元素而创建的没有名字的数组。

        1. total = sum_array((int[]){3, 0, 4, 5, 2}, 5);
        2. 函数内部创建的复合字面量可以包含任意的表达式，不限于常量
            
                total = sum_array((int []){2*i, i+j, j*k}, 3);
        3. 复合字面量可以使用初始化式、可以不提供完全的初始化(未初始化的元素默认为0)
        4. 复合字面量是左值 ，所以元素是可以改变的，如果要求是“只读”的，可以在类型前加上const，如(const int []){4, 5}.

#### 4. 程序终止 735
1. main 函数的返回类型是int 760
2. main函数返回的值是状态码，在某些操作系统中程序终止时可以检测到状态码。 761
3. exit函数，<stdlib.h>头文件。 传递给exit的参数和main函数返回值具有相同含义。 762
4. main函数中的语句 return表达式；等价于 exit(表达式) 763
5. return和exit的差异：不管那个函数调用exit函数都会导致程序终止，return语句仅当有main函数调用时才会导致程序终止。 764
6. reurn后可以跟表达式，return会先计算表达式再返回。return后可以跟三元操作符。 765

#### 5. 问答 743
1. 编译器把不跟圆括号的函数名看做是指向函数的指针。 768
2. 为什么要提供函数原型，只要把所有函数的定义放置在main函数之前，不就没有问题了吗？ 769
	1. 答：错。
		1. 某些函数相互调用，这时无论先定义那一个都会导致问题
		2. 需要仔细斟酌函数定义的顺序以满足调用顺序
		3. 程序达到一定规模，在一个文件中放置所有函数是不可行的。

3. 为什么可以留着数组中第一维的参数不进行说明，但是其他维数必须说明呢？ 775
	1. 答：
		1. 传递的数组名其实是把指向数组的第一个元素的指针传递给了函数，而编译器计算a[i] 的地址时，
		方法是用i乘以每个元素的大小并加到a表示的地址上。

		2. 多维数组的计算方式是：a[i][i]的地址是：i乘以数组a的每行的大小加上i乘以a每
		一个元素的大小并加到a表示的地址上，所以必须需要数组每一行的大小。

		3. 所以底线是程序员必须声明数组a拥有的列的数量。

4. 如果函数f1调用函数f2，而函数f2又调用了f1，这样合法吗？ 781
	1. 答：合法，这是一种间接递归的形式。

### 3. 主要语言构造 764
#### 1. 指令	 765
> 我们把预处理器执行的命令成为指令

1. 所有指令都以#字符开始，指令默认只占一行，每条指令的结尾没有分号或其他特殊标记。 788

2. 函数 790
> 函数类似于其他语言的“过程”或“子例程”，它们是用来构建程序的构建块。

#### 3. 语句 773
>语句是程序运行时执行的命令

1. <font color=red>C语言规定每条语句都要以分号结尾,但是有一个例外：复合语句就不以分号结尾。</font> 796
2. <font color=green>指令因为多是一行，所以不用分号结尾，而语句可能跨越多行，需要表示分隔</font> 797

#### 4. 注释 779
#### 1. //单行 780
#### 2. ```/*  */```可以有多种方式。 781

#### 5. 变量和赋值 783
#### 1. 类型： 784
> 类型用来说明变量所存储的数据种类

1. <font color=red>每一个变量都必须有一个类型</font>
2. <font color=green> 类型告诉编译器此变量需要占据多大的内存空间，类型确定了，C语言变量的存储空间大小就确定了。</font>
3. <font color=green>类型会影响变量的存储方式以及允许对变量进行的操作</font>

#### 2. 声明 791
1. <font color=green>C语言使用变量之前必须对其进行声明</font>
2. main函数包含声明时，必须把声明放置在语句之前，函数和程序块也一样。
3. C++和Java程序中在使用时才声明变量。
4. 作用
    1. 告诉编译器，这个名字已经匹配到一块内存空间。
    2. 告诉编译器，这个名字已经预定了，其他地方不能在使用它声明变量或对象名。
5. 声明可以多次，定义只能一次，变量的生命和定义是一样的，一般用在函数声明和定义上。
6. 除了动态内存，变量在声明时就分配了内存空间。

#### 3. 赋值 801
> 变量通过赋值的方式获得值

#### 4. 初始化 804
> <font color=green>当程序执行时，某些变量会被自动初设置为0，而大多数变量则不会，没有默认值并且尚未在程序中被赋值的变量时未初始化的。</font>

1. <font color=red>方位未初始化的便令，可能会得到不可知的结果</font>
2. 解决方法
    1. 在变量声明中加入初始值。
        1. int height = 8； 8 是一个初始化式
        2. 在同一个声明中可以对任意数量的变量进行初始化。
            int height = 8，length = 12， width = 10；
        3. 2中的每个变量都有值，而接下来只有width有值：
            1. 只有width初始化：int height，length， width = 10；
    2. 用赋值的方法给变量赋初始值。

#### 5. 读入输入 817
1. scanf：
    1. printf和scanf的f含义相同都是“格式化”的意思。
    2. printf和scanf都需要使用**格式串**来制定输入或输出的形式
    3. 之所以这样是因为输入和输入都需要知道数据的类型。

#### 6. 定义常量的名字 823
> 当程序含有常量时，建议给这些常量命名。

1. 可以使用宏定义来给常量命名：
    ```#define INCHES_PER_POUND 16```

#### 7. 标识符 829
1. 一般标识符遵循只是用小写的规范，必要还可以插入下划线或驼峰命名

#### 6. C89关键字  832
1. 有关数据“模子”的关键字：void、char、short、int、long、float、double、sizeof； 
2. 有关数据符号的关键字：signed、unsigned； 
3. 构造类型：struct、union、enum、typedef；
4. 有关存储与生命周期的类型：auto、static、extern、register、const、volatile；

5. register
    1. 说明： 这个关键字请求编译器尽可能的将变量存放在CPU内部的寄存器中，而不是通过内存寻址访问以提高效率（是尽可能，不是绝对）。
    2. 解释：寄存器其实就是一块一块小的存储空间，只不过其存储速度比内存快得多，但是价格昂贵。
    3. 注意：
        1. register变量必须是一个单个的值，并且其长度必须小于或等于整形的长度。
        2. register变量可能不存在内存中，所以不能用取地址运算符“&”来获取register变量的地址。

6. static；详见mybase。
    1. 说明：声明静态变量。
    2. 作用：
        1. 修饰变量：static可以修饰局部变量和全局变量，它们都存放在内部的静态区中。
            1. 静态全局变量：作用域仅限于变量被定义的文件中，其他文件即使使用extern声明也不能使用它。准确的说：作用域是从定义之处开始到文件结束。在定义之处前面的那些代码行也不能使用它，想要使用就得在前面再加extern***。
            2. 静态局部变量：作用域仅限于该函数里，该文件中的其他函数也用不了。虽然局部变量的生命周期随着函数的结束而终止，但是因为被static修饰的变量总是存在内存的静态区，所以即使这个函数运行结束，这个静态变量的值也不会被销毁，函数下次使用时仍然能用到这个值。
    3. 注意，static的生命只执行一次，下次就从内存中找变量的值。

7. 符号关键字： unsigned和signed
    1. 说明：最高位如果是1，表明这个数是负数，其值为除最高位以外的剩余位的值加上“-”号；最高位如果是0，表明这个数是正数，其值为除最高位以外的剩余位的值。

8. const
    1. 说明：const是constant的缩写，表示恒古不变。被const修饰的变量称为常变量，准确来说应该是只读的变量
    2. 作用：
        1. 修饰只读变量：定义const只读变量，具有不可变性。
            1. const int Max = 100；
            2. 释：<font color=green>const修饰的只读变量必须在定义的同时初始化，因为定义后就不能再被改变了。</font>
            3. int Array[Max];
            4. 释：这样编译时会报错，<font color=green>数组下标只能是常量</font>，即使常变量也不可以，但是宏常数可以。
        2. 修饰数组
        3. 修饰指针
        4. case 后面的数字不可以用const 修饰，因为case后面只能是常量、字符型常量和常量表达式

9. volatile
    1. 说明：volatile是易变、不稳定的意思。
    2. 作用：用volatile修饰的变量可以被某些编译器未知的因素更改，即更新数据，未知的因素如操作系统、硬件或者其他线程等。
    3. 例子1：

            int i = 10;
            int j = i;//1）语句
            int k = i;//2）语句

        分析：编译时编译器认为i的值没有发生变化，所以在1）语句时从内存中取出i的值赋给j后并没有被丢掉，在2）语句时继续用这个值给k赋值，而不生成汇编代码重新从内存里取出i的值。

   4. 例子2：

            volatlie int i = 10;
            int j = i;
            int k = i;
        
        分析：例2与例1不同的是，volatile关键字告诉编译器，i的值随时可能发生变化，则每次用i，编译器都会生成汇编代码从内存中取i的值。

    5. 问题：const volatile int i = 10;这行代码有没有问题？如果没有，那么i到底是什么属性？
    6. 答：没有问题。因为const表示常量语义，被const修饰的对象在所在的作用域里无法进行修改；volatile表示易变的，即在运行期对象可能在当前程序上下文的控制流以外被修改。发生易变的情况，如：在多线程中。被其他线程修改；对象所在的存储器可能被多个硬件设备随机修改等情况。例如，只读的状态寄存器，它是volatile属性，因为它可能被意外的修改。但是，同时它也具有const属性，因为它修饰的内容只能被读而不能被写。可知：它们控制的范围不同，被const修饰的对象在程序本身内不能修改，而被volatile修饰的对象可能在本程序外被修改。所以，const和volatile一起使用没有问题。
                    
#### 5. 有关语句的类型： 890
if、else、for、while、do、switch、case、fault、goto、break、continue、return 

#### 7. C99关键字 893
#### 1. _Bool 894
> bool 类型变量，等价于unsigned char，只有0和1

1. 头文件：<stdbool.h>

#### 2. _Complex 899
> 对于C99 标准定义, 存在 float _Complex, double _Complex, long double _Complex 复数类型.
  
1. 头文件: <complex.h>
2. 其实在复数类型中，gcc标准实现

    ```#define complex _Complex```

#### 3. _Imaginary 907
> 虚数类型,_Complex复数类型的虚部。关键字系统保留，我们无法使用。

#### 4. inline 910
> 内联函数,从C++中引入的概念. 就是将小函数直接嵌入到代码中. C的代码损耗在于函数的进出栈. 要是可以推荐用内联函数替代宏. 宏能不用就不用. 函数声明的时候不要加inline 需要加extern, 定义的时候需要加inline

1. 例子

        extern cjson_t cjson_newtstr(tstr_t str);

        inline cjson_t 
        cjson_newtstr(tstr_t str) {
            str->len = _cjson_mini(str->str);
            return _cjson_parse(str->str);
        }

        // 还有就是和static 一起使用
        static inline int _sconf_acmp(tstr_t tstr, struct sconf * rnode) {
            return strcmp(tstr->str, rnode->key);
        }
        
#### 5. restrict 928

> 这是很装逼的关键字用于编译器优化. 关键字restrict只用于限定指针；该关键字用于告知编译器，
> 所有修改该指针所指向内容的操作全部都是基于(base on)该指针的，即不存在其它进行修改操作的途径；
> 这样的后果是帮助编译器进行更好的代码优化，生成更有效率的汇编代码。
    
1. 演示
    1. 摘自GCC 的 string.h中

            extern void *mempcpy (void *__restrict __dest,
                                  const void *__restrict __src, size_t __n)
                 __THROW __nonnull ((1, 2));
        
    2. 正式用法

            // 简单演示用法, GCC 和 VS 都是 __restrict 推荐加在 * 后面
            static void _strlove(char * __restrict dest) {
                *dest = '\0';
            }
            
#### 8. C11关键字 948
#### 1. _Alignas 949
1. 解释: 内存对齐的操作符，需要和_Alignof配合使用。
2. 演示：

        #ifndef __cplusplus

        #define alignas _Alignas
        #define alignof _Alignof

        #define __alignas_is_defined 1
        #define __alignof_is_defined 1

        #endif

        #include <stdio.h>
        #include <stdalign.h>

        struct per {
            int age;
            double secl;
            char sex;
        };

        int main(int argc, char * argv[]) {
            char c[100];
            alignas(struct per) struct per * per = (struct per *)&c;
            printf("per = %p, c = %p.\n", per, c); 

            return 0;
        }

#### 2. _Alignof 980
1. 解释： 得到类型和变量的对齐方式.
2. 演示：

    printf("alignof(struct per) = %zd.\n", alignof(struct per));
    
#### 3. _Atomic 986
1. 解释:
　　原子操作, 原子锁. gcc 很早就支持. 详细用法可以参照 CAS https://sanwen8.cn/p/18dZQie.html讲的可以
2. 演示：

        #include <stdio.h>
        #include <stdatomic.h>

        int main(int argc, char * argv[]) {
        
            _Atomic int hoge = ATOMIC_VAR_INIT(100);
            int piyo = atomic_load(&hoge);  
            printf("piyo = %d.\n", piyo);
            piyo += 2;
            atomic_store(&hoge, piyo);
            printf("hoge = %d.\n", hoge);

            return 0;
        }
    
#### 4. _Generic 1006
1. 解释：C的泛函机制，高级函数宏
2. 演示：
    
        #include <math.h>
        #include <stdio.h>
        #include <stdlib.h>

        #define ABS(x) _Generic((x), int:abs, float:fabsf, double:fabs)(x)

        //
        // 测试 C11 语法
        //
        int main(int argc, char * argv[]) {
            
                int a = 1, b = 2, c = 3;
            
                _Generic(a + 0.1f, int:b, float:c, default:a)++;
                printf("a = %d, b = %d, c = %d\n", a, b, c); 

                printf("int abs: %d\n", ABS(-12));
                printf("float abs: %f\n", ABS(-12.04f));
                printf("double abs: %f\n", ABS(-13.09876));

                return EXIT_SUCCESS;
        }
    
#### 5. _Noreturn 1033
1. 解释:
　　1. 修饰函数,绝对不会有返回值. _Noreturn 声明的函数不会返回. 引入此新的函数修饰符有两个目的:
        1. 消除编译器对没有 return的函数的警告. 
        2. 允许某种只针对不返回函数的优化.

2. 演示:

        _Noreturn void suicide(void) {
            abort(); // Actually, abort is _Noreturn as well
        }

3. 再扯一点, GCC中等同于 __attribute__((__noreturn__)), 在VC中相似功能是 __declspec(noreturn).
    1. 它不是说函数没有返回值，而是说一旦你调了这个函数，它永远不会返回。一些函数是永远不会返回的，
    2. 比如 abort或者 exit之类，调用它们就意味着结束程序. 所以 warning就显得没有必要.

#### 6. _Static_assert 1049
1. 解释:
    编译器期间断言, 当 #if #error 搞完毕(预编译)之后, 编译器断言. assert是运行时断言.用的时候看具体的需求.
2. 演示:

        _Static_assert(__STDC_VERSION__ >= 201112L, "C11 support required");
        // Guess I don't really need _Static_assert to tell me this :-(

#### 7. _Thread_local 1057
1. 解释：_Thread_local是新的存储类修饰符, 限定了变量不能在多线程之间共享。
2. 演示:

        _Thread_local static int i;
        // Thread local isn't local!
        语义上就是线程的私有变量.

#### 9. 程序结构 1065
#### 1. 局部变量 1066
> 把在函数体内声明的变量称为该函数的局部变量。

1. 性质
    1. 自动存储期限。
        > 变量的存储期限是在变量存储单元存在期内程序执行的部分。

        1. 局部变量的存储单元是在包含该变量的函数被调用时“自动”分配的，函数返回时收回分配。
    
    2. 块作用域
        > 变量的作用域是可以应用该变量的程序文本的部分，从声明变量到所在的函数体的末尾。

2. 静态局部变量
    > 在局部变量声明中放置单词static可以使变量具有静态存储期限而不再是自动存储期限。

#### 2. 外部变量 1081
1. 性质
    1. 静态存储期限
    2. 文件作用域

#### 3. 程序块  1086
1. 声明： [程序块]  {多条声明  多条语句};
2. 例如

        if (i > j) {
            int tmep = i;
            i = j;
            j = tmep;
        }
3. 默认情况下，声明在程序块中的变量的存储期限是自动的：进入程序块时，为变量分配存储单元，退出程序块时收回分配的空间。变量具有块作用域，也就是说，不能再程序块外引用。
4. 注意这是C语言里特有的程序块，大括号括起。python里没有这种结构。

#### 4. 作用域 1098

## 三.高级数据结构  1100
### 1. 数组 1101
> 数组是含有多个数据值的数据结构，并且每个数据结构具有相同的数据类型。

1. 其他变量基本变量都是**标量**，标量具有保存单一数据项的能力。
2. C语言一共有两种聚合类型：数组和结构

#### 1. 一维数组 1107
1. 声明：需要指明数组元素的类型和数量：```int a[10];```
2. 数组的元素可以是任意类型，数组的长度可以用任何(整数)常量表达式指定，因为程序以后改变时可能需要调整数组的长度，所以较好的方法是用宏来定义数组的长度：

        #define N 100
        。。。
        int a[N];
3. 数组初始化
    1. 数组初始化式：
        1. int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        2. 初始化式比数组短，数组剩余元素为0： int a[10] = {1, 3, 4}
        3. 利用2可以将数组初始化为一个值：int a[10] = {0}
        4. 初始化式完全为空是非法的。
        5. int a[] = {1, 2, 3, 4, 5}编译器会利用初始化式的长度来确定数组的大小。**数组仍然有固定数量的元素，这和明确指定长度效果一样**
    
    2. 指定初始化式
        1. 使用场景：数组中只有相对较少的元素需要进行显示的初始化，其他元素进行默认赋值。
        2. C99中的 指定初始化可以解决这一问题
            
                int a[15] = {[2] = 29, [9] = 7, [14] = 48};
                括号里的数字成为指示符
                指示符必须是整型常量表达式

        3. 指定初始化式还有一个优点：赋值的顺序不再是一个问题。

                int a[15] = {[14] = 29, [9] = 7, [1] = 48};
        4. 初始化式可以同时使用老方法和新方法

                int c[10] = {5, 1, 9, [4] = 3, 7, 2, [8] = 6};

4. 对数组使用sizeof
    1. 确定数组的大小： sizeof(a)
    2. 确定数组元素的大小： sizeof(a[0])
    3. 确定数组长度： sizeof(a) / siezeof(a[0])

#### 2. 多维数组 1142
> C语言中的多维数组扮演的角色相对较弱，这主要是因为C语言Wie存储数据提供了更加灵活的方法：指针数组。

1. 多维数组初始化
    1. 嵌套一维数组初始化式

            int m[5][9] = {{1, 1,1,……},{0,1, 2, 2,……},……}

            每个内部初始化提供了矩阵中的一行的值

        1. 没有填满整个数组的话，省略的部分初始化为0
        2. 可以省略内层的大括号，编译器一旦发现数组足以填满一行，它就开始填充下一行。
        3. C99指定初始化式也有用：

                double ident[2][2] = {[0][0] = 1.0, [1][1] = 1.0};
#### 3. 常量数组 1157
> 无论一维数组还是多维数组，都可以在声明最开始处加上单词const而成为"常量"

1. 程序不应该对声明为const的数组进行修改。编译器能够检测到直接修改某个元素的意图。

#### 4. 变长数组 1162
> 数组变量的长度必须用常量表达式进行定义，但是在C99中，有时候也可以使用非常量表达式。
> 声明变长数组的时候可以用变量表示数组里的存储区个数，如果程序多次运行则每次运行的时候变长数组里包含的存储区个数都可能不同。但是某次程序运行中变长数组里的存储区个数不变。

1. **变长数组不可以初始化，编译会出错，如果对变长数组赋值只能使用循环语句进行循环赋值**
2. eg

        #include <stdio.h>
        int main(){
            int num = 0;
            printf("请输入一个整数：");
                scanf("%d", &num);
                int arr[num];
                printf("sizeof(arr) = %d\n", sizeof(arr)); return 0;
            }

5. 问答
    1. 如果试图用赋值运算符把一个数组复制到另一个数组中，编译器将给出出错消息，哪里错了？
    2. 答：这个需要用到C语言里的数组和指针之间的特殊关系，后面会解答。
        1. 把一个数组复制到另一个数组最简单的实现方法是利用循环对数组元素逐个进行赋值。

                for (i = 0; i < N; i++)
                    a[i] = b[i]
        2. 另一种可行的方法是使用来自<string.h>头文件的memcpy(意思是：内存复制).
        
### 2. 结构、联合、枚举 1187
#### 1. 结构 1188
1. 结构是可能具有不同类型的值(成员)的集合
2. 声明：
    1. 声明格式和其他C语言变量声明格式类似： struct {...} part1, part2;  struct {...} 指明了类型。

            struct {
                int number;
                char name [NAME_LEN+1];
                int on_hand;
            } part1, part2;

3. 初始化，也可以在声明的同时进行初始化，像数组一样，大括号括起来。初始化式中的值必须按照结构成员的顺序进行显示。用于结构初始化式的表达式必须是常量。不能用变量来初始化结构体。这一限制在C99中放宽了。

        struct {
            int number;
            char name[NAME_LEN+1];
        } part1 = { 23, "Disk driver"},
          part2 = { 34, "Prinnter cable"};

    1. 初始化式中的成员可以少于它所初始化的结构，剩余补零或空字符。

4. 指定初始化
    1. 类似于数组的指定初始化式，但不是通过下标而是名字赋值。

            {.number = 345, .name = "Disk driver", .on_hand = 10}

    2. 将点号和成员名称的组成称为**指示符**， .的优先级类似++后缀，所以几乎高于所有的运算符
    3. 指定初始化式可以不按照结构中定义的顺序来初始化。
    4. 指定初始化式和初始化混用：

            {.number = 34, "Disk driver", .on_hand = 34}
    5. 值"Disk driver" 的前面没有指示符，所以编译器认为它是初始化结构中位于number之后的成员

5. 操作
    1. 结构体成员是左值
    2. 结构体中所有成员都可以使用 = 来进行赋值，数组本身不可以复制，但是结构体中的数组可以复制。
            
            part1 = part2;

    3. = 运算符仅仅用于类型兼容的结构。
    4. 除了赋值运算，C语言没有提供其他用于整个结构的操作
    5. <font color=red>不能使用 == 和 != 来判断两个结构是相等还是不等</font>

#### 2. 结构类型 1231
1. 由以上可知，声明一个struct时，需要 struct {...} 变量名，这样会导致程序膨胀，并且如果多个地方定义的话可能难以确保声明一致，还有就是多个struct {...} 变量名，它们不具有兼容类型。
2. 所以需要定义表示结构的**类型**(而不是特定的结构变量)的名字
    1. 结构标记的声明
        > 使用于标识某种特定结构的名字。

        1. 例子

                struct part {
                    int number;
                    char name[NAME_LEN+1];
                    int on_hand;
                };
    
        2. 注意：右花括号后的分号必不可少，它表示声明结束。 struct {...} 是一个类型;struct 标识符 {...} 是一个声明语句，声明一个struct part 的类型，所以需要加分号。

        3. 创建了标记part，就可以用它来声明变量：注意，类型是struct part，而不是part。
            
                struct part part1, part2;
                绝对不能漏写struct，part并不是类型名

    2. 结构类型的定义
        > 除了声明的结构标记，还可以使用typedef 来定义真实的类型名

        1. 例子
            
                typedef struct {
                    int number;
                    ...
                } Part;

                Part part1, part2;

        2. 这时一个typedef 语句，要加分号，并且Part必须出现在定义的末尾。这个类型就是Part，而不是上面的struct part。

    3. 用途
        > 通常既可以选择声明标识符也可以用typedef，但是结构用于链表时强制使用声明结构标记。

    4. 结构作为参数和返回值
        0. C函数调用，实参都是值传递，指针也是值传递，只不过复制的是指针中保存的地址，使得新的指针还是指向原来的变量。
        1. 结构作为参数和返回值，都是值传递，需要复制结构体，为了防止系统复制开销，可以使用指向结构的指针来避免复制。有些结构必须保持唯一，指针也是一个办法。
        2. 结构体可以相互赋值的。

                void f(struct part part1){
                    struct part part2 = part1;
                    ...
                }

    5. 复合字面量
        1. 数组那一节中，复合字面量别用于创建没有名字的数组，这样做的目的通常是将数组作为参数传递给函数。
        2. 复合字面量同样可以用于“实时”创建一个结构，而不需要先将其存储在变量中，生成的结构可以像参数一样传递，可以被函数返回，也可以赋值给变量
        3. 例子

                print_part((struct part) {234, "Disk driver", 10});
    6. 结构数组
        1. 结构数组的初始化：和多维数组的初始化方法非常相似，每个结构都拥有自己的花括号括起来的初始化式，数组的初始化式简单的在结构初始化式外围括上另外一对花括号。

                struct dialing_code {
                    char *country;
                    int code;
                };

                const struct dialing_code country_codes[] = 
                { {"Argentina", 34}, {"Bangladesh", 880} };

        2. C99的指定初始化式允许每一项具有多个指示符。

                struct part inven[100] = { [0].number = 234, [0].on_hand = 10, [0].name[0] = '\0' };

#### 3. 联合 1300
1. 概述
    1. 联合和结构类似，不同之处在于联合的成员共享同一存储空间，这样的结果是，联合可以每次存储一个成员，但无法同时存储全部成员
    2. 联合也是由一个或多个成员构成的，而这些成员可以具有不同的类型。
    3. 编译器只为联合中最大的成员分配足够的内存空间，联合的成员在这个空间内彼此覆盖。
    4. 这样的结果是给一个成员赋值，也会改变其他成员的值。

2. 因为编译器把联合的成员重叠存储，所以改变一个成员会使之前存储在任何其他成员中的值发生改变。其他成员会输入无意义的字符。

3. 联合的性质和结构几乎一样
    1. 区别是结构中的成员在内存中有各自的地址空间，而联合的成员存储在同一内存地址中。
    2. 可以用生命结构标记和类型的方法来声明联合的标记和类型
    3. 相结构一样，联合可以使用运算符 = 进行复制，也可以传递给函数，还可以有函数返回。
    4. 联合的初始化方式也和结构的初始化很类似，但是，只有联合的**第一个成员**可以获得初始值。

            union {
                int i;
                double d;
            } u = {0};

    5. 注意或括号是必须的,花括号里的表达式必须是常量。(C99中的规则稍有不同)
    6. 指定初始化式也可以用在联合中，指定初始化式允许我们指定需要对联合中的哪个成员进行初始化。

            union {
                int i;
                double d;
            } u = {.d = 10.0};
            
            只能初始化一个成员，但不一定是第一个。

4. 用途
    1. 用联合来节省空间 
    2. 用联合来构造混合的数据结构
        1. 假设需要数组的元素是int值和double值的混合，因为数组的元素必须是相同的类型，所以好像不可能，但是利用union就相对容易了
        2. 例子

                typedef union {
                    int i;
                    double d;
                } Number;

                Number number_array[100];

5. 为联合添加“标记字段”
    > 联合不知道改变的是哪个成员

    1. 把一个联合嵌入一个结构中，且此结构还含有另一个成员：“标记字段”或者“判别式”，它是用来提示当前存储在联合中的内容的。

            #define INT_KIND 0
            #define DOUBLE_KIND 1
            
            typedef struct {
                int kind;
                union {
                    int i;
                    double d;
                } u;
            } Number;

    2. 每次对联合的成员进行赋值，都由程序负责改变标记字段的内容。

#### 3. 枚举 1361
1. 枚举是一种整数类型，它的值由程序员来命名
2. 枚举类型是一种值有程序员你列出的类型，而且程序员必须为每个值命名(枚举常量)

        enum {CLUBS, DIAMONDS, HEARTS} s1, s2;

3. 枚举常量的名字必须不同于作用域内声明的其他标识符。
4. 枚举标记和类型名
    1. 创建枚举的名字
        1. 通过声明标记的方法
            
                enum suit {CLUS, DIAS, HDR};
                enum suit s1, s2;

        2. 使用typedef来创建独一无二的类型名

                typedef enum {SLDKF, SFSDF} Suit;
                Suit s1, s2;

    2. 枚举作为整数
        1. 在系统内部，C语言会把枚举变量和常量作为整数来处理，默认情况下，0,1,2,3，
        2. 可以自己选择不同的值

                enum suit {CLUS = 1， DIAM = 2， HEARTS = 3}；

        3. 枚举常量可以是任意整数

                enum dept {A= 20， B = 10， C = 23}；

        4. 两个或多个枚举常量具有相同的值也是合法的
        5. 没有为枚举常量指定值，它的值比前一个常量大1.
        6. 枚举值不过是一些稀疏分布的整数，所以C语言允许把它们与普通的整数进行混合

                int i;
                enum {CLUS, DIAMO, A} s;
                i = DIAMO;
                s = 0;  //s=CLUS
                s++;    //s=DIAMO

    3. <font color=green>枚举相当于声明了 1. 一个枚举变量 2. 多个枚举值(大括号里的标识符)，枚举值在整个作用域都可见，所以才不能与作用域中的变量同名。</font>

    4. 
## 四. 字符串处理：替换，查找、截断 1403
### 1. 字符基础 1404
#### 1. 字符字面量 1405
1. 字符串字面量是作为数组来存储的，所以编译器会把它看做是char *类型的指针。
2. <font color=red>注意，字符串字面量相当于是char * 类型的，所以通常情况下在C语言允许使用char *指针的地方使用字符串字面量</font>
    
        char *p;
        p = "abc"

   1. <font color=red>注意，这个赋值操作不是赋值“abc”中的字符，而是使p指向字符串的第一个字符</font> 

3. C语言允许对指针取下标，因此可以对字符串字面量取下标。

        char ch;
        ch = "abc"[1];

    1. 这个特性并不常用，但有时也有方便，eg如下，将0-15的数转换为等价的十六进制字符形式。

            char digit_to_hex_char(int digit){
                return "0123456789ABCDEF"[digit];
            }

4. 试图改变字符串字面量会导致未定义的行为

5. 字符串字面量和字符常量是不同的。
    1. 字符串字面量"a"是用指针来表示的，这个指针指向存放字符"a"(后面紧跟空字符)的内存单元。
    2. 字符常量'a'是用整数(字符集的数值码)来表示的

#### 2. 字符串变量 1431
1. 只要保证字符串是以空字符结尾的，任何一维的字符数组都可以用来存储字符串。字符串的所有库函数也都是默认字符数组以空字符结尾。
2. 如果声明的字符数组长度小于或等于字符串的长度，会使得字符数组末尾没有空字符，会导致不可知的错误。
3. 字符数组与字符指针
    1. 相似声明：
            char date[] = "abce 14";
            char *date = "abce 14";

    2. 不能错误的认为以上两种date可以互换，它们有很大差异：
        1. 在声明为数组时，就像任意数组元素一样，可以修改存储在date中的字符。而声明为指针时，date指向字符串字面值，字符串字面量是不可以修改的。
        2. 在声明为数组是，date是数组名，date本身是不可以修改的。在声明为指针时，date是变量，这个变量是可以在程序执行期间指向其他字符串的。
        3. 如果想要可以修改字符串，那么就要建立字符数组来存储字符串。生命指针变量就不够。
        4. 在使用指针p作为字符串之前，必须把p指向字符数组，使用未初始化的指针当做字符串会引起很严重的后果，不知道指针指向哪里。
            1. 把p指向已经存在的字符串变量

                    char str[STR_LEN + 1], *p;
                    p = str;

            2. 让p指向一个动态分配的字符串：

#### 3. 字符串的库函数 1451
1. <font color=red>C语言中把字符串当做数组来处理，因此对字符串的限制方式和对数组的一样，特别是，它们都不能用C语言的云算法进行复制和比较操作</font>
    1. 直接复制和比较字符串会失败：

            char str1[10], str2[10];
            str1 = "abc";  wrong
            str2 = str1;   wrong

    2. 把数组名用作=的左操作数时非法的，但是=初始化字符数组是合法的：
        
            char str[10] = "abc";  right

        1. 因为声明数组时，如果不初始化，编译器会自动填上合适的字符，例如int是0，char是空字符。所以声明时已经赋值了，在用等号就是赋值操作，不可以直接对数组复制赋值。

    3. 试图使用关系运算符或判等运算符来比较字符串是合法的，但是不会产生预期的结果：

            if (str1 == str2) ...   wrong

        1. 这条语句把str1 和str2作为指针来比较，而不是比较两个数组的内容，因为str1和str2有不同的地址，所以表达式str1 == str2 的值一定为0.

2. <string.h>
    1. <font color=red>注意，此头文件中的字符串类型声明为char *，所以字符指针、数组、字面量都可以，但是字面量不可改变，相当于const char *，所以字面量不能用作可变形参的实参</font>
    2. strcpy: char *strcpy(char *s1, const char *s2);
    3. strncpy： strncpy(str1, str2, sizeof(str1)); 会检查复制的个数，但如果str2的字符串长度大于str1数组长度，会导致str1没有终止的空字符。一下是安全用法
            
            strncpy(str1,  str2, sizeof(str1) - 1);
            str1[sizeof(str1)-1] = '\0';
    4. strlen: size_t strlen(const char *s);
    5. strcat: char *strcat(char *s1, const char *2);
    6. strncat: 与strncpy类似，需要计算一下空字符的位置。 
    7. strcmp: 比较函数：int strcmp(const char *s1, const char *s2);  <font color=green>指针和数组不可以利用运算符比较，可以利用这个函数来比较</font>

3. 惯用法
    1. 惯用法

            while (*s)
                s++;

            while (*s++)
                ;

            while (*p++ = *s++)
                ;

4. 字符串数组
    1. 二维数组，可以省略行数，这个可以从初始化式求出，但是C语言要求指明列数。

            char planets[][8] = {"Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn"}

        1. 这种二维数组中，每一行都有同样的长度，但是列的长度是所有字符串中最长的，这样没有填满二维数组导致浪费空间。

    2. 一维指针数组

            char *panets[] = {"Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn"};        


        
    


### 2. Regex 1511
### 3. Parser 1512
### <font color=green>4. 字符编码</font> 1513

## 五. 基本面向对象或函数式编程的特征 1515
### 1. 继承 1516
### 2. 多态 1517
### 3. Lambda 函数 1518

## 六. 调试：TDD技能 1520
### 1. 异常 1521
### 2. 错误处理 1522
### 3. 断言 1523
### 4. 日志 1524
### 5. 调试支持 1525
### <font color=green>6. 单元测试</font> 1526

## <font color=green>七. 运行时</font> 1528
### 1. 程序代码和可执行代码的组织机制 1529
### 2. 运行时模块加载 1530
### 3. 符号查找机制 1531

## 八. 流 1533
### 1. 基本输入输出 1534
### 2. 文件处理 1535
### 3. 输入输出流类的组织 1536

## 九. 事件驱动 1538
### 1. callback 方法调用 1539
### 2. 如何支持事件驱动编程模型 1540
1. .NET 的delegate，Java的anonymous inner class，Java 7的closure，
C++OX的tr1::function/bind……等各种语言都会在这里下足功夫。 

## 十. 序列化和反序列化 1543
### 1. 缺省机制 1544

## 十一. regex和XML处理问题，可以跳过 1546

## 十二. 并发 1548
### 1. 线程 1549
### 2. 进程 1550
### 3. 并发 1551
### 4. 异步调用 1552

## 十三. <font color=green>动态编程</font> 1554
### 1. 反射 1555
### 2. 元数据编程 1556
### 3. 数据和程序之间的相互转化机制 1557
### 4. 运行时编译和执行的机制 1558

## 十四. 语言常用的特色feature 1560
### 1. 指针 1561
#### 1. 指针变量 1562
1. 大多数现代计算机都讲内存分割为字节，每个字节8位。
2. 指针是变量的初始地址。
3. 指针的取值范围可能不同与整数的范围，所以一定不能用普通整数型变量来存储地址，但是可以用指针变量。
4. 指针就是地址，而指针变量就是存储地址的变量。

#### 2. 指针变量的声明 1568
1. int *p,说明p是指向int类型对象的指针变量。<font color=green>这里用术语对象来代替变量，是因为p可以指向不属于变量的内存区域。</font>
3. 每个指针变量只能指向一种特定类型(引用类型)的对象。

#### 3. 取地址符 1572
1. 取地址符: &
2. 间接寻址: *
3. 如果p指向i，*p就是i的别名。
4. <font color=red>不要把间接寻址运算符用于未初始化的指针变量。如果指针变量p没有初始化，那么视图使用p的值会导致未定义的行为</font> 
    1. 例如： int *p; printf("%d", *p);
    2. 如果p恰好具有有效内存地址，那么会更改那个地址的数据
    3. 如果p指向的内存单元属于操作系统，那么很可能导致系统崩溃。

#### 4. 指针赋值 1581
1. <font color=green>C语言允许使用赋值运算符进行指针的复制，前提是两个指针具有相同的类型</font>
    1. int i, j, *p, *q; p = &i; q = p;
    2. q = p 是将p的内容(即i的地址)复制给q，效果是把q指向p所指向的地方。

2. 可以const来指明传递给函数的指针所指向的值不可改变。

    void f(const int *p);

3. 指针可以作为函数返回值，但不能指向自动局部变量。可一指向全局变量或者static局部变量。 

4. <font color=green>C函数调用是值传递的。参数是指针时也是值传递，只不过指针的值是一个地址，
赋值的指针值还是指针指向的对象的地址。所以改变p指向的对象时，会影响到外部数据，但是改变指针
本身的地址，不会影响外部的指针。外部的指针还是指向原来对象</font> 1592

#### 8. const int *p 和 int * const p: 1594
1. const 在类型前面，保护的是p所指向的int值
2. const 在类型后面，保护的是p本身
3. <font color=green>主要看*的位置，星号和星号前面表示定义的指针所指向的类型。*号后面说明是什么指针</font>

### 2. 指针与数组 1599
0. C语言啊支持3中(而且只有3种)格式的指针算术运算： 
1. 指针加上整数；
2. 指针减去整数；
3. 两个指针相减： 得到两个指针之间的距离 
4. 在一个不指向任何数组元素的指针上执行算术运算符会导致未定的行为
5. 只有在两个指针指向同一个数组时，把它们相减才有意义。
6. 指针比较：只有在两个指针指向同一个数组时，把它们比较才有意义。
7. 指向复合常量的指针：
    int *p = (int []){3, 0, 3, 4};

#### 2. 指针用于数组处理 1610
1. 例子

        #define N 10
        int a[N], sum, *p;
        sum = 0;
        for (p = &a[0]; p < &a[N]; p++)
            sum += *p;

        尽管a数组没有a[N]这个元素，但这里是安全的，因为a[N]这个地址存在，而这个地址存的值是什么是不知道的，而循环中我们仅仅比较了a[N]的地址，而没有用到a[N]保存的值，所以是非常安全的。

2. *p++: ++的后缀优先级大于*，所以是*(p++)。这个指向的是原来的p的值，先返回值，再加一。

#### 3. 用数组名作为指针 1623
1. 可以用数组名作为指向数组第一个元素的指针。
2. <font color=red>虽然可以把数组名用作指针，但是不能给数组名赋新的值。试图使数组名指向其他地方是错误的</font>
3. <font color=red>对于形式参数而言，声明为数组跟声明为指针是一样的；但对于变量而言，声明为数组和声明为指针是不同的</font>
    1. 声明 int a[10];会导致编译器预留10个整数的空间，但声明int *a;只会导致编译器为一个指针分配空间。后一种情况如果当做数组操作很危险。
4. C语言允许把指针看做数组名进行取下标操作。
    1. 当指针指向一个数组名时，可以当做是数组名来使用，也就是说可以执行下标操作。
    2. 记得，是将指针指向一个数组名时，否可会出现错误
        
#### 4. 指针和多维数组 1632
1. 多维数组在内存中的模型：C语言是按行主序列存储二维数组的；换句话说，先是0行的元素，接着是1行的元素，以此类推。使用指针可以利用这一布局。但只有老编译器支持这种操作。

        对于 int a[NUM_ROWS][NUM_COLS]的循环
        int row, col;
        ...
        for (row = 0; row < NUM_ROWS; row++)
            for (col = 0; col < NUM_COLS; col++)
                a[row][col] = 0;

        但是如果把它看做一维的数组也是可以的，两个循环就成为一个循环了

        int *p;
        ...
        for (p = &a[0][0]; p <= &a[NUM_ROWS-1][NUM_COLS-1])
            *p = 0;

2. 指针处理多维数组的行
    > 为了访问到第i行的元素，需要初始化p指向数组a中第i行的元素0：p = &a[i][0]，可以简写为 p = a [i];

    1. 对于任意数组a来说，a[i] 等价于 *(a + i)，因此，可以推导出以上等式。

            int a[NUM_ROWS][NUM_COLS], *p, i;
            ...
            for (p = a[i]; p < a[i] + NUM_COLS; p++)
                *p = 0;

3. 处理多维数组的列
    1. eg

            int a[NUM_ROWS][NUM_COLS], (*p)[NUM_COLS], i;
            ...
            for (p = &a[0]; p < &a[NUM_COLS; p++)
                (*p)[i] = 0;

    2. 解释
        1. <font color=green>这里把p声明为指向长度为NUM_COLS的整型数组的指针。在(*p)[NUM_COLS]中，*p是需要使用括号的；如果没有括号，编译器认为p是指针数组，而不是指向数组的指针</font>。
        2. 因为p是指向数组的指针，所以*p就是p指向的内容，就是那个数组本身。所以(*p)[i]就是那个数组的第i个元素。

4. <font color=red>用多维数组名作为指针</font>
    1. 无论数组的维数是多少都可以采用任意数组的名字作为数组的指针
    2. int a[NUM_ROWS][NUM_COLS] 的a不是指向a[0][0]的指针，而是指向a[0]的指针
    3. 从C语言的观点来看，这样是有意义的，因为C语言认为a不是二维数组，而是一维数组，且这个一维数组的每个元素又是一维数组。用作指针时，a的类型是 int （*）[NUM_COLS](指向长度为NUM_COLS的整型数组的指针)
    4. 注意，二维数组的名字不是int *类型，所以有的函数调用时，需要的参数是int *时，不可以用二维数组名当做参数 

#### 5. C99 中的指针和变长数组 1677
> 指针可以指向变长数组中的元素

1. 一维变长数组
    
        void f(int n){
            int a[n], *p;
            p = a;
            ...
        }

2. 二维变长数组
    
        void f(int m, int n){
            int a[m][n], (*p)[n];
            p = a;
            ...
        }
    
    1. 如果变长数组是多维的，指针的类型取决于除了第一维外每一维的长度。

    2. </font color=green>C语言中每种类型的内存是固定的，声明时就会分配空间。类型要能完全确定内存的具体大小。而变长数组除外。变长数组是运行时确定的？指针指向的内存空间的大小也必须确定，编译器应该会确定指针所能访问的内存空间的界限，不会允许它操作不在它不能操作的内存空间，所以，p所指向的内存空间界限应该必须是确定的。</font>

#### 6. 问答 1700
1. 指针的加减法并不是将数字加到指针所保存的地址，而是对它进行了缩放，例如如果p的类型是int *，那么p+i通常是p加上4*i。
2. i[a] 和 a[i] 是一样的，对编译器而言，i[a] 等同于 *(i + a)，也就是*(a + i)。但不要这样使用。
3. 形式参数*a和a[]是一样的，都是说明我们期望的实际参数是指针。在这两种情况下，对a进行的运算时相同的，而且在这两种情况下，可以在函数内给a本身赋新的值。C语言要求数组变量的名字是常量指针，但对于数组形式参数的名字没有这一限制。
4. 数组和指针可以互换准确吗？
    1. 不准确。数组型形式参数和指针形式参数是可以互换的，但是数组行变量不同于指针变量。从技术上说，数组的名字不是指针，C语言会在需要的时候把数组的名字转换为指针。对数组a使用sizeof时，sizeof(a)的值是数组中字节的总数，即每个元素的大小乘以元素的数量。但是，如果p是指针变量，sizeof(p)的值则是用来存储指针所需的字节数量。

### 3. 指针的高级应用 1707

#### 1. 动态存储分配 1709
1. C语言的数据结构通常是固定大小的，就是变长数组的长度在运行时确定，但在数组的生命周期内仍然是固定长度的。只有通过重新编译才可以更改数组长度。
2. 动态存储分配可以在程序执行期间分配内存单元。
3. 内存分配函数： <stdlib.h> 头文件
    1. malloc --- 分配内存块，但是不对内存块进行初始化。
    2. calloc --- 分配内存块，并且对内存块进行清零。
    3. realloc--- 调整先前分配的内存块大小。

4. 空指针
    1. 如果找不到满足我们要求的足够大的内存块，函数会返回空指针
    2. 空指针是不知想任何地方的指针，空指针 用名为NULL的宏来表示。
    3. 指针测试真假：所有非空指针都为真，而只有空指针为假。

#### 2. 动态分配字符串 1722
1. malloc为字符串分配内存
    1. void *malloc (size_t size);
    2. p = malloc(n+1)；为n个字符的字符串分配看空间。空字符空间不要忘记。p是char *类型的。可以不用强制转换，void指针自动转换。

2. 在字符串函数中使用动态存储分配
    1. 但要记住，如果不再使用返回的动态存储分配的空间，一定要free掉。

3. 动态分配数组
    1. malloc
    2. calloc 会初始化分配空间即使是struct，成员也会别初始化
        1. void *calloc(size_t nmemb, size_t size);

    3. realloc
        1. void *realloc(void *ptr, size_t size);
        2. 要确定传递给realloc的函数的指针来源元先前的malloc、calloc、realloc的调用，否则会出现异常。
        3. 规则
            1. 当扩展内存时，realloc不会对添加的内存块的字节初始化
            2. 如果realloc不能按要求扩大内存，那么会返回空指针，并且原有数据不变
            3. 如果第一个餐宿是空指针，就像malloc那样
            4. 如果第二个参数是0，那么会释放内存块。

4. 释放存储空间 
    1. malloc函数和其他内存分配函数获得的内存块都是来源于堆。
    2. free函数
        1. void free(void *ptr);
        2. free 函数的实际参数必须是先前内存分配函数的返回的指针，如果是其他对象的指针，可能会导致未定义行为。
    3. 悬空指针问题
        1. 如果释放掉了指针p所指向的内存，而有没有改变p本身，如果继续使用p会导致严重错误，因为程序已经不再对这块内存有任何控制权了。
        2. 悬空指针很难发现，因为几个指针可能指向相同的内存块，在释放内存后，全部指针都悬空了。

5. 链表
1. 例子
        
        struct node {
            int value:
            struct node *next;
        }
2. 这里就是链表为什么必须使用标记而不是typedef类型名。因为编译器知道node 而不知道typedef的类型名，所有在结构体中只能声明struct的标记。

#### 4. 指向函数的指针 1763
1. 函数指针作为参数
    1. double integerate(double （*f）（double）， double a， double b）;
    2. 在*f两边的圆括号说明f是个指向函数的指针
    3. 把f当成函数声明也是合法的，从编译器角度来看，这种原型和前一种形式完全相同。函数名和数组名一样，其实也是指针。
    4. void * 指针可以强制转换为各种类型的指针，但是void *在没有转化为其他类型的指针时不可以访问特定类型的对象，因为不知道指向的内存的类型，也就不知道存储空间的大小。

#### 5. 受限指针 1770
1. 在C99中，关键字 restrict可以出现在指针声明中：用 restrict声明的指针叫做受限指针。

        int * restrict p;

2. 这样做的目的是，如果指针p指向的对象在之后要修改，那么该对象不会允许通过除了指针p之外的任何方式访问。

3. 如果一个函数的两个参数用restrict修饰，那说明这两个参数指向的目标不能重叠。否则有一个参数不可以修改指向的内容，会发生未定义错误。

#### 6. 灵活的数组成员 1779
1. struct hack
    1. 例子

        struct vstring {
            int len;
            char chars[1];
            };
        ...
        struct vstring *str = malloc(sizeof(struct vstring) + n - 1);
        str->len = n;

    2. 这里使用一种“欺骗”的方法，分配了比该结构声明时应具有的内容(n-1)更多的内存，然后使用这些内存来存储chars数组额外的元素。
    3. 有的编译器甚至允许chars的数组的长度为零。

2. 灵活数组成员
    1. 例子

            struct vstring {
                int len;
                char chars[];
            };
    
            struct vstring *str = malloc(sizeof(struct vstring) + n);
            str->len = n;

    2. 灵活数组成员不同寻常之处在于，它在结构内并不占空间。
    3. 规则
        1. 灵活数组成员必须出现在结构的最后
        2. 结构至少还有一个其他成员
        3. 复制包含灵活数组成员的结构时，其他成员都会被赋值，但不复制灵活数组本身。
  
    4. 具有灵活数组成员的结构时不完整类型，不完整类型缺少用于确定所需内存大小的信息。
        1. 不完整类型不能作为其他结构的成员和数组的元素，但数组可以包含指向具有灵活数组成员的结构的指针。

#### 7.问答 1814
1. NULL宏表示什么：NULL实际上表示0。p=0；既可以是整形变量赋值，也可以是给指针赋值为空指针，不容易分辨，所以p = NULL；更清楚
2. 有的NULL的定义如下： #define NULL (void *) 0; 这种技巧是合法的，这样只能将NULL赋值给指针，而不能赋值给int类型。更大的好处是空指针作为参数传递给函数不会出现识别错误(当成是int的0)的情况。
3. 更安全的调用malloc ：  p = malloc(sizeof（*p）); 因为p的类型确定了，所以*p的大小就确定了。所以sizeof（*p）的大小可以计算出来。即使p没有初始化，但我们不需要知道*p的值，而只需要知道它的大小。

### 4. 预处理器 1819
#### 1. 预处理器的最主要能力：
> 宏定义、条件编译、文件包含。 

#### 2. 宏定义 1821
1. 简单的宏/对象式宏
    1. [#define指令 (简单的宏)]    #define  标识符 替换列表
    2. 不要再宏定义中放置任何额外的符号
    3. 不要再宏定义后添加分号，否则宏替换时会加上额外的符号和分号。宏替换只是简单的文本替换
    4. 虽然简单宏常用于定义常量名，但是他们还有其他应用。
        1. 可以对C语法做小的修改
        2. 对类型重命名
        3. 控制条件编译：例如下面可能表明程序在“调试模式”下进行编译，并使用额外的语句输出调试信息： #define DEBUG
        4. 宏定义中的替换列表为空是合法的。
            1. 解释： 定义宏，并在预处理过程中将其替换为空字符串（即删除）。
            2. 意义：这样做主要是为了标记某些内容，使程序阅读者能够清楚标记表明的意义，同时又不影响被编译的源代码。也就是说，用法同define后接两个参数，只是后一个参数为空字符串。
            3. 用途：
                1. 定义一个符号用来给#if(n)def判断。          
                2. 多文件编译中防止头文件被重复包含。


2. 带参数的宏
    1. 定义格式： [#define指令 (带参数的宏)]     #define 标识符(x1, x2, ..., xn)  替换列表
    2. 标识符和左括号之间必须没有空格，否则预处理器会以为它是简单的替换。
    3. 标识符中的参数，在替换列表中时需要加上括号防止引起错误，最外面也要加上一个大括号，防止仅仅文本替换引起的错误。
    4. 带参数的宏可以包含空的参数列表：  #define getchar() getc(stdin)

3. 宏可能导致的错误
    1. 宏可能会不止一次的计算它的参数，函数对他的参数只会计算一次，而宏可能会计算两次升值更多次： n = MAX(i++, j):这里第一个参数每次出现，都会多计算一次，因为宏只是简单的替换。


4. # 和 ## 运算符
    > 宏定义可以包含两个专用的运算符：# 和 ##。编译器不会识别这两种运算符，它们会在预处理时被执行。

    1. # 运算符将宏的一个参数转换为字符串字面量，它仅允许出现在带参数的红替换列表中。#运算符可以使PRINT_INT为每个输出的值添加标签

            #define PRINT_INT(n) printf(#n " = %d\n", n);  
            n之前的#运算符通知预处理器根据PRINT_INT的参数创建一个字符串字面量。 <font color=green>这是一个字面量，相当于把参数有复制了一下，在后面用</font>
            PRINT_INT(i/J);  会变为  printf("i/j" " = %d\n");

    2.  ## 运算符可以将两个记号（如表示符）“粘合”在一起，成为一个标记，如果其中一个操作数是宏参数，“粘合”会在形式参数被相应的实际参数替换后发生。

            #define MK_ID(n)  i##n
            MK_ID(1),预处理器首先使用实际参数替换形式参数n，接着，预处理器将i和1合并成为一个记号（i1）。

            int MK_ID(1), MK_ID(2), MK_ID(3);
            预处理器转变为：
            int i1, i2, i3
            

            #define GENERIC_MAX(type) type type##_max(type x, type y) { return x > y ? x : y;}

            GENERIC_MAX(float)
            GENERIC_MAX(int)

5. 宏的通用属性
    1. 宏的替换列表可以包含对其他宏的调用： #define PI 3.1415926  #define TWO_PI (2 * PI)
    2. 预处理器只会替换完整的记号，而不会替换记号片段，</font color=green>因此，预处理器会忽略嵌在标识符、字符常量、字符串字面量之中的的宏名</font>
    3. 宏定义的作用范围通常到出现这个宏文件的文件末尾
    4. 宏不可以被定义两遍，除非新的定义与旧的定义完全一样。
    5. 宏可以使用#undef指令“取消定义”。  [#undef 指令]  #undef  标识符

6. 宏定义的圆括号：
    1. 对于在一个宏中哪里需要加圆括号有两条规则要遵守
        1. 如果宏的替换列表中有运算符，那么始终要将替换列表放在括号里
        2. 如果宏有参数，每个参数每次在替换列表中出现时都要放在圆括号里。

7. 创建较长的宏
    1. 创建较长的宏时，逗号运算符会十分有用
        
            #define ECHO(S) (get(S), puts(s))
            这个宏会先读入一个字符串，再把字符串显示出来
            使用的是宏字符替换加上逗号运算符的功能

    2. 使用大括号形成复合语句：

            #define ECHO(s) { gets(s); puts(s);}

    3. 以上两种的弊端
        1. 逗号运算符并不能解决所有的问题。加入一个宏需要包含一系列的语句，而不仅仅是一系列的表达式，这时逗号救起不了作用了，因为它只能连接表达式，不能连接语句。
            1. 解决办法是将语句放在do循环中，并将条件设置为假，因此语句只执行一次，但注意，这里最后也要少一个分号，在替换时补全。

                    #define ECHO(s)  \
                            do {
                                gets(s);
                                puts(s);
                            } while (0)

                    ECHO(str);  /* do { gets(str); puts(str); } while (0);*/
        2. 但这样可能会产生错误，例如if 后面跟复合语句的话，大括号后面没有分号，但是写程序时写宏标识符时一个句子应该加分号。
            1. 解决办法，在代码里运用宏的名字ECHO是，不要再ECHO后面加分号。


8. 预定义宏
    > C语言有一些预定义宏，每个宏标识一个整数常量或字符串字面量。

    1. __LINE__   被编译的行号
    2. __FILE__   被编译的文件名
    1. __DATE__   编译的日期（格式"Mmm dd yyyy")
    1. __TIME__   编译的时间（格式"hh:mm:ss")
    1. __STDC__   如果编译器复合C标准（C89或C99），那么值为1

9. 空的宏参数
    > C99 允许宏调用中的任意或所有参数为空，当然这样的调用需要有和一般调用一样多的逗号
    
    1. 例子

            #define ADD(x, y) (X+y)  与处理之后： i = ADD(j, k); 变成 i = (j+k),而赋值语句：i = ADD( , k);则变为 i = (+k)
    2. 空参数是#或是##时有特殊规定，空的实际参数是#的话，空参数被#“字符串化”，则结果为""（空字符串）。
    3. 如果## 运算符之后的一个实际参数为空，它将被不可见的“位置标记”记号代替，把原始的记号与位置标记记号相连接，得到的还是原始的记号（位置标记记号消失了），如果连接两个位置标记记号，得到的是一个位置标记记号，宏扩展完成后，位置标记记号从程序消失。

10. 参数个数可变的宏
    1. 例子

            #define TEST(condition, ...)  ((condition)? printf("Passed test: %s\n", condition): printf(__VA_ARGS__)

11. __func__标识符
    1. __func__与预处理器无关
    2. 每个函数都可以访问__func__标识符，它的行为很像一个存储当前正在执行的函数的名字的字符串变量，作用相当于在函数体的一开始包含如下生命

            static const char __func__[] = "function-name"

    3. 这个标识符可是让我们写出如下宏
            
            #define FUNCTION_CALLED() printf("%s called\n", __func__);
    4. __func__的另一个用法：作为参数传递给函数，让函数知道调用它的函数的名字。

#### 3. 条件编译 1944
1. #if 和#endif
    1. 调试
            
            #define DEBUG 1
            #if DEBUG
            ...
            #endif
    2. 在预处理过程中，#if会测试DEBUG的值，如果DEBUG不为0，预处理器将if和endif之间的语句保留#if和#endif消失，如果DEBUG是0，会将之间的语句也一起删除。
    3. 当#if指令会把没有定义过的标识符当做0对待，#if DEBUG会失败，#if !DEBUG会成功

2. defined运算符
    > defined 应用于标识符时，如果标识符是一个定义过的宏则返回1，否则返回0，defined 长于#if指令结合使用。

3. #ifdef 指令和 #ifndef
    > #ifdef 指令测试一个标识符是否已经定义为宏  #ifdef 标识符。结尾需要和 #endif对应。#ifdef相当于 #if defined(标识符)

4. #elif 和#else
    > #if、#ifdef、#ifndef可以向普通的if语句那样嵌套使用

5. 使用条件编译
    1. 编写在多台机器可移植额程序

            #if defined(WIN32)
            ...
            #elif defined(MAC_OS)
            ...
            #elif defined(LINUX)
            ...
            #endif

    2. 编写用不同的编译器的程序

    3. 为宏提供默认定义：先检测一个宏是否定义，若没有定义可提供一个默认定义

    4. 临时屏蔽包含注释的代码

#### 4. 其他指令 1981
1. #error
2. #line
    1. #line n
    2. #line n “文件”
    3. #pragma

#### 5. 问答 1988
1. 什么常量需要定义为宏：除了0和1意外的每一个数值常量都应该定义为宏。字符串的话，在不止一次使用或可能改变的常量

### 5. 大型程序源文件结构 1991
#### 1. 源文件 1992
1. 把程序分成多个源文件有许多显著的优点
    1. 结构清晰
    2. 可以分别对每个源文件进行编译
    3. 有利于复用

#### 2. 头文件 1998
1. 共享宏定义和类型定义
2. 共享函数原型
    1. 在文件foo.c中定义了函数f，则把头文件命名为foo.h
    2. <font color=green>在含有函数f定义的源文件中始终包含声明函数f的头文件</font>
    3. 仅用于单一文件的函数不需要在头文件中声明。
3. 共享变量声明
    1. 声明变量 ：int i，这样不仅声明了i是int类型的，而且也对i进行了定义，从而使编译器为i留出了空间，为了声明而不是定义它，需要在变量的声明处放置extern关键字。
        
            extern int i;
            
        1. extern 告诉编译器，变量i是在程序中的其他位置定义的（很可能不在同一个源文件），因此不需要为i分配空间。
        2. extern 可以用于所有类型的变量，在数组的声明中使用extern时，可以省略数组的长度：  extern int a[];因为编译器不需要为数组分配空间，也就不需要知道数组的长度。

4. C应该注意头文件嵌套，但C++头文件嵌套很常见
5. 保护头文件：如果源文件包含同一个头文件两次，那么很可能产生编译错误，当头文件包含其他头文件时，这种问题十分普遍。头文件只包含变量、函数原型、宏没关系，但有类型定义，会编译错误。
    1. 为了防止头文件多次包含，用#ifdef和#endif指令来封闭文件的内容

6. 头文件中的#error指令
    1. 例如用到在C89不存在的特性时，要检查编译器的版本

            #ifndef __STDC__
            #error This header requires a Standard C compiler

#### 3. 把程序划分为多个文件 2022


### 6. 其他 2025
#### 1. c程序通常包含3个步骤 2026
- 预处理
- 编译
- 链接

2. 在任何需要数值的地方，都可以使用具有相同类型的表达式。 2031

#### 3. 宏 2033
1. 当宏包含运算符时，必须用括号把表达式括起来。
    
        #define RECIPROCAL_OF_PI （1.0f / 3.1415f)

2. 宏的名字只用了大写字母

#### 4. 代码规范 2040
1. 语句可以分开放在任意多行内
2. 在每个运算符的前后都放上一个空格
3. 每个逗号后放一个空格
4. 缩进
5. 空行可以把程序划分为逻辑单元

## 十六. C/C++ 需要考虑内存模型 2047
### 1. 字面值的内存位置 2048
1. 对于整数类型，如果出现在表达式语句中，通常会成为“立即数”，被包含在生成的代码中。

2. 没有参与代码生成的常量，比如用于全局变量的初始化、数组声明、模板参数等等，哪里也不存，在编译期就处理了。

3. 其它常量，通常放在静态数据区。

4. 字符串常量会放在一个专用的字符串池内存块中，或者放在静态数据区中。
有些编译器还会安排在代码区一起（视所用的编译器和编译选项而定）

5. 数字常量占用代码段汇编指令的操作数部分。
﻿### 位域
    1. 一个位域必须存储在同一个字节中，不能跨两个字节。如一个字节所剩空间不够存放另一位域时，
	应从下一单元起存放该位域。也可以有意使某位域从下一单元开始。  

    2. 位域的长度不能大于指定类型固有长度，比如说int的位域长度不能超过32，bool的位域长度不能超过8
﻿## c多态
### c语言多态需要两个元素 2065
1. 像c++一样，可以通过指向父类的指针，也可以指向子类这个特点
2. 父类子类绑定不同的对象，成员和函数。

### c语言实现 2069
1. struct 指针可以通过强制转换，是的一个指针可以指向另一个struct的指针，前提是两个struct拥有一样成员位置
    1. 这里说的是内存对齐。父指针和子指针对对象的操作是通过相同位置的内存来实现的，如果父指针指向的对象和子指针指向的对象的成员内存位置不同，会报错。
    2. 所以一般父和子有相同的成员布局。
    3. 例子：
        父struct 有两个成员，两个函数，子struct只有两个函数，而没有成员，
		调用指向子struct的父struct指针print会报错，段错误。因为父子相同内存内容不一样. 
```
        +-------+------+------+------+----+
        | width |hight |print |area  | 16 |
        +-------+------+------+------+----+
        |   4   | 4    | 4    |4     |    |   
        +-------+------+------+------+----+

        +-------+------+----+
        | print |area  | 8  |
        +-------+------+----+
        |   4   | 4    | 4  |
        +-------+------+----+
```

    4. 所以，父子对象需要有相同长度的成员，对齐他们的内存位置

    5. 父指针想c++的父指针一样，只能调用父对象已有的对象，不能访问子对象有而父对象没有的内容，即使指针实际指向的是子对象。

[链接](https://www.cnblogs.com/wuyudong/p/achieving-polymorphism-in-c.html)
﻿## C/C++中的static和extern关键字
### 原理 2096
1. 首先，关于声明和定义的区别。
	1. 只有分配存储空间的变量声明才叫变量定义，其实函数也是一样，
	2. 编译器只有见到函数定义才会生成指令，而指令在程序运行时当然也要占存储空间。
	3. 那么没有函数体的函数声明有什么用呢？
		1. 它为编译器提供了有用的信息，编译器在翻译代码的过程中，只有见到函数原型（不管带不带函数体）
			之后才知道这个函数的名字、参数类型和返回值，这样碰到函数调用时才知道怎么生成相应的指令，
			所以函数原型必须出现在函数调用之前，这也是遵循“先声明后使用”的原则。

2. 标识符的链接属性（Linkage）有三种

	1. 外部链接（ExternalLinkage）

		如果最终的可执行文件由多个程序文件链接而成，一个标识符在任意程序文件中即使声明
		多次也都代表同一个变量或函数，则这个标识符具有External Linkage。具有External
		Linkage的标识符编译后在符号表中是GLOBAL的符号。

	2. 内部链接（InternalLinkage）

		如果一个标识符在某个程序文件中即使声明多次也都代表同一个变量或函数，则这个标识
		符具有Internal Linkage。具有Internal Linkage的标识符编译后在符号表中是LOCAL的符号。

	3. 无链接（NoLinkage）

		除以上情况之外的标识符都属于No Linkage的，例如函数的局部变量，以及不表示变量和
		函数的其它标识符。

3. 声明和定义的次数限制

	1. 凡是被多次声明的变量或函数，必须有且只有一个声明是定义，如果有多个定义，
		或者一个定义都没有，链接器就无法完成链接。显然，声明可以有很多次。


### static:  2129
0. <font color=red>静态成员只初始化一次，所以再次调用函数，函数的局部static变量不会再次初始化。</font>

	当编译器处理函数内部static静态变量时，遇到静态变量的初始化，就会在函数f外单独生成一条命令，给j赋值为0. 这些命令甚至会在函数调用以前就执行

1. 在C中，static主要定义全局静态变量、定义局部静态变量、定义静态函数。

	1. 定义全局静态变量：在全局变量前面加上关键字static，该全局变量变成了全局静态变量。全局静态变量有以下特点。

		- 在全局区分配内存。

		- 如果没有初始化，其默认值为0.

		- 该变量在本文件内从定义开始到文件结束可见。

	2. 定义局部静态变量：在局部变量前面加上关键字static，其特点如下：

		- 该变量在全局数据区分配内存。

		- 它始终驻留在全局数据区，直到程序运行结束。

		- 其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。

	3. 定义静态函数：在函数返回类型前加上static关键字，函数即被定义为静态函数，其特点如下：

		- 静态函数只能在本源文件中使用

		- 在文件作用域中声明的inline函数默认为static类型

2. 在C++中新增了两种作用：定义静态数据成员或静态函数成员。

	1. 定义静态数据成员。

		- 内存分配：静态数据成员在程序的全局数据区分配。

		- 初始化和定义：静态数据成员定义时要分配空间，所以不能在类声明中定义。

			静态数据成员因为程序以开始运行就必须存在，所以其初始化的最佳位置在类
			的内部，public、protected、private关键字对它的限定和普通数据成员一样，因为其空
			间在全局数据分配，属于所有本类的对象共享。它不属于特定的类对象，在没产生类对象
			时，其作用域可见，即没有产生类的实例时，就可以操作它了。

			静态成员函数。静态成员函数与类相联系，不与类的对象相联系。静态成员函数不能访问
			非静态数据成员。

### extern 2174
1. extern可以置于变量或函数前，以在别的文件中标识变量或函数的定义，并提示编译器遇到此变量或函数时在其他模块中寻找其定义。
2. extern是C、C++语言中表明函数和全局变量作用范围（可见性）的关键字。
3. 对于extern变量来说，仅仅是一个变量的声明，其并不是定义，不会分配内存空间。
4. extern表示将变量或函数声明为外部链接，变量默认是内部链接，函数默认是外部链接。
	因此用来外部链接的函数，声明时有无extern都可以连接通过。而全局变量则不行。
5. 通常，在模块的头文件中，对本模块提供给其他模块引用的函数和全局变量以关键字extern声明。

﻿## 生存周期与作用域的区别： 
1. 生存周期: 变量从定义到销毁的时间范围。存放在全局数据区的变量的生存周期存在于整个程序运行期间，而存放在栈中的数据则随着函数等的作用域结束导致出栈而销毁，除了静态变量之外的局部变量都存放于栈中。
 
2. 作用域: 变量的可见代码域（块作用域，函数作用域，类作用域，程序全局作用域）。

3. <font color=green>static变量是指静态的变量，不管是在全局还是局部声明的static变量都存放于程序的全局变量区域，所以它的生命周期是从程序开始到程序结束。但是static变量的作用域并不等同于它的生存周期，它的作用域决定于它被定义的位置。可以认为static变量的作用域<=生存周期。</font>

	1. 举一个局部声明的例子。在函数test中声明静态变量i：
 
			void test() 
			{ 
			int m=3; 
			static int i=5; 
			} 

		1. 局部变量m存放在栈中，当test函数结束，m将被销毁；
		2. 静态变量i不存放在栈中，而是存放于程序的全局变量区域，因此随着函数test的结束，它并不随着出栈操作而被销毁，它的生存周期存在于程序的整个运行期；
		3. 然而m和i的作用域都仅存在于test函数中它们的定义之后，即test调用结束之后，m和i就不再可用，但是i仍存在于内存之中。

	2. 再举一个全局声明的例子。在文件A 中定义静态变量j：
	 
			int n=3; //默认为extern 
			static int j=5; //声明为static 

		1. 全局变量和静态变量j都存放于程序的全局数据区域，它们的生存周期都是程序的整个运行期，但是n的作用域为全局作用域，可以通过extern在其他文件中使用，而j只能在文件A中使用，
		2. 例如在文件B中：
		 
				extern int n; //ok 
				extern int j; //error: j在文件B中不可见 
				int a=n;//ok：但这里有个初始化先后的问题，具体参见参考一 
				int b=j;//error 

		3. 也就是说，在声明全局的static变量时，static没有改变它的生存周期，也即存储位置（因为全局变量本来就存储在全局数据域），而是将变量的作用域限制在当前文件中。

4. <font color=red>注意</font>
	1. include "source" 是将包含的文件source(不管是头文件还是源文件)整个添加到文件内，所以source中定义的内容都相当于本文件定义的内容，source中定义的变量无论是static还是extern，本文件都可以访问，且不需要加extern。
	2. 如果include "source"了，g++后面就可以省略掉被包含文件的源文件了，否则如果某个函数或者变量它和它的头文件都没有被include到main文件里，而又用到它了，需要在编译时将源文件添加上，是的编译器可以找到函数定义。这是在编译时一同加上的源文件中定义的static才是真正的隔离了作用域作用。

	3. 例子
		1. extern_static.h

		```
		#ifndef _EXTERN_STATIC
		#define _EXTERN_STATIC
		#include <stdlib.h>
		#include <stdio.h>

		void print_01();
		extern void print_02(); //函数不写任何声明的情况和写了extern声明的情况等价，函数的声明默认是extern的。
		static void print_03(); //static修饰函数声明，说明此函数仅仅被此文件内部使用，
								//即被extern_stattic.h 和extern_static.cpp内部调用，而不能被main.cpp内调用。
		void print_04();
		#endif
		```

		2. extern_static.cpp
		```
		#include "extern_static.h"

		static int a = 100;
		int b = 200;

		void print_01(){
			printf("test_01\n");
			return;
		}

		void print_02(){

			printf("test_02\n");
			return;
		}

		void print_03(){
			printf("test_03\n");
			return;

		}

		void print_04(){
			printf("call print_03() in print_04() start\n");
			print_03();
			printf("call print_03() in print_04() finsh\n");
			return;

		}
		```

		3. main.cpp
		```
		#include "extern_static.h"

		int main()
		{
			print_01();
			print_02();
			//print_03();
			print_04();
			extern int b;
			printf("b is :%d", b);
			int c = getchar();

		}
		```
		4. <font color=red>编译</font> 
			1. main.cpp include了头文件，所以main.cpp源文件其实被插入了extern_static.h 代码，所有这个头文件中的代码都和main.cpp在头一个文件中，所以它们不管是static还是extern都可以直接用。
			2. 因为没有包含extern_static.cpp源文件，所以编译时要告诉编译器函数定义在哪里：g++ main.cpp extern_static.cpp -o test

			3. 定义在extern_static.cpp中的static变量main不可以访问，因为不在同一个文件中，static限定作用域只有本文件可以访问。extern全部文件可以访问

			4. 如果不写头文件，main直接包含extern_static.cpp也是可以的，这时编译器将整个extern_static.cpp插入main.cpp源文件，这是编译时不用再指定extern_static.cpp源文件:g++ main.cpp -o test。否则会报错:g++ main.cpp extern_static.cpp，因为编译器读到两边extern_static.cpp 内容。
4. <font color=green>C语言中，实际参数是通过值传递的</font> 689

### note 2295
1. <font color=green>C语言中，实际参数是通过值传递的</font> 689

