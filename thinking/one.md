## 模式 680
> 之所以要加上抽象类,是因为在强类型语言中,是通过指向父类的指针指向派生类来实现多态的.

### 简单工厂模式 683
1. 通过一个字符串来生成一个类.然后使用者是一个指向父类的指针.实现多态.

### 工厂方法 686
> 定义一个用于创建对象的接口,让子类决定实例化哪一个类.工厂方法使一个类的实例化延迟到其子类.

1. 每个需要实例化类都有一个对应的工厂类/方法. 使用时先实例化类工厂对象,然后使用类工厂对象创建需要的对象.

2. 需要客户自己决定初始化哪一个工厂类.

3. 声明了很多个工厂类/工厂方法.

4. 工厂方法克服了简单工厂违背开放-封闭原则的缺点,又保持了封装对象创建过程的优点.

5. 工厂方法模式是简单工厂模式的进一步抽象和推广.由于使用了多态性,
工厂方法模式保持了简单工厂模式的优点,而又克服它的缺点.
但缺点是每加一个产品,就需要添加一个产品工厂类,增加了额外的开发量.

### 策略模式 701
> 它定义了算法家族,分别封装起来,让它们之间可以互相替换,此模式让算法的变化,不会影响到使用算法的客户

1. 上下文: 上下文中包含一个抽象算法类实例,通过改变这个属性,上下文可以改变具体的策略类.

2. 结构图:
	1. Context: 上下文,用一个ConcreteStrategy来配置,维护一个对strategy的对象的引用
	2. Strategy: 策略类,定义所有支持的算法的公共接口
	3. ConcreteStrategy: 具体策略类,封装了具体的算法行为,继承于Strategy

### 装饰器模式 711
> 动态地给一个对象添加一些额外的职责,就增加功能来说,装饰器模式比生成器模式更为灵活.

1. component是定义一个对象接口,可以给这些对象动态的添加职责.
2. concreteComponent是定义一个具体的对象,也可以对这个对象添加一些职责.
3. Decrator,装饰器抽象类,继承了Component,从外类来扩展Component类的功能.
但对于Component来说,是无需知道Decorator的存在的.

4. 总结:
	Decorator包含一个component对象,通过调用自己的同名方法时,
调用component对象的方法,然后在添加一些步骤.

### 代理模式 723
> 为其他对象提供一种代理以控制对这个对象的访问.

1. 代理模式的subject类和proxy类共用同样的接口.这样就在任何使用RealSubject的地方都可以使用proxy

2. proxy包含一个subject对象作为属性.

2. 使用场景:
	1. 远程代理,也就是为一个对象在不同的地址空间提供局部代表,
	这样可以隐藏一个对象存在于不同地址空间的事实.

	2. 虚拟代理, 是根据需要创建开销很大的对象,通过它来存放实例化需要很长时间的真实对象.

	3. 安全代理, 用来控制真实对象访问时的权限.

	4. 智能指针,是指当调用真实的对象时,代理处理另外一些事.

### 原型模式 740
> 用原型实例指向创建对象的种类,并且通过拷贝这些原型创建新的对象.

1. 原型模型其实就是从一个对象在创建另外一个可定制的对象,而且不需要知道任何创建细节.

2. 结构图:
	1. client: 指向一个prototype
	2. portotype: 原型类,声明一个clone自身的接口
	3. concretePrototype: 具体原型类,实现一个克隆自身的操作.

3. 一般在初始化的信息不发生变化的情况下,克隆是最好的办法.这既隐藏了对象创建的细节,
又对性能是大大的提高

4. 深拷贝/浅拷贝

### 模板方法模式 755
> 定义一个操作中的算法的骨架,而将一些步骤延迟到子类中.模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤.

1. 结构图:
	1. AbstractClass: 实现了一个模板方法,定义了算法的骨架,具体子类将重定义PrimitiveOperation
	以实现一个算法的步骤.
		1. TemplateMethod()
		2. PrimitiveOperation1()
		3. PrimitiveOperation2()

	
	2. ConcerteClass: 实现PrimitiveOperation以完成算法中与特定子类相关的步骤.
		1. PrimitiveOperation1()
		2. PrimitiveOperation2()

	3. ConcerteClass 继承自AbstractClass

2. AbstractClass
```
abstract class AbstractClass
{
	public abstract void PrimitiveOperation1();
	public abstract void PrimitiveOperation2();
	//一些抽象行为,放到子类去实现.

	public void TemplateMethod(){
		PrimitiveOperation1();
		PrimitiveOperation2();
		Console.WriteLine("");

		//模板方法,给出了逻辑的骨架,而逻辑的组成是一
		//些相应的抽象操作,它们都延迟到子类实现.
	}
}
```

3. concreteClass:
	实现了父类定义的一个或多个抽象方法,每一个AbstractClass都可以有任意多个concreteClass
与之对应,而每一个ConcreteClass都可以给出这些抽象方法(也就是顶级逻辑的组成步骤)的不同实现,
从而使得顶级逻辑的实现各不相同.

4. 模板方法模式是通过把不变行为搬移到超累,去除子类中的重复代码来体现它的优势.

### 外观模式 798
> 为子系统中的一组接口提供一个一致的界面,此模式定义了一个高层接口,这个接口使得这一子系统更容易使用.
> 类似于股票与基金

1. 结构图
	1. client
	2. Facade: 外观类,知道哪些子系统负责处理请求,将客户的请求代理给适当的子系统对象
		- MethodA()
		- MethodB()

	3. SubSystemOne, SubSystemTwo....: 子系统类集合,实现子系统的功能,处理Facade对象的指派的人物.
		注意子类中没有Facade的任何信息,既没有对Facade对象的引用.
		- MethodOne() ...

2. 使用场景
	1. 在设计初期阶段,应该要有意识地将不同的两个层分离
	2. 开发阶段,子系统往往因为不断的重构烟花而变得越来越复杂,增加外观模式可以提供一个简单的接口,减少它们之间的依赖.
	3. 维护一个遗留的大型系统时,可能这个系统已经非常难以维护和扩展,可以为新系统开发一个外观模式类,
	来提供设计粗超或高度复杂的遗留代码的比较清晰的简单接口.

### 建造者模式 818
> 将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示.

1. 结构图
	1. Builder: 为创建一个Product对象的各个部件指定的抽象接口
		- buildPart()

	2. ConcreteBuilder: 具体建造类,实现Builder接口,构造和装配各个部件

	3. Director: 指挥类,是构建一个使用Builder接口的对象,按照顺序调用builder中指定各个方法.

	4. Product: 具体产品.

### 观察者模式 831
> 定义了一宗一对多的依赖关系,让多个观察者对象同时监听某一个主题对象.这个主体对象在状态发生变
化时,会通知所有观察者对象,使它们能够自动更新自己.

1. 构造图:
	1. Subject类,它把所有对观察者对象的引用保存在一个聚集里,每个主题都可以有任何数量
	的观察者,抽象主题提供一个接口,可以增加和删除观察者对象.

	2. Observer类,抽象观察者,为所有的具体观察者定义一个接口,在得到主体的通知时更新自己.

	3. ConcreteObserber: 具体观察者,实现抽象观察者所要求的更新接口,以便使本身的状态
	与主题的状态相协调.

	4. conreteSubject: 具体主题,将有关状态存入具体观察者对象,在具体主题的内部状态改,
	变时,给所有登记过的观察者发出通知.

2. 应用场景
	1. 当一个对象的改变需要同时改变其他对象的时候,而且它不知道具体有多少对象有
	待改变时,应该考虑观察者模式.

3. 如果观察者的通知方法名称不同的话,可以使用事件委托(一个包装函数的类,统一调度),来
委托执行具体方法.

### 抽象工厂模式 854
> 提供一个创建一系列相关或相互依赖对象的接口,而无需指定他们具体的类.
0. 记忆点:
	程序换数据库,多个表要有不同数据库的实现.

1. 结构图:
	1. AbstractFactory: 抽象工接口,它里面应该包含所有的产品创建的抽象方法.
		- CreateProductA()
		- CreateProductB()

	2. ConcreteFactory1: 具体的工厂类,创建具有特定实现的产品对象

	3. AbstractProductA: 抽象产品,它们都有可能有两种不同的实现

	5. AbstractProductB: 抽象产品,它们都有可能有两种不同的实现

	4. ProductA1, ProductA2...: 对两个抽象产品的具体分类的实现

	6. ProductB1, ProductB2...: 对两个抽象产品的具体分类的实现

2. 解释:
	- AbstractProductA和AbstractProductB是两个抽象产品,它们都有可能有多个不同的实现.
	- ProductA1,ProductA2和ProductB1,ProductB2就是对两个抽象产品具体分类的实现.

	- IFactory是一个抽象工厂接口,它里面应该包含所有产品创建的抽象方法
	- ConcreteFactory1和ConcreteFactory2就是具体的工厂.

	- 通常是在运行时刻在创建一个ConcreteFactory类的实例,这个具体工厂在创建具有特定实现的产品对象.
	也就是说,为创建不同的产品对象,客户端应使用不同的具体工厂.

3. 只有一个User类和User类的时候,是只需要工厂方法模式,但是当换数据库类似的任务时,有多个表,
而Sql server和Access又是两大不同的分类,所以解决这种涉及多个产品系列的问题时,
有一个专门的工厂模式叫做**抽象工厂模式**.

4. 优缺点:
	1. 便于交换产品系列
	2. 让具体的创建过程与客户端分离,客户端是通过它们的抽象接口操纵实例,
	产品的具体类名也被具体工厂实现分离,不会出现在客户代码中.

### 状态模式 893
> 当一个对象的内在状体改变时允许改变其行为,这个对象看起来像是改变了其类.

1. 状态模式主要解决的是**当控制一个对象状态转换**的条件表达式过于复杂时的情况.
把状态的**判断逻辑转移到表示不同状态的一系列的类**当中,可以把复杂的判断逻辑简化.

2. 如果这个状态判断很简单,那就没有必要用"状态模式".

3. 结构图:
	1. State: 抽象状态类,定义一个接口以封装与Context的一个特定装体相关的行为.

	2. ConcreteStateA: 具体状态类,每一个子类实现一个与Context的一个状态相关的行为.

	3. Context: 维护一个concreState子类的实例,这个实例定义当前的状态. 

### 适配器模式 908
> 将一个类的接口转换成客户希望的另外一个接口.Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作.

1. 场景:	
	1. 系统的数据和行为都正确,但接口不符时,我们应该考虑用适配器,目的是使控制范围之外的一个原有对象与某个接口匹配.
	2. 适配器模式主要应用于希望福永一些现存的类,但接口又与复用环境要求不一致的情况.

2. 两种适配器模式
	1. 类是配器: 通过多重继承对一个接口与另一个接口进行匹配

	2. 对象适配器:

### 备忘录模式 920
> 在不破坏封装性的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态.
> 这样以后就可将该对象恢复到原先保存的状态.

1. 结构图:
	1. Originator: 负责创建一个备忘录Memento,用以记录当前时刻它的内部状态,并可使用备忘录恢复内部状态
		- + Statte
		- + SetMemento(in m:Memento)
		- + CreateMemento()

	2. Memento: 负责存储Originator对象的内部状态,并可防止Orinator以外的其他对象访问备忘录Memento
		- + State

	3. Caretaker: 负责备保存好备忘录 Memento,不能对备忘录的内容进行操作或检查.
		- - Memento

### 组合模式 936
> 将对象组合成树形结构以表示"部分-整体"的层次结构.组合模式使得用户对单个对象和组合对象的使用具有一致性.

1. 场景:
	1. 整体和部分可以被一致对待的问题.

	2. 需求中是体现部分与整体层次的结构时,以及希望用户可以忽略组合对象与单个对象的不同,
	统一的使用组合结构中的所有对象时,就应该考虑使用组合模式了.

2. 结构图
	1. Component: 组合对象声明接口,在适当情况下,实现所有类共有接口的默认行为.生命一个接口用于访问和管理Component的子部件.
		1. + Add(in c: Component)
		2. + Remove(in c: Component)
		3. + Dispaly(in depth: int)

	2. Leaf: 在组合中表示叶节点对象,叶节点没有子结点.
		1. + Display(in depth: int)

	3. Composite: 定义有枝节点行为,用来存储子部件,在Component接口中实现与子部件有关的操作,比如增加Add和删除Remove.
		1. + Add()
		2. + Remove()
		3. + Display()

	4. 2,3 继承自1. Composite聚合指向Component


### 迭代器模式 962
> 迭代器模式,提供一种方法顺序访问一个聚合对象中的各个元素,而又不暴露该对象的内部表示.

1. 场景:
	1. 一个聚集对象,而且不管这些对象是什么都需要遍历的时候,需要考虑迭代器模式.
	2. 需要对聚集有多种方式遍历
	3. 为遍历不同的聚集结构提供如开始,下一个,是否结束,当前哪一项等统一的接口.

2. 结构图:
	1. Aggregate: 抽象聚集类
	2. ConcreteAggregate: 具体抽象类,继承Aggregate
	3. Iterator: 迭代抽象类,用于定义得到开始对象,得到下一个对象...统一接口
		- + First()
		- + Next()
		- + IsDone()
		- + CurrentItem()

	4. ConcreteIterator: 具体迭代类,继承Ietrator,实现...
	
### 单例模式 981
> 保证一个类仅有一个实例,并提供一个访问它的全局访问点.

1. 所有类都有构造方法,不编码则系统默认生成空的构造方法,
	若有显示定义的构造方法,默认的构造方法就会失效.
	
### 桥接模式 987
> 将抽象部分与它的实现部分分离,使它们都可以独立的变化.

1. 比如手机:按照品牌分类,按照软件来分类.手机是一个独立的对象,它包含的品牌,软件可以独立变化.
2. 我的理解是一个类中包含不同的抽象类属性.

### 命令模式 993
> 将一个请求封装为一个对象,从而是你可以用不同的请求对客户进行参数化;
> 对请求排队或记录请求日志,以及支持可撤销的操作.

1. 结构图:
	1. Command: 用来声明执行操作的接口:
		- +Excute()

	2. Invoker: 要去该命令执行这个请求

	3. Receiver: 知道如何实施与执行一个请求相关的操作,任何类都可能作为一个接受者

	4. ConcreteCommand: 将一个接受者对象绑定于一个动作,调用接受者相应的操作,以实现Execute

### 职责链模式 1007
> 使多个对象都有机会处理请求,从而避免请求的发送者和接受者之间的耦合关系.将这个对象连成一条链,
> 并沿着这条链传递该请求,直到有一个对象处理它为止.

### 中介模式 1011
> 用一个中介对象来封装一系列的对象交互,中介者使各对象不需要显式地相互引用,从而使其耦合松散,
> 而且可以独立地改变它们之间的交互

### 享元模式 1015
> 运用共享技术有效地支持大量细粒度的对象.

1. 在享元对象内部并且不会随环境改变而改变的共享部分,可以称为是享元对象的内部状态,而随环境改变而改变,
不可以共享的状态就是外部状态.

2. 享元模式可以避免大量非常相似的开销.

3. 享元模式执行时所需的状态时有内部的也可能有外部的,内部状态存储于具体享元对象中,而外部对象则应该考虑
由客户端对象存储或计算

### 解释器模式 1026
> 给定一个语言,定义它的文法的一种表示,并定义一个解释器,这个解释器使用该表示来解释语言中的句子.

### 访问者模式 1029

## 原则 1031
### 单一职责原则 1032
> 单一职责原则(SRP),就一个类而言,应该仅有一个引起它变化的原因.

1. 如果一个类承担过多的职责,就等于把这些职责耦合在一起,一个职责的变化可能会削弱或者抑制这
	个类完成其他职责的能力. 这种耦合会导致脆弱的设计,当发生变化时,设计会遭受到意想不到的破坏.

2. 软件设计真正要做的许多内容,就是发现职责并把那些职责相互分离:
	如果您呢个想到多于一个的动机去改变一个类,那么这个类就具有多于一个职责,就应该考虑类的职责分离.

### 开放-封闭原则 1041
> 是说软件实体(类,模块,函数等等)应该可以扩展,但是不可以修改.

1. 无论模块是多么的"封闭",都会存在一些无法对之封闭的变化.既然不可能完全封闭,
设计人员必须对于他设计的模块应该对哪种变化封闭做出选择.他必须先猜测出最有
可能发生的变化种类,然后构造抽象来隔离那些变化.

2. 在我们最初编写代码使,假设变化不会发生,当变化发生时,我们就创建抽象来隔离以后发生的同类变化.

3. 面对需求,对程序的改动是通过增加新代码进行的,而不是更改现有的代码.这就是"开放-封闭原则的精神所在."

4. 我们希望的是在开发工作展开不就就知道可能发生的变化,查明可能发生的变化所等待的时间越长,要创建的抽象就越困难.

5. 开放-封闭原则是面向对象设计的核心所在.遵循这个原则可以带来面向对象技术所声称的巨大好处,也就是可维护,可扩展,可复用,灵活性好.
	开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象,然而,对于应用程序的每个部分都可以的进行抽象同样不是一个好的主意.拒绝不成熟的抽象和抽象本身一样重要.

### 依赖倒转原则 1057
> 抽象不应该依赖细节,细节应该依赖与抽象.就是针对接口编程,不要对实现编程.

1. 里氏代换原则: 子类型必须能够替换掉它们的父类型.

2. 由于子类型的可替换性才使得使用父类类型的模块在无序修改的情况下就可以扩展.

### 迪米特法则 1064
> 如果两个类不必彼此直接通信,那么这两个类就不应当发生直接的相互作用.如果一个类需要调用另一个类的某一个方法的话,可以通过第三者转发这个调用.

### 合成/聚合复用原则: 1067
> 尽量使用合成/聚合,尽量不要使用类继承.
