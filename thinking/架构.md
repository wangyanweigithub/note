
<!-- vim-markdown-toc GFM -->

* [范式 98](#范式-98)
		* [命令范式 108](#命令范式-108)
		* [声明范式 123](#声明范式-123)
		* [对象范式 135](#对象范式-135)
		* [并发范式 140](#并发范式-140)
		* [泛型式 145](#泛型式-145)
		* [元编程 156](#元编程-156)
		* [切面式 158](#切面式-158)
		* [事件驱动式 160](#事件驱动式-160)
		* [215 196](#215-196)
	* [框架: 198](#框架-198)
* [并发模式  208](#并发模式--208)
	* [服务访问和配置模式 210](#服务访问和配置模式-210)
		* [包装器模式 213](#包装器模式-213)
		* [组件配置器 215](#组件配置器-215)
		* [截取器 216](#截取器-216)
		* [扩展接口 217](#扩展接口-217)
	* [事件处理模式 219](#事件处理模式-219)
		* [反应器(Reactor)/分配器/通知器 220](#反应器reactor分配器通知器-220)
			* [Reactor模式结构 364](#reactor模式结构-364)
		* [主动器(Proactor) 393](#主动器proactor-393)
			* [Proactor模式结构 430](#proactor模式结构-430)
			* [业务流程及时序图 447](#业务流程及时序图-447)
		* [reactor和proactor的区别 458](#reactor和proactor的区别-458)
			* [对比两者的区别 471](#对比两者的区别-471)
		* [更好的proactor 514](#更好的proactor-514)
		* [异步完成标记 589](#异步完成标记-589)
		* [接收器-连接器 592](#接收器-连接器-592)
	* [同步模式 595](#同步模式-595)
		* [定界加锁(Scoped Locking) 596](#定界加锁scoped-locking-596)
		* [策略花加锁 597](#策略花加锁-597)
		* [线程安全接口 599](#线程安全接口-599)
		* [双检查加锁优化 600](#双检查加锁优化-600)
	* [并发模式 602](#并发模式-602)
		* [主动对象 603](#主动对象-603)
		* [监视对象 604](#监视对象-604)
		* [半同步/半异步 605](#半同步半异步-605)
		* [领导者/追随者 606](#领导者追随者-606)
		* [线程特定的存储器 607](#线程特定的存储器-607)
* [python asyncio 609](#python-asyncio-609)
	* [高级接口 610](#高级接口-610)
		* [Tasks 612](#tasks-612)
		* [队列集 613](#队列集-613)
		* [子进程集 614](#子进程集-614)
		* [流 616](#流-616)
			* [protocol/协议 617](#protocol协议-617)
			* [只读协议 618](#只读协议-618)
			* [只写协议 619](#只写协议-619)
			* [读写协议 620](#读写协议-620)
		* [同步 622](#同步-622)
		* [异常 623](#异常-623)
* [c++ 原生async 625](#c-原生async-625)
* [boost asyncio 627](#boost-asyncio-627)
* [模型思维 630](#模型思维-630)
	* [为什么需要模型思维 631](#为什么需要模型思维-631)
	* [做一个多模型思考者 644](#做一个多模型思考者-644)
	* [模型的7大用途 650](#模型的7大用途-650)
		* [构建模型的三种方法: 655](#构建模型的三种方法-655)
	* [多模型思维 675](#多模型思维-675)
	* [对人类行为建模 676](#对人类行为建模-676)
	* [模型思维 678](#模型思维-678)
* [模式 680](#模式-680)
	* [简单工厂模式 683](#简单工厂模式-683)
	* [工厂方法 686](#工厂方法-686)
	* [策略模式 701](#策略模式-701)
	* [装饰器模式 711](#装饰器模式-711)
	* [代理模式 723](#代理模式-723)
	* [原型模式 740](#原型模式-740)
	* [模板方法模式 755](#模板方法模式-755)
	* [外观模式 798](#外观模式-798)
	* [建造者模式 818](#建造者模式-818)
	* [观察者模式 831](#观察者模式-831)
	* [抽象工厂模式 854](#抽象工厂模式-854)
	* [状态模式 893](#状态模式-893)
	* [适配器模式 908](#适配器模式-908)
	* [备忘录模式 920](#备忘录模式-920)
	* [组合模式 936](#组合模式-936)
	* [迭代器模式 962](#迭代器模式-962)
	* [单例模式 981](#单例模式-981)
	* [桥接模式 987](#桥接模式-987)
	* [命令模式 993](#命令模式-993)
	* [职责链模式 1007](#职责链模式-1007)
	* [中介模式 1011](#中介模式-1011)
	* [享元模式 1015](#享元模式-1015)
	* [解释器模式 1026](#解释器模式-1026)
	* [访问者模式 1029](#访问者模式-1029)
* [原则 1031](#原则-1031)
	* [单一职责原则 1032](#单一职责原则-1032)
	* [开放-封闭原则 1041](#开放-封闭原则-1041)
	* [依赖倒转原则 1057](#依赖倒转原则-1057)
	* [迪米特法则 1064](#迪米特法则-1064)
	* [合成/聚合复用原则: 1067](#合成聚合复用原则-1067)

<!-- vim-markdown-toc -->
##  范式 98
> 冒号课堂

1. 学会不如会学,会学不如会用,会用不如被用
2. 知识之上时思想,思想之上时精神.
3. 指的是计算机编程的基本风格或典范模式. 

4. 借用哲学的术语,如果说每个编程者都在创造虚拟世界,那么编程范式就是他们置身其中自
觉不自觉采用的世界观和方法论.

#### 命令范式 108
1. 其世界观是：程序是由若干行动指令组成的有序列表。

2. 方法论是：用变量来存储数据，用语句来执行指令。

3. 结构化编程: 在微观上，主张循规守矩；在宏观上，主张分而治之。

4. 过程式编程（procedural programming）:
	是指引入了过程（procedure）、函数（function）或子程序（subroutine/subprogram）
的命令式编程。但由于现代的命令式语言均具备此特征，故二者往往不加区分。

4. 结构化编程（structured programming或简称SP:
	它是在过程式编程的基础上发展起来的。其本质是一种编程原则，提倡代码应具有清晰
的逻辑结构，以保证程序易于读写、测试、维护和优化

#### 声明范式 123
1. 命令式编程是行动导向的，因而算法是显性而目标是隐性的；声明式编程是目标驱动的，
因而目标是显性而算法是隐性的。

2. 声明式编程重目标、轻过程，专注问题的分析和表达而不致陷入算法的迷宫，其代码也更加简
洁清晰、易于修改和维护。

3. 主要包括函数式编程和逻辑是编程.

4. 命令式编程是行动导向（Action-Oriented）的，因而算法是显性而目标是隐性的；
声明式编程是目标驱动（Goal-Driven）的，因而目标是显性而算法是隐性的

#### 对象范式 135
1. 核心思想可泛化为：
	以数据为中心组织逻辑，将系统视为相互作用的对象集合，并利用继承与多态来增强可维护性,
可扩展性和可重用性.

#### 并发范式 140
1. 并发式编程以进程为导向,以任务为中心将系统模块化.

2. 并发式编程以资源的共享与竞争为主线.

#### 泛型式 145
1. 算法串联数据,如脊贯肉;数据实化算法,如肉附脊.

2. 泛型算法是算法导向的,即以算法为起点和中心点,逐渐将其所涉及的概念内涵模糊化,外延扩大化,
将其所涉及的运算抽象化,一般化,从而扩展算法的适用范围.

3. 泛型编程基本思想: 将算法与其作用的数据结构分离,并将后者尽可能泛化,最大限度地实现算法重用

4. 这种泛化是基于模板的参数多态,相比OOP基于继承的子类性多态,普使性更强,而且效率更高.

5. STL三要素: 算法,容器,迭代器.
#### 元编程 156

#### 切面式 158

#### 事件驱动式 160
1. 事件是程序中令人关注的信息状态上的变化.

2. 在基于事件驱动的系统中,事件包括内建事件与用户自定义事件,
其中内建事件又分为底层事件和语义事件.

3. Callback指能作为参数传递的函数或代码,它允许底层模块调用高层模块,使调用者与被调用者从代码上
解耦.异步Callback在传入后并不立即被调用,使调用者与被调用者从时间上解耦.

4. 事件驱动式编程有3个步骤:
	- 实现事件处理器;
	- 注册事件处理器;
	- 实现事件循环.

5. 异步过程在主程序中以非堵塞的机制运行,即主程序不必等待该过程的返回就能继续下一步.
异步机制能减少随机因素造成的资源浪费,提高系统的性能和可伸缩性.

6. 独立是异步的前提,耗时是异步的理由.

7. 事件驱动最重要的两个特征是被动性与异步性.被动性来自控制反转,异步性来自会话切换.

8. 观察者模式又名发布订阅模式,既是事件驱动式的简化,也是事件驱动式的核心.
它省略了事件管理器部分.

9. MVC架构是观察者模式在架构设计上的一个应用.

10. 典型的事件驱动模型: 事件源, 事件管理器, 事件处理器	
	1. 事件处理器现在关注的事件源上注册,后者不定期地发表事件对象,经过事件管理器的转化,
	合并,排队,分派等集中处理后,事件处理器接收到事件并对其进行相应处理.

	2. 事件处理器可以随时注册或注销事件源,意味着二者之间建立了松耦合的多对多关系:
		- 一个事件源可以注册多个处理器
		- 一个处理器可以监听多个事件源.
	
		

#### 215 196

### 框架: 198
> 就是一组协同工作的类,它们为特定类型的软件构筑了一个可重用的设计.与库和工具包不同指出在于前者侧重软件设计重用而后两种侧重代码重用.

2. 一个足够复杂的应用软件开发,为确保快速有效,通常采取的方式时:	
	1. 在宏观管理上选取一些框架以控制整体的结构和流程
	2. 在微观上利用库和工具包来解决具体的细节问题

3. 框架的意义在于使设计者在特定领域的整体设计上不必重新发明轮子,库和工具包的意
义在于是开发者摆脱底层编码,专注特定问题和业务逻辑.

## 并发模式  208
> 面向模式的软件体系结构卷2: p5
### 服务访问和配置模式 210
> 设计模式把现有的非面向对象的API所提供的函数和数据,封装在更加简洁/健壮,可移植,可维护的内聚的面向对象类接口中.

#### 包装器模式 213
> 设计模式允许应用程序不必修改,重新编译,静态的重连接应用程序的情况下,在运行...
#### 组件配置器 215
#### 截取器 216
#### 扩展接口 217

### 事件处理模式 219
#### 反应器(Reactor)/分配器/通知器 220
0. 概述:
	- 事件驱动的应用可以多路分解并分配从一个或者多个客户机发送给应用的服务请求.
	- 反应器模式引入的机构"逆转"了应用总的控制流,这就是所说的好莱坞规则:
	不要打电话给我们,我们会给你打电话

1. 情景:
	同时接收多个服务请求,并且依次同步地处理它们的事件驱动应用程序.

2. 怎样应用反应器:
	由指定的组件"反应器",而不是应用程序负责同步等待指示事件,将它们多路分解给负责处理这
些事件的事件处理程序,然后在实践处理程序上分配合适的钩子方法.尤其是,由反应器分配对某
一**事件做出反应**的事件处理程序.

	这样开发人员只负责实现具体事件处理程序并重用反应器的多路分解和分配机制.

3. 缺陷:
	它不能同时支持大量的客户机或耗时长的客户机请求,因为它在事件多路分解层<font color=green>串行化</font>了
所有的事件处理程序的处理过程,主动器可以有效减小这种限制.

4. 细节
	- 对于应用程序提供的每个服务,引入一个**单独的事件处理程序**处理某一事件源的某一类型的事件.(!某个socket的某个事件的handler处理程序)
	-  在**反应器**中注册所有的事件处理程序,反应器使用一个**同步事件多路分解器**等待一个或多个事件源的指示事件.(!epoll/select事件循环)
	- 发生指示事件后,同步事件多路分解器通知反应器,后者同步分配与事件相关的事件处理程序,
		以便这些事件处理程序可以执行请求的服务.(!反应其不是epoll,是否是IOLoop)
	
5. 结构: 反应器模式有5个主要组成部分
	- 句柄: 用来识别像网络连接或打开文件这样的事件源,事件源产生指示事件并对它们进行排队
		- 指示事件可以来自外部像connect事件或READ事件,也可以来源与内部,如**超时事件**
		- 一旦一个事件源产生了一个指示事件,该指示事件就被送入相关句柄的队列中,句柄被标示为"就绪"
		- 这样,就可以在句柄中执行一个像accept或者read这样的操作而不会阻塞调用程序.

	- 同步事件多路分解器:一个函数,阻塞,select/epoll
	- 事件处理程序:定义一个或多个钩子方法组成的接口,钩子方法代表了**处理反应器就收并分配的指示事件时可用的服务集**
	- 具体事件处理程序: 实现应用程序所提供的特定服务的事件处理程序
		- 
	- 反应器: 定义了一个接口,允许应用程序注册或删除事件处理程序及其相应的句柄,并运行应用程序的事件循环.

	- 总结:
		1. 网络io中socket是句柄
		2. select/epoll是同步事件多路分解器
		3. get/post/connect/before/after/finally 等等固定的钩子,将某些固定的操作绑定到具体的事件处理程序
		4. 事件handler是具体事件处理程序
		5. IOLoop是reactor,注册,删除事件处理程序,运行epoll事件循环.

6. 控制流倒置:
	- 等待指示事件,多路分解这些事件给它们的具体事件处理程序,**向具体事件处理程序分配相应的钩子方法**,
		所有这些是**反应器**而不是应用程序的责任.

	- 特别是,具体事件处理程序并不调用反应器,而是由反应器分配一个具体处理程序,
		具体事件处理程序对某个指定的事件发生做出反应.这种"控制逆转"又称为"好莱坞原则"

7. 实现: 
	1. 反应器各个部分分两层
		1. 多路分解/分配基础设施层的组件:
			本层执行一个通用的,与应用程序无关的策略,用于将指示事件多路分解到事件处理程序,然后分配相应的事件处理程序钩子方法.

		2. 应用层组件
			本层定义具体事件处理程序,再具体事件处理程序的钩子方法中进行与应用有关的处理.

	2. 步骤
		1. 定义事件处理程序接口: 
		> 事件处理程序具体指定了由一个或几个钩子方法组成额接口,这些钩子方法代表了处理由反应
		>器接收并分配的指示事件时可用的服务集.

			1. 确定分配目标的类型:
				1. 事件处理程序对象
				> 将事件处理程序与句柄结合起来建立一个事件处理程序对象.

				2. 事件处理程序函数: 向反应器而不是对象注册函数指针

				3. 可以使用**适配器**模式同时支持对象和指针.

			2. 确定事件处理程序分配接口策略: 
				1. 单方法分配接口策略
				> 事件处理对象只包括一个事件处理方法.放映器用此方法分配事件,
				>将所发生事件的类型作为参数传递给方法.
				> 这样会导致事件处理方法会有大量switch匹配事件类型.

				2. 多方法分配借口策略:
				> 为处理每一类事件(如输入,超时)创建一个单独的钩子方法.
				> 这样更具扩展性,因为是由反应器实现而不是具体事件处理程序handle_event()方法
				来进行多路分解.

		2. 定义反应器接口: 
		> 应用程序使用放映器借口注册或者删除事件处理程序及相应的句柄,并调用应用程序的事件循环.
		> 通常使用单实例访问反应器借口,因为一个应用进程有一个反应器就够了.
		> 为了将应用程序和不同操作系统平台所具有的复杂,不可移植的多路分解和分配机制分开,
		反应器模式可以使用**桥(bridge)模式**.
			1. register_handler/remove_handler
			2. instance(单实例)
			3. `handle_events`:
				- 主入口点方法,调用同步事件多路分解器,等待事件发生,分解事件到它们对应的处理方法
				- 可以使用timeout参数限制等待指示事件的时间.
				- 一旦句柄集上发生一个或者多个事件,同步事件多路分解器函数就会返回,
				此时handler_event()方法做出"反应",将指示事件多路分解到与每个句柄相关的已就
				绪的事件处理程序,然后分配处理程序的钩子方法来处理事件.

		3. 实现反应器接口
			1. 开发反应器的实现层次:
				
			2. 选择一种同步事件多路分解器机制

			3. 实现一个多路分解表:
				- 格式: <句柄,事件处理程序,指示事件类型>的三元组

			4. 定义反应器的具体实现: 
				- 反应器接口中有一个指向反应器具体实现的指针,并将所有的方法调用传给该指针.
				- 反应器的私有部分中有一个事件处理程序多路分解表

		4. 确定应用程序所需要的反应器数量

		5. 实现具体事件处理程序
			1. 确定维护具体事件处理程序状态的策略
				一个事件处理程序需要维护与特定请求有关的状态信息.

			2. 实现用一个句柄配置各具体事件处理程序的策略:具体事件处理程序对句柄执行有关操作. 两个策略:
				1. 硬编码
				2. 类属方法

			3. 实现具体事件处理程序的功能.
				
8. dot 图
	1. uml
	```
	digraph uml {
		rankdir=BT;
		node[shape=record];

		reactor[label="{Reactor||+handle_events()\n+register_handler()\n+remove_handler()}"];
		event_handler[label="{Event_handler||+handle_event()\n+get_handler()}"];
		concrete_handlerA[label="{Concrete Event_handler A||+handle_event()\n+get_handler()}"];
		concrete_handlerB[label="{Concrete Event_handler A||+handle_event()\n+get_handler()}"];
		demultiplexer[label="{Synchronous event demultiplexer||+select()}"];

		reactor->event_handler[label="dispatches"];
		concrete_handlerA->event_handler[arrowhead=onormal];
		concrete_handlerB->event_handler[arrowhead=onormal];
		reactor->demultiplexer[label="uses"];
	}
	```

	2. 结构图: ![reactor 结构图](/home/wang/F/note/img/reactor_结构图.jpg)

##### Reactor模式结构 364
1. Reactor包含如下角色：

	- Handle 句柄；用来标识socket连接或是打开文件；

	- Synchronous Event Demultiplexer：同步事件多路分解器：由操作系统内核实现的一个函数；
	用于阻塞等待发生在句柄集合上的一个或多个事件；（如select/epoll；）

	- Event Handler：事件处理接口

	- Concrete Event HandlerA：实现应用程序所提供的特定事件处理逻辑；

	- Reactor：反应器，定义一个接口，实现以下功能：
	
		1. 供应用程序注册和删除关注的事件句柄；
		2. 运行事件循环；
		3. 有就绪事件到来时，分发事件到之前注册的回调函数上处理；

2. “反应”器名字中”反应“的由来：“反应”即“倒置”，“控制逆转”

	具体事件处理程序不调用反应器，而是由反应器分配一个具体事件处理程序，
具体事件处理程序对某个指定的事件发生做出反应；这种控制逆转又称为“好莱坞法则”
（不要调用我，让我来调用你）

3. 业务流程及时序图
	1. 应用启动，将关注的事件handle注册到Reactor中；
	2. 调用Reactor，进入无限事件循环，等待注册的事件到来；
	3. 事件到来，select返回，Reactor将事件分发到之前注册的回调函数中处理；

#### 主动器(Proactor) 393
0. 概述
	- 在主动器模式中,客户机和完成处理程序多代表的应用组件称为**主动性实体**.
	- 和被动地等待<font color=green>指示事件的到达并作出响应的反应器模式不同</font>, 
	<font color=red>主动器模式中的客户机和完成处理程序通过在一个异步操作处理器中主动地初始化
	一个或者多个异步操作请求,引起应用程序内部的控制流和数据.</font>
	
	- 异步操作完成后,异步操作处理器和指定的主动器组件协作,将产生的完成事件多路分解给相关的完成处理程序,
	并分配这些处理程序的钩子方法.

1. 它由资源、请求、请求完成处理器、资源管理器、调度器和异步处理器构成。

2. 资源同reactor。

3. 请求是对资源的实际操作，如read,write,accept,每个请求对应于一个异步处理器,
    请求不会立刻执行，而是先缓存在请求队列中，由调度器统一处理。
    
4. 请求完成处理器是请求完成后的回调函数。

5. 资源管理器是资源、请求和请求完成处理器的容器。

6. 调度器也是一个过程，从资源管理器中取出请求，调用相应的异步处理器，在异步处理完毕后调用请求完成处理器。

7. 异步处理器为操作系统提供的异步操作函数，如iocp，或者用线程去模拟。它也是
基于事件循环，能以单线程并发处理多路socket的事件。其输入为资源和请求，其输出为请求完成通知。
libuv就是典型的实现。

8. 其优点为：

    - 单线程处理多路socket,规范了一套处理流程。
    - 在操作系统支持真异步处理器时，有并发性。
    - 使用者所需知识度低，不需要了解实际的事件处理。

9. 其缺点为：
    - 假设为单线程环境，接口都不是线程安全的，在多线程项目中用起来不是很平滑。
    (与模式无关，libuv等实现的缺陷)

##### Proactor模式结构 430
1. Proactor主动器模式包含如下角色
	- Handle 句柄；用来标识socket连接或是打开文件；
	- Asynchronous Operation Processor：异步操作处理器；负责执行异步操作，
	一般由操作系统内核实现；

	- Asynchronous Operation：异步操作

	- Completion Event Queue：完成事件队列；异步操作完成的结果放到队列中等待后续使用

	- Proactor：主动器；为应用程序进程提供事件循环；从完成事件队列中取出异步操作的结果，
	分发调用相应的后续处理逻辑；

	- Completion Handler：完成事件接口；一般是由回调函数组成的接口；

	- Concrete Completion Handler：完成事件处理逻辑；实现接口定义特定的应用处理逻辑；

##### 业务流程及时序图 447
1. 应用程序启动，调用异步操作处理器提供的异步操作接口函数，
调用之后应用程序和异步操作处理就独立运行；应用程序可以调用新的异步操作，
而其它操作可以并发进行；

2. 应用程序启动Proactor主动器，进行无限的事件循环，等待完成事件到来；

3. 异步操作处理器执行异步操作，完成后将结果放入到完成事件队列；

4. 主动器从完成事件队列中取出结果，分发到相应的完成事件回调函数处理逻辑中；

#### reactor和proactor的区别 458
1. reactor侧重的是告诉使用者a资源发生了b事件，怎么处理你看着办吧。

2. proactor侧重的是告诉使用者，主人你对a资源进行的b请求完成了

3. 以做软件项目为例子，在reactor时，它就是老板，你就是程序员，某天它对你下达一个开发x软件的任务，
然后你就去调研需求，设计编码;

4. 在proactor时，它就是程序员，你就是老板，某天你对它下达一个开发x软件的任务，它开发完毕后告诉你，老板，x软件开发完毕。

5. 从实现细节来看，reactor就是缺少异步处理器，如果内部为每种事件提供一个异步处理器，
将输入的事件侦听变为提交请求，那么reactor就变为proactor了。

##### 对比两者的区别 471
1. 主动和被动: 以主动写为例：
	- Reactor将handle放到select()，等待可写就绪，然后调用write()写入数据；写完处理后续逻辑；

	- Proactor调用aoi_write后立刻返回，由内核负责写操作，写完后调用相应的回调函数处理
	后续逻辑；

2. 可以看出，Reactor被动的等待指示事件的到来并做出反应；它有一个等待的过程，做什么都要先
放入到监听事件集合中等待handler可用时再进行操作；

3. Proactor直接调用异步读写操作，调用完后立刻返回；

4. 实现
	- Reactor实现了一个被动的事件分离和分发模型，服务等待请求事件的到来，
	再通过不受间断的同步处理事件，从而做出反应；

	- Proactor实现了一个主动的事件分离和分发模型；这种设计允许多个任务并发的执行，
	从而提高吞吐量；并可执行耗时长的任务（各个任务间互不影响）

5. 优点
	1. Reactor实现相对简单，对于耗时短的处理场景处理高效；

	2. 操作系统可以在多个事件源上等待，并且避免了多线程编程相关的性能开销和编程复杂性；

	3. 事件的串行化对应用是透明的，可以顺序的同步执行而不需要加锁；

	4. 事务分离：将与应用无关的多路分解和分配机制和与应用相关的回调函数分离开来，

	5. Proactor性能更高，能够处理耗时长的并发场景；

6. 缺点
	1. Reactor处理耗时长的操作会造成事件分发的阻塞，影响到后续事件的处理；

	2. Proactor实现逻辑复杂；依赖操作系统对异步的支持，目前实现了纯异步操作的操作系统少，
	实现优秀的如windows IOCP，但由于其windows系统用于服务器的局限性，目前应用范围较小；
	而Unix/Linux系统对纯异步的支持有限，应用事件驱动的主流还是通过select/epoll来实现；

7. 适用场景
	1. Reactor：同时接收多个服务请求，并且依次同步的处理它们的事件驱动程序；
	2. Proactor：异步接收和同时处理多个服务请求的事件驱动程序；

8. 作者: Posted by: 大CC | 28APR,2015

#### 更好的proactor 514
1. 我希望所有的请求操作都是线程安全的，请求完成通知不是通过回调函数由内部发起，而是转化为一条消息，
由外部主动获取。这样能更好的整合到项目中。它的接口是这样的：

```
#ifndef SSOCKET_H 519
#define SSOCKET_H 520

#define    SS_MSG_ACCEPT //客户端连接消息 522
#define SS_MSG_OPEN //连接服务器成功消息 523
#define SS_MSG_DATA //数据消息 524
#define SS_MSG_CLOSE //对方断开消息 525
#define SS_MSG_ERROR //错误消息，发生时，socket已经断开 526
#define SS_MSG_FILE //文件发送成功消息 527

struct ss_message{
    int type;
    int id; 
    void *ud;
    int size; //在type = SS_MSG_ACCEPT时，size为客户端的id;在SS_MSG_DATA时，size为data的大小

    //在SS_MSG_DATA时,data为数据;在SS_MSG_ACCEPT时,data为ip地址字符串;在SS_MSG_ERROR时，data为错误消息;在SS_MSG_FILE时,data为文件路径; 
    //SS_MSG_DATA,SS_MSG_ACCEPT,SS_MSG_FILE,data需要外部释放
    char *data;
};

int ss_init();
//获取一条网络消息，return >0有消息
int ss_poll(struct ss_message *m);

//以下接口都是线程安全的
int ss_listen(const char *addr,int port,int bks,void *ud);
int ss_connect(const char *addr,int port,void *ud);
void ss_close(int id);
void ss_bind(int id,void *ud);
void ss_start(int id);
void ss_send(int id,char *data,int n); 
int ss_send_file(int id,const char *path);

#endif 449 553
```

2. socket句柄不暴露给外部，而是暴露内部的id，内部的id可以映射到实际的socket句柄，
这样做更安全，通过id，内部可以检测该socket是否有效。

3. 由外部循环调用ss_poll来获取请求完成通知。

4. ss_bind可以为id绑定一个用户数据，该id的请求完成消息里会带上该用户数据。

5. ss_start用于开始accept,read这些持续性请求，而不需要一次一次发起。

6. ss_send将要发送的数据送入id的发送队列，内部会保证有序的发送出去。

7. ss_send_file:因为内部有发送队列要缓存数据，所以并不适合文件这种大数据量的需求，
该接口会使用sendfile要处理文件发送，从而避免缓存文件数据。

8. ss_close在关闭时会保证发送队列已经全部发送，否则不会关闭socket.

9. 具体的实现放在github上。

10. 在服务器程序上使用
	1. 多线程的服务器程序通常是这样的结构：

	2. 网关用于提供入口点，会收到所有的socket消息，在accept时会创建一个agent,
	此后该socket的消息就会发送到该agent。agent负责解码网络数据，分解出一个个协议包，
	然后调用协议包处理器处理该包，再将处理的结果编码为协议包发送到该socket。
	因为proactor是单线程的，为了并发，一般有两种方式：

		1. agent解码出协议包后，用线程池来执行包处理逻辑。
		2. agent缓存住网络数据，由线程池来调度agent,以一定的频率来进行解码、包处理。

	3. 网关和agent的作用是隔离网络层，进行网络协议和内部协议的转换。agent除了转换协议，
	还可以保存中间状态，在有状态的协议中，agent和socket是一一配对的。在无状态的协议中，
	所有的socket可以共用一个agent。

#### 异步完成标记 589
> (Asynchronous Completion Token, ACT) 

#### 接收器-连接器 592
> (Acceptor-Connector) 

### 同步模式 595
#### 定界加锁(Scoped Locking) 596
#### 策略花加锁 597
> (strategized Locking)
#### 线程安全接口 599
#### 双检查加锁优化 600

### 并发模式 602
#### 主动对象 603
#### 监视对象 604
#### 半同步/半异步 605
#### 领导者/追随者 606
#### 线程特定的存储器 607

## python asyncio 609
### 高级接口 610
> asyncio/api.md
#### Tasks 612
#### 队列集 613
#### 子进程集 614

#### 流 616
##### protocol/协议 617
##### 只读协议 618
##### 只写协议 619
##### 读写协议 620

#### 同步 622
#### 异常 623

## c++ 原生async 625

## boost asyncio 627


## 模型思维 630
### 为什么需要模型思维 631
> 多模型思维要求掌握多个模型,但是我们不需要洞得非常多的模型,只需要知道每个模型都可以有多应用场景.
> 要成为一个多模型思考者,需要的不仅仅是数学能力,更需要的是创造力.

1. 要想成为一个有智慧的人,你必须拥有多个模型,而且,你必须将你的经验,无论是间接的,还是直接的,都放到构成这些模型的网格上.

2. 所有这些模型都有一个共同形式: 它们都假设一些实体,通常是人或组织,并描述他们是如何相互作用的.

3. 所有的模型都有三个共同特征:
	1. 它们都要简化,剥离不必要的细节,抽象掉若干现实世界的因素,或者需要从头重新创造
	2. 它们都是形式化的,要给出精确的定义.
	3. 所有的模型都是错误的.

### 做一个多模型思考者 644
1. 多模型思维的成功取决于一定程度的可分离性.
	1. 面对一个复杂的系统,我们可以部分地将主要的因果关系分离出来,然后探究它们是如何交织在一起的.

2. 我们应该将逻辑一致性置于比直觉更优先的位置.

### 模型的7大用途 650
> 了解现实就意味着构建转换系统,这些转换系统或多或少都必须与现实相对应

1. 7大用途: 推理,解释,设计,沟通,行动,预测,探索.

#### 构建模型的三种方法: 655
1. 具身法: 用这种方法构建的模型包括重要部分,同时对于不必要的维度和属性,
	要么剥离,要么将它们整合在一起考虑.
	
	1. 生态沼泽/立法机构和交通系统的模型

2. 类比法: 可以对现实进行类比与抽象
	1. 犯罪行为传播类比为传染病传播
	2. 政治立场的选择类比为在一个左右连续线段上的选择.
	3. 球形牛是类比方法一个最直观的例子: 估计牛的牛皮面积

3. 另类现实法: 有意不去表征,不去刻画现实.
	1. 比如如果能够通过空气安全有效的传输能量将会怎样?
	2. 这类模型允许我们进行现实世界中不可能的(思想)实验
	3. 

4. 具身法更强调现实主义,类比则致力于刻画过程,系统或现象的本质.

5. 没有什么比现实更不真实了....细节令人困惑,只有通过选择,通过消除,通过强调,我们才能获得事物的真正意义.
	
### 多模型思维 675
### 对人类行为建模 676

### 模型思维 678

## 模式 680
> 之所以要加上抽象类,是因为在强类型语言中,是通过指向父类的指针指向派生类来实现多态的.

### 简单工厂模式 683
1. 通过一个字符串来生成一个类.然后使用者是一个指向父类的指针.实现多态.

### 工厂方法 686
> 定义一个用于创建对象的接口,让子类决定实例化哪一个类.工厂方法使一个类的实例化延迟到其子类.

1. 每个需要实例化类都有一个对应的工厂类/方法. 使用时先实例化类工厂对象,然后使用类工厂对象创建需要的对象.

2. 需要客户自己决定初始化哪一个工厂类.

3. 声明了很多个工厂类/工厂方法.

4. 工厂方法克服了简单工厂违背开放-封闭原则的缺点,又保持了封装对象创建过程的优点.

5. 工厂方法模式是简单工厂模式的进一步抽象和推广.由于使用了多态性,
工厂方法模式保持了简单工厂模式的优点,而又克服它的缺点.
但缺点是每加一个产品,就需要添加一个产品工厂类,增加了额外的开发量.

### 策略模式 701
> 它定义了算法家族,分别封装起来,让它们之间可以互相替换,此模式让算法的变化,不会影响到使用算法的客户

1. 上下文: 上下文中包含一个抽象算法类实例,通过改变这个属性,上下文可以改变具体的策略类.

2. 结构图:
	1. Context: 上下文,用一个ConcreteStrategy来配置,维护一个对strategy的对象的引用
	2. Strategy: 策略类,定义所有支持的算法的公共接口
	3. ConcreteStrategy: 具体策略类,封装了具体的算法行为,继承于Strategy

### 装饰器模式 711
> 动态地给一个对象添加一些额外的职责,就增加功能来说,装饰器模式比生成器模式更为灵活.

1. component是定义一个对象接口,可以给这些对象动态的添加职责.
2. concreteComponent是定义一个具体的对象,也可以对这个对象添加一些职责.
3. Decrator,装饰器抽象类,继承了Component,从外类来扩展Component类的功能.
但对于Component来说,是无需知道Decorator的存在的.

4. 总结:
	Decorator包含一个component对象,通过调用自己的同名方法时,
调用component对象的方法,然后在添加一些步骤.

### 代理模式 723
> 为其他对象提供一种代理以控制对这个对象的访问.

1. 代理模式的subject类和proxy类共用同样的接口.这样就在任何使用RealSubject的地方都可以使用proxy

2. proxy包含一个subject对象作为属性.

2. 使用场景:
	1. 远程代理,也就是为一个对象在不同的地址空间提供局部代表,
	这样可以隐藏一个对象存在于不同地址空间的事实.

	2. 虚拟代理, 是根据需要创建开销很大的对象,通过它来存放实例化需要很长时间的真实对象.

	3. 安全代理, 用来控制真实对象访问时的权限.

	4. 智能指针,是指当调用真实的对象时,代理处理另外一些事.

### 原型模式 740
> 用原型实例指向创建对象的种类,并且通过拷贝这些原型创建新的对象.

1. 原型模型其实就是从一个对象在创建另外一个可定制的对象,而且不需要知道任何创建细节.

2. 结构图:
	1. client: 指向一个prototype
	2. portotype: 原型类,声明一个clone自身的接口
	3. concretePrototype: 具体原型类,实现一个克隆自身的操作.

3. 一般在初始化的信息不发生变化的情况下,克隆是最好的办法.这既隐藏了对象创建的细节,
又对性能是大大的提高

4. 深拷贝/浅拷贝

### 模板方法模式 755
> 定义一个操作中的算法的骨架,而将一些步骤延迟到子类中.模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤.

1. 结构图:
	1. AbstractClass: 实现了一个模板方法,定义了算法的骨架,具体子类将重定义PrimitiveOperation
	以实现一个算法的步骤.
		1. TemplateMethod()
		2. PrimitiveOperation1()
		3. PrimitiveOperation2()

	
	2. ConcerteClass: 实现PrimitiveOperation以完成算法中与特定子类相关的步骤.
		1. PrimitiveOperation1()
		2. PrimitiveOperation2()

	3. ConcerteClass 继承自AbstractClass

2. AbstractClass
```
abstract class AbstractClass
{
	public abstract void PrimitiveOperation1();
	public abstract void PrimitiveOperation2();
	//一些抽象行为,放到子类去实现.

	public void TemplateMethod(){
		PrimitiveOperation1();
		PrimitiveOperation2();
		Console.WriteLine("");

		//模板方法,给出了逻辑的骨架,而逻辑的组成是一
		//些相应的抽象操作,它们都延迟到子类实现.
	}
}
```

3. concreteClass:
	实现了父类定义的一个或多个抽象方法,每一个AbstractClass都可以有任意多个concreteClass
与之对应,而每一个ConcreteClass都可以给出这些抽象方法(也就是顶级逻辑的组成步骤)的不同实现,
从而使得顶级逻辑的实现各不相同.

4. 模板方法模式是通过把不变行为搬移到超累,去除子类中的重复代码来体现它的优势.

### 外观模式 798
> 为子系统中的一组接口提供一个一致的界面,此模式定义了一个高层接口,这个接口使得这一子系统更容易使用.
> 类似于股票与基金

1. 结构图
	1. client
	2. Facade: 外观类,知道哪些子系统负责处理请求,将客户的请求代理给适当的子系统对象
		- MethodA()
		- MethodB()

	3. SubSystemOne, SubSystemTwo....: 子系统类集合,实现子系统的功能,处理Facade对象的指派的人物.
		注意子类中没有Facade的任何信息,既没有对Facade对象的引用.
		- MethodOne() ...

2. 使用场景
	1. 在设计初期阶段,应该要有意识地将不同的两个层分离
	2. 开发阶段,子系统往往因为不断的重构烟花而变得越来越复杂,增加外观模式可以提供一个简单的接口,减少它们之间的依赖.
	3. 维护一个遗留的大型系统时,可能这个系统已经非常难以维护和扩展,可以为新系统开发一个外观模式类,
	来提供设计粗超或高度复杂的遗留代码的比较清晰的简单接口.

### 建造者模式 818
> 将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示.

1. 结构图
	1. Builder: 为创建一个Product对象的各个部件指定的抽象接口
		- buildPart()

	2. ConcreteBuilder: 具体建造类,实现Builder接口,构造和装配各个部件

	3. Director: 指挥类,是构建一个使用Builder接口的对象,按照顺序调用builder中指定各个方法.

	4. Product: 具体产品.

### 观察者模式 831
> 定义了一宗一对多的依赖关系,让多个观察者对象同时监听某一个主题对象.这个主体对象在状态发生变
化时,会通知所有观察者对象,使它们能够自动更新自己.

1. 构造图:
	1. Subject类,它把所有对观察者对象的引用保存在一个聚集里,每个主题都可以有任何数量
	的观察者,抽象主题提供一个接口,可以增加和删除观察者对象.

	2. Observer类,抽象观察者,为所有的具体观察者定义一个接口,在得到主体的通知时更新自己.

	3. ConcreteObserber: 具体观察者,实现抽象观察者所要求的更新接口,以便使本身的状态
	与主题的状态相协调.

	4. conreteSubject: 具体主题,将有关状态存入具体观察者对象,在具体主题的内部状态改,
	变时,给所有登记过的观察者发出通知.

2. 应用场景
	1. 当一个对象的改变需要同时改变其他对象的时候,而且它不知道具体有多少对象有
	待改变时,应该考虑观察者模式.

3. 如果观察者的通知方法名称不同的话,可以使用事件委托(一个包装函数的类,统一调度),来
委托执行具体方法.

### 抽象工厂模式 854
> 提供一个创建一系列相关或相互依赖对象的接口,而无需指定他们具体的类.
0. 记忆点:
	程序换数据库,多个表要有不同数据库的实现.

1. 结构图:
	1. AbstractFactory: 抽象工接口,它里面应该包含所有的产品创建的抽象方法.
		- CreateProductA()
		- CreateProductB()

	2. ConcreteFactory1: 具体的工厂类,创建具有特定实现的产品对象

	3. AbstractProductA: 抽象产品,它们都有可能有两种不同的实现

	5. AbstractProductB: 抽象产品,它们都有可能有两种不同的实现

	4. ProductA1, ProductA2...: 对两个抽象产品的具体分类的实现

	6. ProductB1, ProductB2...: 对两个抽象产品的具体分类的实现

2. 解释:
	- AbstractProductA和AbstractProductB是两个抽象产品,它们都有可能有多个不同的实现.
	- ProductA1,ProductA2和ProductB1,ProductB2就是对两个抽象产品具体分类的实现.

	- IFactory是一个抽象工厂接口,它里面应该包含所有产品创建的抽象方法
	- ConcreteFactory1和ConcreteFactory2就是具体的工厂.

	- 通常是在运行时刻在创建一个ConcreteFactory类的实例,这个具体工厂在创建具有特定实现的产品对象.
	也就是说,为创建不同的产品对象,客户端应使用不同的具体工厂.

3. 只有一个User类和User类的时候,是只需要工厂方法模式,但是当换数据库类似的任务时,有多个表,
而Sql server和Access又是两大不同的分类,所以解决这种涉及多个产品系列的问题时,
有一个专门的工厂模式叫做**抽象工厂模式**.

4. 优缺点:
	1. 便于交换产品系列
	2. 让具体的创建过程与客户端分离,客户端是通过它们的抽象接口操纵实例,
	产品的具体类名也被具体工厂实现分离,不会出现在客户代码中.

### 状态模式 893
> 当一个对象的内在状体改变时允许改变其行为,这个对象看起来像是改变了其类.

1. 状态模式主要解决的是**当控制一个对象状态转换**的条件表达式过于复杂时的情况.
把状态的**判断逻辑转移到表示不同状态的一系列的类**当中,可以把复杂的判断逻辑简化.

2. 如果这个状态判断很简单,那就没有必要用"状态模式".

3. 结构图:
	1. State: 抽象状态类,定义一个接口以封装与Context的一个特定装体相关的行为.

	2. ConcreteStateA: 具体状态类,每一个子类实现一个与Context的一个状态相关的行为.

	3. Context: 维护一个concreState子类的实例,这个实例定义当前的状态. 

### 适配器模式 908
> 将一个类的接口转换成客户希望的另外一个接口.Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作.

1. 场景:	
	1. 系统的数据和行为都正确,但接口不符时,我们应该考虑用适配器,目的是使控制范围之外的一个原有对象与某个接口匹配.
	2. 适配器模式主要应用于希望福永一些现存的类,但接口又与复用环境要求不一致的情况.

2. 两种适配器模式
	1. 类是配器: 通过多重继承对一个接口与另一个接口进行匹配

	2. 对象适配器:

### 备忘录模式 920
> 在不破坏封装性的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态.
> 这样以后就可将该对象恢复到原先保存的状态.

1. 结构图:
	1. Originator: 负责创建一个备忘录Memento,用以记录当前时刻它的内部状态,并可使用备忘录恢复内部状态
		- + Statte
		- + SetMemento(in m:Memento)
		- + CreateMemento()

	2. Memento: 负责存储Originator对象的内部状态,并可防止Orinator以外的其他对象访问备忘录Memento
		- + State

	3. Caretaker: 负责备保存好备忘录 Memento,不能对备忘录的内容进行操作或检查.
		- - Memento

### 组合模式 936
> 将对象组合成树形结构以表示"部分-整体"的层次结构.组合模式使得用户对单个对象和组合对象的使用具有一致性.

1. 场景:
	1. 整体和部分可以被一致对待的问题.

	2. 需求中是体现部分与整体层次的结构时,以及希望用户可以忽略组合对象与单个对象的不同,
	统一的使用组合结构中的所有对象时,就应该考虑使用组合模式了.

2. 结构图
	1. Component: 组合对象声明接口,在适当情况下,实现所有类共有接口的默认行为.生命一个接口用于访问和管理Component的子部件.
		1. + Add(in c: Component)
		2. + Remove(in c: Component)
		3. + Dispaly(in depth: int)

	2. Leaf: 在组合中表示叶节点对象,叶节点没有子结点.
		1. + Display(in depth: int)

	3. Composite: 定义有枝节点行为,用来存储子部件,在Component接口中实现与子部件有关的操作,比如增加Add和删除Remove.
		1. + Add()
		2. + Remove()
		3. + Display()

	4. 2,3 继承自1. Composite聚合指向Component


### 迭代器模式 962
> 迭代器模式,提供一种方法顺序访问一个聚合对象中的各个元素,而又不暴露该对象的内部表示.

1. 场景:
	1. 一个聚集对象,而且不管这些对象是什么都需要遍历的时候,需要考虑迭代器模式.
	2. 需要对聚集有多种方式遍历
	3. 为遍历不同的聚集结构提供如开始,下一个,是否结束,当前哪一项等统一的接口.

2. 结构图:
	1. Aggregate: 抽象聚集类
	2. ConcreteAggregate: 具体抽象类,继承Aggregate
	3. Iterator: 迭代抽象类,用于定义得到开始对象,得到下一个对象...统一接口
		- + First()
		- + Next()
		- + IsDone()
		- + CurrentItem()

	4. ConcreteIterator: 具体迭代类,继承Ietrator,实现...
	
### 单例模式 981
> 保证一个类仅有一个实例,并提供一个访问它的全局访问点.

1. 所有类都有构造方法,不编码则系统默认生成空的构造方法,
	若有显示定义的构造方法,默认的构造方法就会失效.
	
### 桥接模式 987
> 将抽象部分与它的实现部分分离,使它们都可以独立的变化.

1. 比如手机:按照品牌分类,按照软件来分类.手机是一个独立的对象,它包含的品牌,软件可以独立变化.
2. 我的理解是一个类中包含不同的抽象类属性.

### 命令模式 993
> 将一个请求封装为一个对象,从而是你可以用不同的请求对客户进行参数化;
> 对请求排队或记录请求日志,以及支持可撤销的操作.

1. 结构图:
	1. Command: 用来声明执行操作的接口:
		- +Excute()

	2. Invoker: 要去该命令执行这个请求

	3. Receiver: 知道如何实施与执行一个请求相关的操作,任何类都可能作为一个接受者

	4. ConcreteCommand: 将一个接受者对象绑定于一个动作,调用接受者相应的操作,以实现Execute

### 职责链模式 1007
> 使多个对象都有机会处理请求,从而避免请求的发送者和接受者之间的耦合关系.将这个对象连成一条链,
> 并沿着这条链传递该请求,直到有一个对象处理它为止.

### 中介模式 1011
> 用一个中介对象来封装一系列的对象交互,中介者使各对象不需要显式地相互引用,从而使其耦合松散,
> 而且可以独立地改变它们之间的交互

### 享元模式 1015
> 运用共享技术有效地支持大量细粒度的对象.

1. 在享元对象内部并且不会随环境改变而改变的共享部分,可以称为是享元对象的内部状态,而随环境改变而改变,
不可以共享的状态就是外部状态.

2. 享元模式可以避免大量非常相似的开销.

3. 享元模式执行时所需的状态时有内部的也可能有外部的,内部状态存储于具体享元对象中,而外部对象则应该考虑
由客户端对象存储或计算

### 解释器模式 1026
> 给定一个语言,定义它的文法的一种表示,并定义一个解释器,这个解释器使用该表示来解释语言中的句子.

### 访问者模式 1029

## 原则 1031
### 单一职责原则 1032
> 单一职责原则(SRP),就一个类而言,应该仅有一个引起它变化的原因.

1. 如果一个类承担过多的职责,就等于把这些职责耦合在一起,一个职责的变化可能会削弱或者抑制这
	个类完成其他职责的能力. 这种耦合会导致脆弱的设计,当发生变化时,设计会遭受到意想不到的破坏.

2. 软件设计真正要做的许多内容,就是发现职责并把那些职责相互分离:
	如果您呢个想到多于一个的动机去改变一个类,那么这个类就具有多于一个职责,就应该考虑类的职责分离.

### 开放-封闭原则 1041
> 是说软件实体(类,模块,函数等等)应该可以扩展,但是不可以修改.

1. 无论模块是多么的"封闭",都会存在一些无法对之封闭的变化.既然不可能完全封闭,
设计人员必须对于他设计的模块应该对哪种变化封闭做出选择.他必须先猜测出最有
可能发生的变化种类,然后构造抽象来隔离那些变化.

2. 在我们最初编写代码使,假设变化不会发生,当变化发生时,我们就创建抽象来隔离以后发生的同类变化.

3. 面对需求,对程序的改动是通过增加新代码进行的,而不是更改现有的代码.这就是"开放-封闭原则的精神所在."

4. 我们希望的是在开发工作展开不就就知道可能发生的变化,查明可能发生的变化所等待的时间越长,要创建的抽象就越困难.

5. 开放-封闭原则是面向对象设计的核心所在.遵循这个原则可以带来面向对象技术所声称的巨大好处,也就是可维护,可扩展,可复用,灵活性好.
	开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象,然而,对于应用程序的每个部分都可以的进行抽象同样不是一个好的主意.拒绝不成熟的抽象和抽象本身一样重要.

### 依赖倒转原则 1057
> 抽象不应该依赖细节,细节应该依赖与抽象.就是针对接口编程,不要对实现编程.

1. 里氏代换原则: 子类型必须能够替换掉它们的父类型.

2. 由于子类型的可替换性才使得使用父类类型的模块在无序修改的情况下就可以扩展.

### 迪米特法则 1064
> 如果两个类不必彼此直接通信,那么这两个类就不应当发生直接的相互作用.如果一个类需要调用另一个类的某一个方法的话,可以通过第三者转发这个调用.

### 合成/聚合复用原则: 1067
> 尽量使用合成/聚合,尽量不要使用类继承.

