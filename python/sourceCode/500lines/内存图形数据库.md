 

Dagoba：内存中的图形数据库

丹恩·利弗

丹恩（Dann）与他两岁的孩子喜欢建筑，例如编程语言，数据库，分布式系统，聪明友善的社区以及小马城
堡。

序幕

    “当我们尝试自行挑选出任何东西时，我们发现它被一千根看不见的绳索牢牢地绑在了宇宙中的所有东
    西上。” 约翰·缪尔

    “到世界的尽头去不穿越自己的东西，上帝，太阳，莎士比亚，一个商业旅行者，在现实中穿越自己变
    成了那个自我。” -詹姆斯·乔伊斯

很久以前，当世界还很年轻时，所有数据都在一个文件中愉快地传输。如果您想让数据越过围栏，只需将围
栏设置在其路径上，然后每个数据依次跳过。打卡，打卡。生活轻松，编程轻而易举。

然后是随机访问革命，数据在山坡上自由掠过。聚集数据已成为一个严重的问题：如果您可以随时访问任何
数据，那么您如何知道接下来要选择哪个呢？通过在第^1项之间形成链接来发展数据收集技术，通过链接的
组合将单元组编组为地层。质疑数据意味着挑选一只绵羊，并拉扯与之相关的一切。

后来的程序员脱离了这一传统，对如何聚合数据强加了一套规则^2。与其将完全不同的数据直接捆绑在一起
，不如将它们按内容聚类，将数据分解成一口大小的片段，用笔收集起来，并用名字标签打圈。以声明方式
提出问题，导致将部分分解的数据（关系学家称为“正常”的状态）累积到返回给程序员的franken集合中。

在许多记录的历史中，这种关系模型至高无上。在两次主要的语言战争和无数次小规模冲突中，它的统治地
位受到了挑战。它以低效率，笨拙和缺乏可伸缩性的代价提供了模型中您可能需要的一切。对于那是程序员
愿意付出的代价的时代。然后互联网发生了。

分布式革命再次改变了一切。数据摆脱了空间限制，并在机器之间漫游。使用CAP的理论家破坏了关系垄断
，为新的羊群技术打开了大门，其中一些最早追溯到驯化随机访问数据的尝试。我们将研究其中之一，一种
称为图形数据库的样式。

拿一个

在本章中，我们将建立一个图形数据库^3。在构建它时，我们将探索问题空间，为我们的设计决策生成多个
解决方案，比较这些解决方案以了解它们之间的折衷，最后为我们的系统选择正确的解决方案。代码紧凑性
的优先级高于平常，但是该过程自远古以来就反映了软件专业人员所使用的过程。本章的目的是教这个过程
。并建立图形数据库^4。

使用图形数据库将使我们能够以优雅的方式解决一些有趣的问题。图形是一种非常自然的数据结构，用于探
索事物之间的联系。从这个意义上讲，图是一组顶点和一组边。换句话说，它是由线连接的一堆点。还有一
个数据库？“数据库”就像是数据堡垒。您将数据放入其中并从中取出数据。

那么，图数据库可以解决哪些问题？好吧，假设您喜欢跟踪祖先的树木：父母，祖父母，表亲两次被移除，
就是这种情况。您想开发一个系统，使您可以进行自然而优雅的查询，例如“谁被除去后，Thor的第二个堂
兄弟是谁？” 或“ Freyja与女武神有什么联系？”

此数据结构的合理模式是拥有一个实体表和一个关系表。查询Thor的父母可能看起来像

SELECT e.* FROM entities as e, relationships as r
WHERE r.out = "Thor" AND r.type = "parent" AND r.in = e.id

但是，我们如何将其扩展到祖父母呢？我们需要执行子查询，或使用其他类型的供应商特定的SQL扩展。到
移除后的第二代表亲时，我们将拥有大量 SQL。

我们想写什么？既简洁又灵活的东西；一种自然地为我们的查询建模并扩展到其他类似查询的东西。
second_cousins('Thor')简洁明了，但这并没有给我们带来任何灵活性。上面的SQL很灵活，但是缺乏简洁
性。

诸如此类的东西可以Thor.parents.parents.parents.children.children.children达到相当好的平衡。这
些原语使我们可以灵活地提出许多类似的问题，但是查询是简洁自然的。这个特殊的表述给我们带来了太多
的结果，因为它包含了堂兄弟姐妹和兄弟姐妹，但我们在这里使用格式塔。

能为我们提供这种界面的最简单的方法是什么？我们可以制作一个顶点列表和一个边列表，就像关系模式一
样，然后构建一些辅助函数。它可能看起来像这样：

V = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 ]
E = [ [1,2], [1,3],  [2,4],  [2,5],  [3,6],  [3,7],  [4,8]
    , [4,9], [5,10], [5,11], [6,12], [6,13], [7,14], [7,15] ]

parents = function(vertices) {
  var accumulator = []
  for(var i=0; i < E.length; i++) {
    var edge = E[i]
    if(vertices.indexOf(edge[1]) !== -1)
      accumulator.push(edge[0])
  }
  return accumulator
}

上面函数的本质是遍历一个列表，为每个项目评估一些代码并建立一个结果累加器。但是，这还不够清楚，
因为循环构造会引入一些不必要的复杂性。

如果为此目的设计了一个更具体的循环结构，那将是很好的。碰巧的是，该reduce函数正是这样做的：给定
一个列表和一个函数，它会针对列表中的每个元素对函数进行评估，同时将累加器通过每次评估遍历。

用这种更实用的样式编写的查询更短，更清晰：

parents  = (vertices) => E.reduce( (acc, [parent, child])
         => vertices.includes(child)  ? acc.concat(parent) : acc , [] )
children = (vertices) => E.reduce( (acc, [parent, child])
         => vertices.includes(parent) ? acc.concat(child)  : acc , [] )

给定一个顶点列表，我们在边缘上进行缩小，如果边缘的子代在输入列表中，则将边缘的父代添加到累加器
中。该children功能是相同的，但检查边缘的母公司，以确定是否增加了边的孩子。

这些功能是有效的JavaScript，但是使用了一些功能，这些功能在撰写本文时尚未实现浏览器。此翻译版本
将在今天运行：

parents  = function(x) { return E.reduce(
  function(acc, e) { return ~x.indexOf(e[1]) ? acc.concat(e[0]) : acc }, [] )}
children = function(x) { return E.reduce(
  function(acc, e) { return ~x.indexOf(e[0]) ? acc.concat(e[1]) : acc }, [] )}

现在我们可以这样说：

    children(children(children(parents(parents(parents([8]))))))

它向后读取，使我们迷失在愚蠢的parens中，但在其他方面与我们想要的非常接近。花一点时间看一下代码
。您看到任何改善方法吗？

我们将边缘视为全局变量，这意味着使用这些辅助功能一次只能拥有一个数据库。那是非常有限的。

我们也根本不使用顶点。这告诉我们什么？这意味着我们需要的一切都在edges数组中，在这种情况下，这
是正确的：顶点值是标量，因此它们独立存在于edges数组中。如果我们要回答诸如“ Freyja与女武神的联
系是什么？”之类的问题，我们将需要向顶点添加更多数据，这意味着使它们成为复合值，这意味着edges数
组应引用顶点而不是复制其值。

我们的边缘也是如此：它们包含一个“入”顶点和一个“出”顶点^5，但没有优雅的方式来合并其他信息。我们
需要用它来回答诸如“ Loki有多少继父母？”的问题。或“奥丁在雷神出生之前生了多少个孩子？”

您不必费劲地斜视一下我们两个选择器的代码看起来非常相似，这表明它们可能从中更深层次地抽象出来。

您还有其他问题吗？

建立更好的图表

让我们解决一些我们发现的问题。将顶点和边设为全局构造会使我们一次只能绘制一张图，但我们希望拥有
更多图。为了解决这个问题，我们需要一些结构。让我们从命名空间开始。

Dagoba = {}                                     // the namespace

我们将使用一个对象作为我们的命名空间。JavaScript中的对象通常只是键/值对的无序集合。在
JavaScript中，我们只有四种基本数据结构可供选择，因此我们将大量使用这一结构。（在聚会上问人们一
个有趣的问题是“ JavaScript的四个基本数据结构是什么？”）

现在我们需要一些图。我们可以使用经典的OOP模式来构建它们，但是JavaScript为我们提供了原型继承，
这意味着我们可以构建原型对象（我们将其称为）Dagoba.G，然后使用工厂函数实例化该对象的副本。这种
方法的优点是我们可以从工厂返回不同类型的对象，而不是将创建过程绑定到单个类构造函数。因此，我们
免费提供了一些额外的灵活性。

Dagoba.G = {}                                   // the prototype

Dagoba.graph = function(V, E) {                 // the factory
  var graph = Object.create( Dagoba.G )

  graph.edges       = []                        // fresh copies so they're not shared
  graph.vertices    = []
  graph.vertexIndex = {}                        // a lookup optimization

  graph.autoid = 1                              // an auto-incrementing ID counter

  if(Array.isArray(V)) graph.addVertices(V)     // arrays only, because you wouldn't
  if(Array.isArray(E)) graph.addEdges(E)        //   call this with singular V and E

  return graph
}

我们将接受两个可选参数：顶点列表和边列表。JavaScript在参数方面比较宽松，因此所有命名参数都是可
选的，undefined如果未提供，则默认为^6。在构建图形并使用V和E参数之前，我们通常会具有顶点和边，
但是在创建时没有这些顶点和边并以编程方式构建图形也是很常见的^7。

然后，我们创建一个新对象，它具有原型的所有优点，而没有任何缺点。我们为边缘构建了一个全新的数组
（其他基本JS数据结构之一），为顶点构建了一个新数组，一个名为的新对象vertexIndex和一个ID计数器-
稍后将详细介绍这两个。（思考：为什么我们不能将它们放在原型中？）

然后我们调用addVertices，并addEdges从我们的工厂里面，让我们现在定义的。

Dagoba.G.addVertices = function(vs) { vs.forEach(this.addVertex.bind(this)) }
Dagoba.G.addEdges    = function(es) { es.forEach(this.addEdge  .bind(this)) }

好的，那太容易了，我们只是将工作转移给了addVertex和addEdge。我们现在也应该定义它们。

Dagoba.G.addVertex = function(vertex) {         // accepts a vertex-like object
  if(!vertex._id)
    vertex._id = this.autoid++
  else if(this.findVertexById(vertex._id))
    return Dagoba.error('A vertex with that ID already exists')

  this.vertices.push(vertex)
  this.vertexIndex[vertex._id] = vertex         // a fancy index thing
  vertex._out = []; vertex._in = []             // placeholders for edge pointers
  return vertex._id
}

如果顶点还没有_id属性，则使用我们的autoid为其分配一个属性。^8如果_id图形中的顶点上已经存在该顶
点，则我们拒绝新的顶点。等一下，什么时候会发生？顶点到底是什么？

在传统的面向对象的系统中，我们希望找到一个顶点类，所有顶点都将是一个实例。我们要采取不同的方法
，并考虑为顶点包含三个属性的任何对象_id，_in和_out。这是为什么？最终，归根结底是要让Dagoba控制
与主机应用程序共享哪些数据。

如果我们Dagoba.Vertex在addVertex函数内部创建实例，则内部数据将永远不会与主机应用程序共享。如果
我们接受Dagoba.Vertex实例作为addVertex函数的参数，则主机应用程序可以保留指向该顶点对象的指针，
并在运行时对其进行操作，从而打破不变性。

因此，如果我们创建一个顶点实例对象，就必须预先决定是将我们始终将提供的数据始终复制到一个新对象
中（有可能使我们的空间使用量增加一倍）还是允许主机应用程序不受限制地访问数据库对象。在性能和保
护之间存在着张力，正确的平衡取决于您的特定用例。

通过在顶点的属性上进行鸭子输入，我们可以在运行时做出决定，方法是深度复制^9输入数据或将其直接用
作顶点^10。我们并不总是希望将平衡安全性和性能的责任交给用户，但是由于这两套用例差异很大，因此
额外的灵活性很重要。

现在我们有了新的顶点，我们将其添加到图形的顶点列表中，将其添加到中以vertexIndex进行有效查找_id
，并为其添加两个附加属性：_out和_in，它们都将成为边^11的列表。

Dagoba.G.addEdge = function(edge) {             // accepts an edge-like object
  edge._in  = this.findVertexById(edge._in)
  edge._out = this.findVertexById(edge._out)

  if(!(edge._in && edge._out))
    return Dagoba.error("That edge's " + (edge._in ? 'out' : 'in')
                                       + " vertex wasn't found")

  edge._out._out.push(edge)                     // edge's out vertex's out edges
  edge._in._in.push(edge)                       // vice versa

  this.edges.push(edge)
}

首先，我们找到边缘连接的两个顶点，然后，如果缺少任何一个顶点，则拒绝边缘。我们将使用一个辅助函
数来记录拒绝时的错误。所有错误都会通过此辅助函数传播，因此我们可以基于每个应用程序覆盖其行为。
稍后我们可以扩展它以允许onError注册处理程序，因此主机应用程序可以链接自己的回调而不会覆盖帮助
程序。我们可能允许按图，按应用程序或按两种方式注册此类处理程序，具体取决于所需的灵活性级别。

Dagoba.error = function(msg) {
  console.log(msg)
  return false
}

然后，将新边添加到两个顶点的边列表中：边的外顶点的边列表，以及边的内边的列表。

这就是我们现在需要的所有图结构！

输入查询

该系统实际上只有两部分：保存图形的部分和回答有关图形的问题的部分。如我们所见，保存图形的部分非
常简单。查询部分有些棘手。

我们将像以前一样从一个原型和一个查询工厂开始。

Dagoba.Q = {}

Dagoba.query = function(graph) {                // factory
  var query = Object.create( Dagoba.Q )

  query.   graph = graph                        // the graph itself
  query.   state = []                           // state for each step
  query. program = []                           // list of steps to take
  query.gremlins = []                           // gremlins for each step

  return query
}

现在是介绍一些朋友的好时机。

一个程序是一系列步骤。每个步骤就像一条管道中的管道，一条数据进入一端，以某种方式转换，然后流出
另一端。我们的管道并不能完全那样工作，但这是一个很好的第一近似值。

程序中的每个步骤都可以具有状态，并且query.state是每个步骤状态的列表，这些状态的索引与中的步骤
列表相关query.program。

一个小鬼是通过做我们的招标曲线行进的生物。在数据库中找到gremlin可能是一件令人惊讶的事情，但是
它们的历史可以追溯到Tinkerpop的Blueprints以及Gremlin和Pacer查询语言。他们记得去过的地方，并允
许我们找到有趣问题的答案。

还记得我们想回答的有关托尔的第二个表亲的问题吗？我们认为这
Thor.parents.parents.parents.children.children.children是一种很好的表达方式。每个parents或
children实例在我们的程序的步骤。每个步骤都包含对其管道类型的引用，该管道类型是执行该步骤操作的
函数。

我们的实际系统中的查询可能类似于：

    g.v('Thor').out().out().out().in().in().in()

每个步骤都是一个函数调用，因此它们可以使用arguments。解释器将步骤的参数传递给步骤的管道类型函
数，因此在查询g.v('Thor').out(2, 3)中out管道类型函数将[2, 3]作为其第一个参数接收。

我们需要一种向查询添加步骤的方法。这是一个辅助函数：

Dagoba.Q.add = function(pipetype, args) { // add a new step to the query
  var step = [pipetype, args]
  this.program.push(step)                 // step is a pair of pipetype and its args
  return this
}

每个步骤都是一个复合实体，将pipetype函数与参数结合使用以应用于该函数。在此阶段，我们可以将两者
合并为部分应用的函数，而不是使用元组^12，但是随后我们将失去一些内省的能力，这些力量将在以后被
证明是有用的。

我们将使用一小组查询初始化器，这些初始化器从图生成新查询。这是我们大多数示例的开始：v方法。它
会建立一个新查询，然后使用我们的add助手来填充初始查询程序。这利用了vertex管道类型，我们将在稍
后讨论。

Dagoba.G.v = function() {                       // query initializer: g.v() -> query
  var query = Dagoba.query(this)
  query.add('vertex', [].slice.call(arguments)) // add a step to our program
  return query
}

请注意，[].slice.call(arguments)“请向我传递此函数的参数数组”是JS的说法。您会假设它arguments已
经是一个数组是可以原谅的，因为它在许多情况下的行为都像一个数组，但是它缺少我们在现代JavaScript
数组中使用的许多功能。

渴望的问题

在研究管道类型本身之前，我们将转移到令人兴奋的执行策略领域。有两种主要的思想流派：按价值呼唤氏
族，也被称为渴望的海狸，严格要求在应用函数之前先评估所有参数。他们的对立派系“按需求呼叫”满足于
在做任何事情之前拖延直到最后一刻-总而言之，他们是懒惰的。

JavaScript是一种严格的语言，将在调用每个步骤时对其进行处理。然后，我们希望对的求值是g.v
('Thor').out().in()先找到Thor顶点，然后找到通过出线边缘与其连接的所有顶点，然后从这些顶点中的
每一个最终返回它们通过入站边缘连接的所有顶点。

使用非严格语言，我们将得到相同的结果-执行策略在这里并没有多大区别。但是，如果我们增加了一些额
外的电话呢？考虑到Thor的连接性，我们的g.v('Thor').out().out().out().in().in().in()查询可能会产
生许多结果-实际上，由于我们不将顶点列表限制为唯一的结果，因此它所产生的结果可能会比总图中的顶
点多得多。

我们可能只对获取一些独特的结果感兴趣，因此我们将对查询进行一些更改：g.v('Thor').out().out
().out().in().in().in().unique().take(10)。现在，我们的查询最多产生10个结果。但是，如果我们急
切地进行评估，会发生什么？在仅返回前10个结果之前，我们仍然需要建立数十亿个结果。

所有图形数据库都必须支持一种机制，以尽可能减少工作量，并且大多数数据库都选择某种形式的非严格评
估来执行。由于我们正在构建自己的解释器，因此可以对程序进行延迟评估，但是可能需要应对某些后果。

心理模型对评估策略的影响

到目前为止，我们的评估思维模型非常简单：

  • 请求一组顶点
  • 将返回的集作为输入传递给管道
  • 根据需要重复

我们希望为我们的用户保留该模型，因为它更易于推论，但是正如我们已经看到的那样，我们不再可以将该
模型用于实现。让用户考虑使用与实际实现不同的模型会带来很多麻烦。泄漏抽象是这种形式的小规模版本
。大体上会导致沮丧，认知失调和流涕。

但是，对于这种欺骗，我们的情况几乎是最佳的：无论执行模型如何，任何查询的答案都是相同的。唯一的
区别是性能。折衷方案是让所有用户在使用系统之前学习更复杂的模型，或者强迫用户的子集从简单模型转
换为复杂模型，以便更好地推理查询性能。

做出此决定时要考虑的一些因素包括：

  • 学习简单模型与更复杂模型的相对认知困难；
  • 首先使用简单模型然后前进到复杂模型而不是跳过简单模型并仅学习复杂模型而施加的额外认知负荷；
  • 进行过渡所需的用户子集，包括比例大小，认知可用性，可用时间等。

在我们的案例中，这种权衡是有意义的。在大多数情况下，查询将以足够快的速度返回结果，从而使用户不
必担心优化查询结构或学习更深入的模型。那些将是对大型数据集编写高级查询的用户，他们也很有可能是
最有能力过渡到新模型的用户。另外，我们希望在学习更复杂的模型之前，使用简单模型只会使难度增加很
小。

我们将很快对此新模型进行更详细的介绍，但与此同时，在下一节中，请牢记以下要点：

  • 每个管道一次返回一个结果，而不是一组结果。每个管道可以在评估查询时被多次激活。
  • 读/写头控制接下来激活哪个管道。头从管道的末端开始，其移动由当前活动管道的结果指示。
  • 该结果可能是上述的gregreins之一。每个gremlin代表一个潜在的查询结果，并且它们通过管道携带状
    态。小妖精使头部向右移动。
  • 管道可以返回“拉”结果，该信号向头部发出信号，指示需要输入并将其向右移动。
  • “ done”（完成）的结果告诉头部，无需再次激活任何先验功能，然后将头部向左移动。

管道类型

管道类型构成了我们系统的核心。一旦我们理解了每个函数的工作原理，我们将有一个更好的基础来理解它
们在解释器中如何一起被调用和排序。

我们首先放置一个放置管道类型的地方，然后添加一个新管道。

Dagoba.Pipetypes = {}

Dagoba.addPipetype = function(name, fun) {              // adds a chainable method
  Dagoba.Pipetypes[name] = fun
  Dagoba.Q[name] = function() {
    return this.add(name, [].slice.apply(arguments)) }  // capture pipetype and args
}

将管道类型的函数添加到管道类型列表中，然后将新方法添加到查询对象。每个管道类型都必须具有相应的
查询方法。该方法及其参数向查询程序添加了新的步骤。

当我们评估g.v('Thor').out('parent').in('parent')该v调用返回一个查询对象时，该out调用添加一个新
步骤并返回该查询对象，并且该in调用执行相同的操作。这就是启用我们的方法链接API的原因。

请注意，添加具有相同名称的新管道类型将替换现有管道类型，从而允许在运行时修改现有管道类型。这个
决定的代价是什么？有哪些选择？

Dagoba.getPipetype = function(name) {
  var pipetype = Dagoba.Pipetypes[name]                 // a pipetype is a function

  if(!pipetype)
    Dagoba.error('Unrecognized pipetype: ' + name)

  return pipetype || Dagoba.fauxPipetype
}

如果找不到管道类型，则会生成一个错误并返回默认管道类型，该默认管道类型的作用就像一条空管道：如
果一条消息进入一侧，则传递到另一侧。

Dagoba.fauxPipetype = function(_, _, maybe_gremlin) {   // pass the result upstream
  return maybe_gremlin || 'pull'                        // or send a pull downstream
}

看到那些下划线？我们使用那些标签来标记将在我们的函数中不使用的参数。大多数其他管道类型将使用所
有三个参数，并具有所有三个参数名称。这使我们能够一眼分辨出特定管道类型所依赖的参数。

这种下划线技术也很重要，因为它可以使注释很好地对齐。不，认真如果“必须编写程序供人们阅读，并且
只能偶然地使机器执行”，那么我们马上就会想到，我们的主要关注应该是使代码漂亮。

顶点

我们遇到的大多数管道类型都将使用gremlin并生成更多的gremlins，但是这种特定的管道类型仅通过字符
串即可生成gremlins。给定一个顶点ID，它将返回一个新的gremlin。给定一个查询，它将找到所有匹配的
顶点，并一次产生一个新的gremlin，直到通过它们为止。

Dagoba.addPipetype('vertex', function(graph, args, gremlin, state) {
  if(!state.vertices)
    state.vertices = graph.findVertices(args)       // state initialization

  if(!state.vertices.length)                        // all done
    return 'done'

  var vertex = state.vertices.pop()                 // OPT: requires vertex cloning
  return Dagoba.makeGremlin(vertex, gremlin.state)  // gremlins from as/back queries
})

我们首先检查是否已经收集了匹配的顶点，否则我们尝试找到一些顶点。如果有任何顶点，我们将弹出一个
顶点，并返回一个位于该顶点上的新gremlin。每个鬼怪可以携带自己的状态，就像日记记录了去过的地方
以及在遍历图表时看到的有趣的事情。如果我们收到一个gremlin作为此步骤的输入，我们将为退出的
gremlin复制其日志。

请注意，我们在这里直接更改state参数，而不是将其传递回去。另一种选择是返回一个对象而不是gremlin
或信号，然后以这种方式返回状态。这使我们的返回值复杂化，并创建了一些额外的垃圾^13。如果JS允许
多个返回值，它将使此选项更加美观。

但是，我们仍然需要找到一种方法来处理突变，因为调用位点保留了对原始变量的引用。如果我们可以通过
某种方法确定特定引用是否为“唯一”，即它是对该对象的唯一引用，该怎么办？

如果我们知道一个引用是唯一的，那么我们将获得不变性的好处，同时避免了昂贵的写时复制方案或复杂的
持久数据结构。仅凭一个引用，我们无法确定对象是否已被更改或是否已返回我们请求的更改的新对象：保
持“观察到的不变性” ^14。

有两种常见的确定方法：在静态类型的系统中，我们可以利用唯一性类型^15来保证在编译时每个对象只有
一个引用。如果我们有一个参考计数器^16（甚至只是便宜的两位粘性计数器），我们就可以在运行时知道
一个对象只有一个参考，并利用该知识为我们带来好处。

JavaScript没有这两种功能，但是如果我们真的非常有纪律，我们可以获得几乎相同的效果。我们将成为。
目前。

进出

遍历图表就像订购汉堡一样容易。这两行为我们设置了in和out管道类型。

Dagoba.addPipetype('out', Dagoba.simpleTraversal('out'))
Dagoba.addPipetype('in',  Dagoba.simpleTraversal('in'))

该simpleTraversal函数返回一个接受gremlin作为其输入的管道类型处理程序，并在每次查询时生成一个新
的gremlin。一旦这些gregreins消失了，它就会发送回“拉”请求，以从其前身那里获得新的gremlin。

Dagoba.simpleTraversal = function(dir) {
  var find_method = dir == 'out' ? 'findOutEdges' : 'findInEdges'
  var edge_list   = dir == 'out' ? '_in' : '_out'

  return function(graph, args, gremlin, state) {
    if(!gremlin && (!state.edges || !state.edges.length))     // query initialization
      return 'pull'

    if(!state.edges || !state.edges.length) {                 // state initialization
      state.gremlin = gremlin
      state.edges = graph[find_method](gremlin.vertex)        // get matching edges
                         .filter(Dagoba.filterEdges(args[0]))
    }

    if(!state.edges.length)                                   // nothing more to do
      return 'pull'

    var vertex = state.edges.pop()[edge_list]                 // use up an edge
    return Dagoba.gotoVertex(state.gremlin, vertex)
  }
}

前几行处理输入版本和输出版本之间的差异。然后，我们准备返回我们的pipetype函数，该函数看起来很像
我们刚刚看到的顶点管道类型。这有点让人惊讶，因为这需要一个gremlin，而顶点管道类型会从nihilo生
成gremlins 。

但是，我们可以看到这里出现了同样的情况，增加了查询初始化步骤。如果没有鬼胎蛋白并且我们没有可用
的边缘，那么我们就拉。如果我们有一个格雷姆林，但尚未设置状态，那么我们会找到沿正确方向的所有边
并将其添加到我们的状态。如果有一个葛雷姆林，但是它的当前顶点没有合适的边，那么我们拉。最后，我
们弹出一条边缘，并在其指向的顶点上返回一个新克隆的gremlin。

看一下这段代码，我们在这!state.edges.length三个子句中都看到了重复的内容。试图对此进行重构以降
低这些条件的复杂性是很诱人的。有两个问题使我们无法这样做。

一个相对较小：第三个!state.edges.length意味着与前两个有所不同，因为state.edges已在第二个和第三
个条件之间进行了更改。实际上，这鼓励我们进行重构，因为具有相同标签意味着在单个函数内包含两个不
同的事物通常并不理想。

第二个更严重。这不是我们正在编写的唯一管道类型函数，并且我们将一遍又一遍地看到这些查询初始化和
/或状态初始化的想法。在编写代码时，结构化质量和非结构化质量之间总是存在平衡的行为。结构太多，
您将在样板和抽象复杂性上付出高昂的代价。结构太少，您必须将所有管道细节保留在脑海中。

在这种情况下，大约有十几种管道类型，正确的选择似乎是尽可能使每种管道类型的功能样式化，并用注释
标记组成部分。因此，我们抵制了重构这种特定管道类型的冲动，因为这样做会降低一致性，但是我们也抵
制了为查询初始化，状态初始化等设计正式的结构抽象的冲动。如果有数百种管道类型，则后一种选择可能
是正确的选择：抽象的复杂性成本是不变的，而收益则随单位数量线性增长。当处理那么多移动部件时，您
可以采取任何措施来强制其中的规则性是有帮助的。

属性

让我们暂停片刻，考虑基于我们已经看到的三种管道类型的示例查询。我们可以这样要求托尔的祖父母^17
：

g.v('Thor').out('parent').out('parent').run()

但是，如果我们想要他们的名字怎么办？我们可以在那末放一张地图：

g.v('Thor').out('parent').out('parent').run()
 .map(function(vertex) {return vertex.name})

但这是一个足够常见的操作，我们希望编写更多类似的内容：

g.v('Thor').out('parent').out('parent').property('name').run()

再加上这种方式，属性管道是查询的组成部分，而不是后面附加的内容。我们将很快看到，这有一些有趣的
好处。

Dagoba.addPipetype('property', function(graph, args, gremlin, state) {
  if(!gremlin) return 'pull'                                  // query initialization
  gremlin.result = gremlin.vertex[args[0]]
  return gremlin.result == null ? false : gremlin             // false for bad props
})

这里的查询初始化很简单：如果没有gremlin，我们拉。如果存在小怪兽，则将其结果设置为属性的值。然
后，小鬼可以继续前进。如果它通过最后一个管道，它将收集结果并从查询中返回。并非所有的gremlins都
具有result属性。那些不返回其最近访问的顶点的顶点。

请注意，如果属性不存在，我们将返回false而不是返回gremlin，因此属性管道也将充当过滤器的一种类型
。您能想到此用途吗？在此设计决策中要权衡哪些？

独特

如果我们想收集所有Thor的祖父母的外孙（他的堂兄弟姐妹，兄弟姐妹和他本人），可以执行以下查询：
g.v('Thor').in().in().out().out().run()。但是，这将给我们带来很多重复。实际上，至少会有四本托
尔本人。（您能想到一个可能还会更多的时间吗？）

为了解决这个问题，我们引入了一种称为“唯一”的新管道类型。我们的新查询将产生与孙代一一对应的输出
：

    g.v('Thor').in().in().out().out().unique().run()

管道类型的实现：

Dagoba.addPipetype('unique', function(graph, args, gremlin, state) {
  if(!gremlin) return 'pull'                                  // query initialization
  if(state[gremlin.vertex._id]) return 'pull'                 // reject repeats
  state[gremlin.vertex._id] = true
  return gremlin
})

一个独特的管道纯粹是一个过滤器：它要么使gremlin原封不动地通过，要么尝试从以前的管道中拉出新的
gremlin。

我们通过尝试收集格雷姆林初始化。如果gremlin的当前顶点在我们的缓存中，那么我们之前已经看过它，
因此我们尝试收集一个新顶点。否则，我们将gremlin的当前顶点添加到缓存中并传递。十分简单。

过滤

我们已经看到了两种简单的过滤方法，但是有时我们需要更复杂的约束。如果我们想找到所有重量大于身高
^18的托尔兄弟姐妹怎么办？该查询将为我们提供答案：

g.v('Thor').out().in().unique()
 .filter(function(asgardian) { return asgardian.weight > asgardian.height })
 .run()

如果我们想知道雷神兄弟中哪一个幸存下来，我们可以通过过滤对象：

g.v('Thor').out().in().unique().filter({survives: true}).run()

运作方式如下：

Dagoba.addPipetype('filter', function(graph, args, gremlin, state) {
  if(!gremlin) return 'pull'                                  // query initialization

  if(typeof args[0] == 'object')                              // filter by object
    return Dagoba.objectFilter(gremlin.vertex, args[0])
         ? gremlin : 'pull'

  if(typeof args[0] != 'function') {
    Dagoba.error('Filter is not a function: ' + args[0])
    return gremlin                                            // keep things moving
  }

  if(!args[0](gremlin.vertex, gremlin)) return 'pull'         // gremlin fails filter
  return gremlin
})

如果过滤器的第一个参数不是对象或函数，则我们将触发错误，并传递gremlin。暂停一分钟，然后考虑替
代方法。一旦遇到错误，我们为什么决定继续查询？

可能出现此错误有两个原因。首先涉及程序员在REPL中或直接在代码中键入查询。运行时，该查询将产生结
果，并且还会产生程序员可观察到的错误。程序员然后纠正错误以进一步过滤产生的结果集。或者，系统可
以仅显示错误而不产生结果，而修复所有错误将允许显示结果。

第二种可能性是在运行时动态应用过滤器。这是一个非常重要的情况，因为调用查询的人不一定是查询代码
的作者。因为这是在网络上，所以我们的默认规则是始终显示结果，并且永不中断。通常最好是在遇到麻烦
时退缩，而不是屈服于我们的伤口，并向用户显示严重的错误信息。

在那些情况下，显示的结果太少胜于显示的结果太多，Dagoba.error可以被覆盖以引发错误，从而规避自然
控制流程。

采取

我们并不总是希望一次获得所有结果。有时我们只需要少数结果。说我们想要十二个托尔的同时代人，所以
我们一路回到原始牛Auðumbla：

g.v('Thor').out().out().out().out().in().in().in().in().unique().take(12).run()

如果没有take管道，该查询可能需要花费相当长的时间才能运行，但是由于我们采用了惰性评估策略，因此
使用take管道的查询非常高效。

有时我们一次只想要一个：我们将处理结果，使用它，然后再返回另一个。这种管道类型也使我们能够做到
这一点。

q = g.v('Auðumbla').in().in().in().property('name').take(1)

q.run() // ['Odin']
q.run() // ['Vili']
q.run() // ['Vé']
q.run() // []

我们的查询可以在异步环境中运行，从而使我们可以根据需要收集更多结果。当我们用完时，将返回一个空
数组。

Dagoba.addPipetype('take', function(graph, args, gremlin, state) {
  state.taken = state.taken || 0                              // state initialization

  if(state.taken == args[0]) {
    state.taken = 0
    return 'done'                                             // all done
  }

  if(!gremlin) return 'pull'                                  // query initialization
  state.taken++
  return gremlin
})

state.taken如果不存在，我们初始化为零。JavaScript有隐含的胁迫，但强制转换undefined成NaN的，所
以我们必须要明确的在这里^19。

然后state.taken到达时，args[0]我们返回“完成”，将前面的管道密封起来。我们还重置了state.taken计
数器，使我们以后可以重复查询。

我们做这两个步骤查询初始化之前办理的案件take(0)和take() ^20。然后，我们增加计数器并返回gremlin
。

如

接下来的四个管道类型作为一个组工作，以允许进行更高级的查询。这仅允许您标记当前顶点。我们将在接
下来的两个管道类型中使用该标签。

Dagoba.addPipetype('as', function(graph, args, gremlin, state) {
  if(!gremlin) return 'pull'                                  // query initialization
  gremlin.state.as = gremlin.state.as || {}                   // init the 'as' state
  gremlin.state.as[args[0]] = gremlin.vertex                  // set label to vertex
  return gremlin
})

初始化查询后，我们确保gremlin的本地状态具有as参数。然后，我们将该参数的属性设置为gremlin的当前
顶点。

合并

一旦标记了顶点，就可以使用merge提取它们。如果我们想要托尔的父母，祖父母和曾祖父母，我们可以做
这样的事情：

g.v('Thor').out().as('parent').out().as('grandparent').out().as('great-grandparent')
           .merge('parent', 'grandparent', 'great-grandparent').run()

这是合并管道类型：

Dagoba.addPipetype('merge', function(graph, args, gremlin, state) {
  if(!state.vertices && !gremlin) return 'pull'               // query initialization

  if(!state.vertices || !state.vertices.length) {             // state initialization
    var obj = (gremlin.state||{}).as || {}
    state.vertices = args.map(function(id) {return obj[id]}).filter(Boolean)
  }

  if(!state.vertices.length) return 'pull'                    // done with this batch

  var vertex = state.vertices.pop()
  return Dagoba.makeGremlin(vertex, gremlin.state)
})

我们映射每个参数，然后在gremlin的标记顶点列表中寻找它。如果找到它，则将gremlin克隆到该顶点。请
注意，合并中仅包括到达此管道的gremlins-如果Thor的母亲的父母不在图中，则她将不在结果集中。

除

我们已经看到过一些案例，我们想说“给我所有非雷神的雷神兄弟姐妹”。我们可以用过滤器做到这一点：

g.v('Thor').out().in().unique()
           .filter(function(asgardian) {return asgardian._id != 'Thor'}).run()

使用asand 更简单except：

g.v('Thor').as('me').out().in().except('me').unique().run()

但是也有一些查询很难过滤。如果我们想要雷神的叔叔和姨妈怎么办？我们将如何过滤他的父母？as和
except ^21很容易：

g.v('Thor').out().as('parent').out().in().except('parent').unique().run()

Dagoba.addPipetype('except', function(graph, args, gremlin, state) {
  if(!gremlin) return 'pull'                                  // query initialization
  if(gremlin.vertex == gremlin.state.as[args[0]]) return 'pull'
  return gremlin
})

在这里，我们正在检查当前顶点是否等于我们先前存储的顶点。如果是，我们将其跳过。

背部

我们可能会提出的一些问题涉及进一步检查图表，如果答案是肯定的，则稍后再返回到我们的起点。假设我
们想知道Fjörgynn的哪些女儿育有Bestla的儿子之一的孩子？

g.v('Fjörgynn').in().as('me')       // first gremlin's state.as is Frigg
 .in()                              // first gremlin's vertex is now Baldr
 .out().out()                       // clone that gremlin for each grandparent
 .filter({_id: 'Bestla'})           // keep only the gremlin on grandparent Bestla
 .back('me').unique().run()         // jump gremlin's vertex back to Frigg and exit

这是定义back：

Dagoba.addPipetype('back', function(graph, args, gremlin, state) {
  if(!gremlin) return 'pull'                                  // query initialization
  return Dagoba.gotoVertex(gremlin, gremlin.state.as[args[0]])
})

我们正在使用Dagoba.gotoVertex助手功能在这里完成所有实际工作。让我们现在来看一下它和其他一些帮
助器。

帮手

上面的管道类型依靠一些帮助者来完成工作。在深入了解口译员之前，让我们快速看一下。

格林林斯

小怪兽是简单的生物：它们具有当前的顶点和某些局部状态。因此，要制作一个新的东西，我们只需要用这
两个东西制作一个物体。

Dagoba.makeGremlin = function(vertex, state) {
  return {vertex: vertex, state: state || {} }
}

根据这个定义，任何具有顶点属性和状态属性的对象都是gremlin，因此我们可以内联构造函数，但是将其
包装在函数中可以使我们将所有属性添加到所有gremlins中。

正如我们在back管道类型和simpleTraversal函数中所见，我们还可以获取现有的gremlin并将其发送到新的
顶点。

Dagoba.gotoVertex = function(gremlin, vertex) {               // clone the gremlin
  return Dagoba.makeGremlin(vertex, gremlin.state)
}

请注意，此函数实际上返回一个全新的gremlin：旧克隆的克隆，并发送到我们所需的目的地。这意味着，
gremlin可以坐在一个顶点上，而将其克隆发送出去以探索许多其他顶点。这正是发生的情况
simpleTraversal。

作为可能的增强功能的示例，我们可以添加一些状态来跟踪gremlin访问的每个顶点，并添加新的管道类型
以利用这些路径。

寻找

该vertexpipetype使用findVertices功能来收集一组初始的顶点，从此处开始我们的查询。

Dagoba.G.findVertices = function(args) {                      // vertex finder helper
  if(typeof args[0] == 'object')
    return this.searchVertices(args[0])
  else if(args.length == 0)
    return this.vertices.slice()                              // OPT: slice is costly
  else
    return this.findVerticesByIds(args)
}

该函数将其参数作为列表接收。如果第一个对象是一个对象，则将其传递给searchVertices，从而允许进行
以下查询：

  g.v({_id:'Thor'}).run()
  g.v({species: 'Aesir'}).run()

否则，如果有参数传递给findVerticesByIds，则该参数将处理g.v('Thor', 'Odin').run()。

如果根本没有参数，那么我们的查询看起来像g.v().run()。对于大型图形，这不是您经常要执行的操作，
尤其是因为我们在返回顶点列表之前先对其进行切片。我们之所以进行切片，是因为某些呼叫站点通过在处
理它们时弹出项目来直接操纵返回列表。我们可以通过在呼叫站点进行克隆或避免这些操作来优化此用例。
（我们可以保持计数器状态而不是弹出。）

Dagoba.G.findVerticesByIds = function(ids) {
  if(ids.length == 1) {
    var maybe_vertex = this.findVertexById(ids[0])            // maybe it's a vertex
    return maybe_vertex ? [maybe_vertex] : []                 // or maybe it isn't
  }

  return ids.map( this.findVertexById.bind(this) ).filter(Boolean)
}

Dagoba.G.findVertexById = function(vertex_id) {
  return this.vertexIndex[vertex_id]
}

注意vertexIndex此处的使用。如果没有该索引，我们将不得不一次遍历列表中的每个顶点来确定它是否与
ID相匹配-将恒定时间操作转换为线性时间一个，以及任何O （n ）Ø（ñ）直接依赖它的操作 O （ñ2）Ø（
ñ2）操作。

Dagoba.G.searchVertices = function(filter) {        // match on filter's properties
  return this.vertices.filter(function(vertex) {
    return Dagoba.objectFilter(vertex, filter)
  })
}

该searchVertices函数objectFilter在图形的每个顶点上使用帮助器。我们将objectFilter在下一节中介绍
，但与此同时，您能想到一种懒惰地搜索顶点的方法吗？

筛选

我们看到，simpleTraversal在遇到的边缘使用了过滤功能。这是一个简单的功能，但足以满足我们的目的
。

Dagoba.filterEdges = function(filter) {
  return function(edge) {
    if(!filter)                                 // no filter: everything is valid
      return true

    if(typeof filter == 'string')               // string filter: label must match
      return edge._label == filter

    if(Array.isArray(filter))                   // array filter: must contain label
      return !!~filter.indexOf(edge._label)

    return Dagoba.objectFilter(edge, filter)    // object filter: check edge keys
  }
}

第一种情况根本没有过滤器：将g.v('Odin').in().run()所有边遍历到Odin。

第二种情况在边缘的标签上进行过滤：g.v('Odin').in('parent').run()以“ parent” 标签遍历那些边缘。

第三种情况接受一个标签数组：g.v('Odin').in(['parent', 'spouse']).run()遍历父母和配偶边缘。

第四种情况使用我们之前看到的objectFilter函数：

Dagoba.objectFilter = function(thing, filter) {
  for(var key in filter)
    if(thing[key] !== filter[key])
      return false

  return true
}

这使我们可以使用过滤器对象查询边缘：

`g.v('Odin').in({_label: 'spouse', order: 2}).run()`    // finds Odin's second wife

口译员的本性

我们到达了叙事山的顶端，准备接受我们的奖项：口译员。该代码实际上相当紧凑，但是该模型有一些微妙
之处。

我们将程序与管道进行了比较，这是编写查询的良好心理模型。但是，正如我们看到的，我们需要一个不同
的模型来实现实际的实现。该模型更像是图灵机，而不是流水线：在特定步骤上有一个读/写头。它“读取”
该步骤，更改其“状态”，然后向右或向左移动。

读取该步骤意味着评估管道类型功能。正如我们在上面看到的，这些函数中的每一个都接受整个图，其自身
的参数（可能是gremlin）以及其自身的局部状态作为输入。作为输出，它提供了一个gremlin，false或“
pull”或“ done”信号。该输出是我们的准图灵机读取的，以更改其状态。

该状态仅包含两个变量：一个用于记录“已完成”的步骤，另一个用于记录results查询的。那些被更新，然
后机头移动或查询完成，并返回结果。

现在，我们已经描述了机器中的所有状态。我们将有一个以空开头的结果列表：

  var results = []

在第一步之后开始的最后一个“完成”步骤的索引：

  var done = -1

我们需要一个地方来存储最新步骤的输出，该地方可能是一个gremlin，也可能什么都不是，所以我们将其
称为maybe_gremlin：

  var maybe_gremlin = false

最后，我们需要一个程序计数器来指示读/写头的位置。

  var pc = this.program.length - 1

除了...等等。我们如何变得懒惰^22？从急切的系统构建懒惰系统的传统方法是将参数存储为函数调用，而
不是求值。您可以将“ thunk”视为一个未经评估的表达。在具有一流函数和闭包的JS中，我们可以通过将函
数及其参数包装在不带参数的新匿名函数中来创建thunk：

function sum() {
  return [].slice.call(arguments).reduce(function(acc, n) { return acc + (n|0) }, 0)
}

function thunk_of_sum_1_2_3() { return sum(1, 2, 3) }

function thunker(fun, args) {
  return function() {return fun.apply(fun, args)}
}

function thunk_wrapper(fun) {
  return function() {
    return thunker.apply(null, [fun].concat([[].slice.call(arguments)]))
  }
}

sum(1, 2, 3)              // -> 6
thunk_of_sum_1_2_3()      // -> 6
thunker(sum, [1, 2, 3])() // -> 6

var sum2 = thunk_wrapper(sum)
var thunk = sum2(1, 2, 3)
thunk()                   // -> 6

在真正需要一个thunk之前，不会调用任何thunk，这通常意味着需要某种类型的输出：在我们的情况下是查
询的结果。每次解释器遇到新的函数调用时，我们都将其包装在一个thunk中。回想一下我们最初的查询公
式：children(children(children(parents(parents(parents([8]))))))。这些层中的每一个都将是一个团
块，像洋葱一样包裹起来。

这种方法有两个权衡：一个是空间性能变得更难以推论，因为可以创建潜在的庞大图块图。另一个是我们的
程序现在被表达为一个单一的重击，而此时我们不能做太多事情。

第二点通常不是问题，因为在我们的编译器运行优化与运行时发生所有更改之间，存在相隔。在我们的案例
中，我们没有这个优势：因为我们使用方法链来实现流畅的接口^23如果我们还使用thunk来实现惰性，我们
将在调用每个新方法时对其进行thunk，这意味着当我们得到新方法时对run()我们只有一个thunk作为我们
的输入，也没有办法来优化我们的查询。

有趣的是，我们流畅的界面隐藏了查询语言和常规编程语言之间的另一个差异。g.v('Thor').in().out
().run()可以将查询重写为run(out(in(v(g, 'Thor'))))好像我们没有使用方法链一样。在JS我们首先处理
g和'Thor'，然后v，然后in，out并且run，从内到外工作。在具有非严格语义的语言中，我们将从外部进行
工作，仅在需要时处理每个连续嵌套的参数层。

因此，如果我们从语句的末尾开始使用来评估查询，然后再run返回到v('Thor')，仅根据需要计算结果，那
么我们已经有效地实现了非限制性。秘密在于查询的线性。分支机构使流程图复杂化，并且还引入了重复调
用的机会，这需要进行备忘录以避免工作浪费。查询语言的简单性意味着我们可以基于线性读/写头模型来
实现同样简单的解释器。

除了允许运行时优化之外，此样式还具有与简化检测相关的其他许多好处：历史记录，可逆性，逐步调试，
查询统计信息。所有这些都很容易动态添加，因为我们控制了解释器，并将其保留为虚拟机评估器，而不是
将程序简化为一个单块。

口译，已公开

Dagoba.Q.run = function() {                 // a machine for query processing

  var max = this.program.length - 1         // index of the last step in the program
  var maybe_gremlin = false                 // a gremlin, a signal string, or false
  var results = []                          // results for this particular run
  var done = -1                             // behindwhich things have finished
  var pc = max                              // our program counter

  var step, state, pipetype

  while(done < max) {
    var ts = this.state
    step = this.program[pc]                 // step is a pair of pipetype and args
    state = (ts[pc] = ts[pc] || {})         // this step's state must be an object
    pipetype = Dagoba.getPipetype(step[0])  // a pipetype is just a function

这里max仅仅是一个常数，step，state，和pipetype关于当前步骤缓存信息。我们已经进入了驱动程序循环
，直到完成最后一步，我们才会停止。

    maybe_gremlin = pipetype(this.graph, step[1], maybe_gremlin, state)

用其参数调用步骤的管道类型函数。

    if(maybe_gremlin == 'pull') {           // 'pull' means the pipe wants more input
      maybe_gremlin = false
      if(pc-1 > done) {
        pc--                                // try the previous pipe
        continue
      } else {
        done = pc                           // previous pipe is done, so we are too
      }
    }

为了处理“拉”情况，我们首先将maybe_gremlin ^24设置为false。我们在这里通过将“也许”作为传递“拉”和
“完成”信号的通道来使“也许”超载，但是一旦这些信号之一被吸取，我们便会重新考虑将其视为适当的“也
许”。

如果摆在我们面前的步骤不是“完成” ^25，我们将向后移动头部，然后重试。否则，我们会将自己标记为“
完成”，并让头部自然地向前倾。

    if(maybe_gremlin == 'done') {           // 'done' tells us the pipe is finished
      maybe_gremlin = false
      done = pc
    }

处理“完成”的情况更加容易：设置maybe_gremlin为false并将此步骤标记为“完成”。

    pc++                                    // move on to the next pipe

    if(pc > max) {
      if(maybe_gremlin)
        results.push(maybe_gremlin)         // a gremlin popped out of the pipeline
      maybe_gremlin = false
      pc--                                  // take a step back
    }
  }

我们已经完成了当前步骤，并且已经将头移到了下一个步骤。如果我们在程序的末尾并且maybe_gremlin包
含一个gremlin，则将其添加到结果中，将其设置maybe_gremlin为false，然后将头移回程序的最后一步。

这也是初始化状态，因为pc从开始max。因此，我们从这里开始并返回原处，对于查询返回的每个最终结果
，至少再次在这里结束一次。

  results = results.map(function(gremlin) { // return projected results, or vertices
    return gremlin.result != null
         ? gremlin.result : gremlin.vertex } )

  return results
}

现在，我们已经退出了驱动程序循环：查询已结束，结果已包含在内，我们只需要处理并返回它们即可。如
果任何gremlin有其结果集，我们将返回该结果集，否则将返回gremlin的最终顶点。还有其他我们想退回的
东西吗？这里的权衡是什么？

查询变形金刚

现在，我们为查询程序提供了一个不错的紧凑型解释器，但仍然缺少一些东西。每个现代的DBMS都将查询优
化器作为系统的重要组成部分。对于非关系型数据库，优化我们的查询计划很少会产生在关系型表亲^26中
看到的指数级加速，但这仍然是数据库设计的重要方面。

我们可以做的最简单的事情是合理地称为查询优化器？好吧，我们可以在运行查询程序之前编写一些用于转
换查询程序的小函数。我们将传入一个程序作为输入，并返回一个不同的程序作为输出。

Dagoba.T = []                               // transformers (more than meets the eye)

Dagoba.addTransformer = function(fun, priority) {
  if(typeof fun != 'function')
    return Dagoba.error('Invalid transformer function')

  for(var i = 0; i < Dagoba.T.length; i++)  // OPT: binary search
    if(priority > Dagoba.T[i].priority) break

  Dagoba.T.splice(i, 0, {priority: priority, fun: fun})
}

现在，我们可以将查询转换器添加到我们的系统中。查询转换器是接受程序并返回程序以及优先级的函数。
优先级较高的变压器放在列表的最前面。我们确保fun是一个函数，因为我们稍后将对其进行评估^27。

我们假设不会有太多的变压器添加，并且线性地遍历该列表以添加一个新的。万一这种假设被证明是错误的
，我们将留个注释-对于长列表，二进制搜索在时间上要优化得多，但会增加一点复杂度，并不能真正加快
短列表的速度。

为了运行这些转换器，我们将在解释器的顶部插入一行代码：

Dagoba.Q.run = function() {                     // our virtual machine for querying
  this.program = Dagoba.transform(this.program) // activate the transformers

我们将使用它来调用此函数，该函数将依次通过每个转换器传递我们的程序：

Dagoba.transform = function(program) {
  return Dagoba.T.reduce(function(acc, transformer) {
    return transformer.fun(acc)
  }, program)
}

到现在为止，我们的引擎已经在性能方面以简化为代价，但是此策略的优点之一是，它为全球优化打开了大
门，而如果我们在设计系统时选择进行局部优化，则可能无法使用全局优化。

优化程序通常会增加复杂性并降低系统的美观度，从而使推理和维护变得更加困难。打破抽象障碍以提高性
能是最令人震惊的优化形式之一，但即使是看似无害的事情，例如将面向性能的代码嵌入业务逻辑中，也使
维护变得更加困难。

有鉴于此，这种“正交优化”特别吸引人。我们可以在模块甚至用户代码中添加优化器，而不是将它们与引擎
紧密耦合。我们可以单独或成组地测试它们，并且通过添加生成测试，我们甚至可以使该过程自动化，从而
确保我们可用的优化程序可以很好地协同工作。

我们还可以使用此转换器系统添加与优化无关的新功能。让我们现在来看一个例子。

别名

进行类似的查询g.v('Thor').out().in()非常紧凑，但这是Thor的兄弟姐妹还是他的同伴？两种解释都不能
令人满意。最好说什么意思：g.v('Thor').parents().children()或g.v('Thor').children().parents()。

我们可以使用查询转换器通过两个额外的辅助函数来创建别名：

Dagoba.addAlias = function(newname, oldname, defaults) {
  defaults = defaults || []                     // default arguments for the alias
  Dagoba.addTransformer(function(program) {
    return program.map(function(step) {
      if(step[0] != newname) return step
      return [oldname, Dagoba.extend(step[1], defaults)]
    })
    }, 100)                                     // 100 because aliases run early

  Dagoba.addPipetype(newname, function() {})
}

我们为现有步骤添加了新名称，因此我们需要创建一个查询转换器，以便在遇到新名称时将其转换为旧名称
。我们还需要将新名称作为方法添加到主查询对象上，以便可以将其提取到查询程序中。

如果我们可以捕获丢失的方法调用并将其路由到处理程序函数，那么我们也许可以以较低的优先级运行此转
换器，但是目前无法做到这一点。相反，我们将以100的高优先级运行它，以便在调用别名方法之前将其添
加。

我们调用另一个帮助程序，以将输入步骤的参数与别名的默认参数合并。如果进入的步骤缺少参数，那么我
们将对该插槽使用别名的参数。

Dagoba.extend = function(list, defaults) {
  return Object.keys(defaults).reduce(function(acc, key) {
    if(typeof list[key] != 'undefined') return acc
    acc[key] = defaults[key]
    return acc
  }, list)
}

现在我们可以创建所需的别名：

Dagoba.addAlias('parents', 'out')
Dagoba.addAlias('children', 'in')

通过将父级和子级之间的每个边标记为“父”边，我们还可以开始更加专门化数据模型。然后，我们的别名将
如下所示：

Dagoba.addAlias('parents', 'out', ['parent'])
Dagoba.addAlias('children', 'in', ['parent'])

现在，我们可以为配偶，继父母甚至是激怒的前恋人添加边缘。如果我们增强addAlias功能，我们可以为祖
父母，兄弟姐妹甚至表亲引入新的别名：

Dagoba.addAlias('grandparents', [ ['out', 'parent'], ['out', 'parent']])
Dagoba.addAlias('siblings',     [ ['as', 'me'], ['out', 'parent']
                                , ['in', 'parent'], ['except', 'me']])
Dagoba.addAlias('cousins',      [ ['out', 'parent'], ['as', 'folks']
                                , ['out', 'parent'], ['in', 'parent']
                                , ['except', 'folks'], ['in', 'parent']
                                , ['unique']])

该cousins别名有点麻烦。也许我们可以扩展我们的addAlias功能，以允许我们自己在别名中使用其他别名
，并这样调用它：

Dagoba.addAlias('cousins',      [ 'parents', ['as', 'folks']
                                , 'parents', 'children'
                                , ['except', 'folks'], 'children', 'unique'])

现在代替

g.v('Forseti').parents().as('parents').parents().children()
                        .except('parents').children().unique()

我们可以说g.v('Forseti').cousins()。

但是，我们引入了一些泡菜：在我们的addAlias函数解析别名时，它还必须解析其他别名。如果parents调
用了其他别名该怎么办？在解决过程中，cousins我们必须停下来解析parents，然后再解析其别名，依此类
推？如果parents别名之一最终被调用cousins怎么办？

这使我们进入了依赖解决方案^28的领域，它是现代程序包管理器的核心组件。选择理想版本，摇晃树木，
进行一般优化等方法有很多花哨的技巧，但基本思想很简单。我们将绘制所有依赖关系及其关系的图形，然
后尝试找到一种方法来对齐顶点，同时使所有箭头从左向右移动。如果可以的话，将这种特殊的顶点排序称
为“拓扑排序”，并且我们已经证明我们的依赖图没有循环：它是有向无环图（DAG）。如果我们不这样做，
那么我们的图形至少有一个周期。

另一方面，我们期望查询通常会很短（100个步骤将是一个很长的查询），并且我们的转换器数量会相当少
。如果不做任何改动，我们可以不使用DAG和依赖项管理，而可以从transform函数返回“ true”，然后运行
它直到停止生产为止。这要求每个变压器都是幂等的，但这对于变压器来说是有用的属性。这两种途径的利
弊是什么？

性能

所有生产图数据库均具有特定的性能特征：图遍历查询相对于总图大小^29是恒定时间。在非图形数据库中
，询问某人的朋友列表可能需要与条目数成正比的时间，因为在最幼稚的情况下，您必须查看每个条目。这
意味着，如果对十个条目的查询花费一毫秒，那么对一千万个条目的查询将花费近两周的时间。如果由Pony
Express ^30发送，您的朋友列表会更快到达！

为了减轻这种令人沮丧的性能，大多数数据库在经常查询的字段上建立索引，从而 O （n ）Ø（ñ）搜索到 
ø （升Ò 克n ）Ø（升ØGñ）搜索。这样可以提供更好的搜索性能，但是以牺牲一些写入性能和大量空间为代
价-索引可以轻松地使数据库大小增加一倍。对于大多数数据库，仔细地平衡索引的时空权衡是永久调整过
程的一部分。

图数据库通过在顶点和边之间建立直接连接来避免此问题，因此图遍历只是指针跳转；无需浏览每个项目，
无需索引，完全不需要额外的工作。现在，无论图中有多少人，找到您的朋友的价格都是相同的，而且没有
额外的空间成本或写入时间成本。这种方法的一个缺点是，当整个图形都在同一台计算机的内存中时，指针
将发挥最佳作用。有效地跨多台计算机共享图形数据库仍然是研究的活跃领域^31。

如果我们替换寻找边缘的功能，我们可以在Dagoba的缩影中看到这一点。这是一个天真的版本，可以在线性
时间内搜索所有边缘。它与我们的第一个实现类似，但是使用了我们自建立以来的所有结构。

Dagoba.G.findInEdges  = function(vertex) {
  return this.edges.filter(function(edge) {return edge._in._id  == vertex._id} )
}
Dagoba.G.findOutEdges = function(vertex) {
  return this.edges.filter(function(edge) {return edge._out._id == vertex._id} )
}

我们可以为边缘添加索引，这可以使我们以小图获得大部分信息，但是对于大图则具有所有经典的索引问题
。

Dagoba.G.findInEdges  = function(vertex) { return this.inEdgeIndex [vertex._id] }
Dagoba.G.findOutEdges = function(vertex) { return this.outEdgeIndex[vertex._id] }

在这里，我们又回到了我们的老朋友：纯净，甜美的无索引邻接。

Dagoba.G.findInEdges  = function(vertex) { return vertex._in  }
Dagoba.G.findOutEdges = function(vertex) { return vertex._out }

自己运行这些文件，以体验图形数据库的差异^32。

序列化

在内存中有一个图形是很棒的，但是首先如何使它在那里？我们看到，我们的图构造函数可以获取顶点和边
的列表，并为我们创建一个图，但是一旦构建了图，我们如何才能将顶点和边取回？

我们自然倾向于做类似的事情JSON.stringify(graph)，它会产生非常有用的错误“ TypeError：将圆形结构
转换为JSON”。在图构建过程中，顶点被链接到它们的边缘，并且所有边都被链接到它们的顶点，因此现在
所有内容都引用了其他所有内容。那么，我们如何才能再次提取漂亮的整洁列表呢？JSON替换功能可为您提
供帮助。

该JSON.stringify函数使用一个值进行字符串化，但是它还使用两个附加参数：替换函数和空白数字^33。
替换程序允许您自定义字符串化的进行方式。

我们需要对顶点和边缘进行一些不同的处理，因此我们将手动将两侧合并为一个JSON字符串。

Dagoba.jsonify = function(graph) {
  return '{"V":' + JSON.stringify(graph.vertices, Dagoba.cleanVertex)
       + ',"E":' + JSON.stringify(graph.edges,    Dagoba.cleanEdge)
       + '}'
}

这些是顶点和边的替换。

Dagoba.cleanVertex = function(key, value) {
  return (key == '_in' || key == '_out') ? undefined : value
}

Dagoba.cleanEdge = function(key, value) {
  return (key == '_in' || key == '_out') ? value._id : value
}

它们之间的唯一区别是当要形成一个循环时它们会做什么：对于顶点，我们将完全跳过边列表。对于边缘，
我们将每个顶点替换为其ID。这消除了我们在构建图形时创建的所有循环。

我们正在手动操作JSON Dagoba.jsonify，通常不建议这样做，因为JSON格式相当固定。即使剂量如此之小
，也容易遗漏某些东西，并且很难从视觉上确认其正确性。

我们可以将两个替换函数合并为一个函数，并通过执行在整个图形上使用该新替换函数JSON.stringify
(graph, my_cool_replacer)。这使我们不必手动处理JSON输出，但是生成的代码可能有点麻烦。自己尝试
一下，看看是否可以提出一种避免手工编码JSON的精心设计的解决方案。（如果适合，则奖励积分。）

坚持不懈

持久性通常是数据库中棘手的部分之一：磁盘相对安全，但速度较慢。批处理写入，使它们成为原子记录和
日记记录，很难同时快速而正确地进行。

幸运的是，我们正在构建一个内存数据库，因此我们不必担心任何一个！但是，有时我们可能希望在本地保
存数据库的副本，以便在页面加载时快速重启。我们可以使用我们刚刚构建的序列化器来做到这一点。首先
，让我们将其包装在一个辅助函数中：

Dagoba.G.toString = function() { return Dagoba.jsonify(this) }

在JavaScript中，toString只要将对象强制转换为字符串，就会调用该对象的函数。因此，如果g是图形，
g+''则将是图形的序列化JSON字符串。

该fromString功能不是语言规范的一部分，但使用起来很方便。

Dagoba.fromString = function(str) {             // another graph constructor
  var obj = JSON.parse(str)                     // this can throw
  return Dagoba.graph(obj.V, obj.E)
}

现在，我们将在持久性功能中使用它们。该toString功能正在隐藏-您能发现它吗？

Dagoba.persist = function(graph, name) {
  name = name || 'graph'
  localStorage.setItem('DAGOBA::'+name, graph)
}

Dagoba.depersist = function (name) {
  name = 'DAGOBA::' + (name || 'graph')
  var flatgraph = localStorage.getItem(name)
  return Dagoba.fromString(flatgraph)
}

我们在名称前加上一个虚假的名称空间，以避免污染localStorage域的属性，因为该名称可能会很拥挤。通
常也有一个较低的存储限制，因此对于较大的图，我们可能希望使用某种Blob。

如果来自同一域的多个浏览器窗口同时存在和不存在，则还存在潜在的问题。该localStorage空间被这些窗
口之间共享，他们可能是在不同的事件循环，所以有一个粗心覆盖的其他工作的可能性。规范说，对的读/
写访问应该需要一个互斥体localStorage，但是在不同的浏览器之间不一致地实现了该互斥体，即使使用它
，像我们这样的简单实现仍然可能会遇到问题。

如果我们希望持久性实现具有多窗口并发意识，那么我们可以利用localStorage更改时触发的存储事件来相
应地更新本地图。

更新

我们的out管道类型会复制顶点的向外边缘，并在每次需要时弹出一个。构建新的数据结构需要花费时间和
空间，并将更多的工作推向内存管理器。相反，我们可以直接使用顶点的传出边缘列表，并使用计数器变量
来跟踪我们的位置。您能想到这种方法的问题吗？

如果有人在查询过程中删除了我们访问过的边，那将改变边列表的大小，然后我们将跳过一条边，因为我们
的计数器会关闭。为了解决这个问题，我们可以锁定查询中涉及的顶点，但是我们要么失去定期更新图形的
能力，要么失去使寿命长的查询对象能够按需响应更多结果的请求的能力。即使我们处于单线程事件循环中
，我们的查询也可以跨越多个异步重新输入，这意味着像这样的并发问题是一个非常现实的问题。

因此，我们将付出性能代价来复制边缘列表。但是，仍然存在一个问题，即长期查询可能无法看到完全一致
的时间顺序。在访问顶点时，我们将遍历顶点的每个边，但是在查询过程中，我们会在不同的时钟时间访问
顶点。假设我们保存一个类似的查询var q = g.v('Odin').children().children().take(2)，然后调用
q.run()来收集Odin的两个孙子。一段时间后，我们需要再拉两个孙子，所以我们q.run()再次打电话。如果
Odin在这段时间内有一个新的孙子，我们是否会看到它，这取决于我们第一次运行查询时是否访问了父顶点
。

解决此不确定性的一种方法是更改​​更新处理程序，以向数据添加版本控制。然后，我们将更改驱动程序循
环，以将图形的当前版本传递到查询中，因此，我们始终会看到查询首次初始化时所存在的世界的一致视图
。向我们的数据库中添加版本控制还为真正的交易和以类似于STM的方式自动回滚/重试打开了大门。

未来发展方向

我们之前看到了收集祖先的一种方式：

g.v('Thor').out().as('parent')
           .out().as('grandparent')
           .out().as('great-grandparent')
           .merge(['parent', 'grandparent', 'great-grandparent'])
           .run()

这非常笨拙，并且扩展性不好-如果我们想要六层祖先，那又会怎样呢？还是浏览任意数量的祖先，直到找
到我们想要的东西？

如果我们可以这样说，那就太好了：

g.v('Thor').out().all().times(3).run()

我们想要摆脱的是上面的查询，也许是这样：

g.v('Thor').out().as('a')
           .out().as('b')
           .out().as('c')
           .merge(['a', 'b', 'c'])
           .run()`

在查询转换器全部运行之后。我们可以先运行times变压器，以生产：

    g.v('Thor').out().all().out().all().out().all().run()

然后运行all变压器，并将其转换all为唯一标记的标签as，并merge在最后一个标签之后放置一个as。

但是，这有一些问题。其一，这种as/ merge如果每一个途径是存在于图形技术只适用：如果我们丢失了托
尔的曾祖父母的一个条目，然后我们将跳过有效条目。另外，如果我们只想对查询的一部分而不是整个查询
进行处理，会发生什么？如果有多个alls怎么办？

为了解决第一个问题，我们将不得不将alls视为不仅仅作为as / merge。我们需要每个父级gremlin实际跳
过中间步骤。我们可以将其视为一种隐形传送（从管道的一部分直接跳转到另一部分），也可以将其视为某
种分支管道，但是无论哪种方式都会使我们的模型复杂化。另一种方法是将gremlin视为以某种悬浮动画的
方式穿过中间管道，直到被特殊管道唤醒为止。但是，为悬挂/未悬挂的管道确定范围可能很棘手。

接下来的两个问题比较容易。要仅修改查询的一部分，我们将在特殊的开始/结束步骤中包装该部分，例如
g.v('Thor').out().start().in().out().end().times(4).run()。实际上，如果解释器知道这些特殊的管
道类型，则我们不需要结束步骤，因为序列的结尾始终是特殊的管道类型。我们将这些特殊的管道类型称为
“副词”，因为它们会修改常规管道类型，例如副词会修改动词。

要处理多个alls，我们需要对所有all转换器运行两次：一次在之前times，以all唯一标记所有s，另一次之
后times是重新标记所有标记的alls。

搜寻无限数量的祖先仍然是一个问题，例如，我们如何找出计划在伊米尔的哪些后代中生存的拉格纳洛克？
我们可以像g.v('Ymir').in().filter({survives: true})和那样进行单独的查询g.v('Ymir').in().in
().in().in().filter({survives: true})，然后自己手动收集结果，但这非常糟糕。

我们想使用这样的副词：

g.v('Ymir').in().filter({survives: true}).every()

可以像all+ 一样工作，times但不强制执行限制。但是，我们可能想对遍历强加一种特殊的策略，就像固定
的BFS或YOLO DFS一样，这样g.v('Ymir').in().filter({survives: true}).bfs()会更加灵活。以这种方式
进行表达可以使我们以简单的方式陈述诸如“检查Ragnarök幸存者，跳过其他各代人”之类的复杂查询：g.v
('Ymir').in().filter({survives: true}).in().bfs()。

包起来

所以我们学了什么？图形数据库非常适合存储互连的对象^34您计划通过图遍历查询的数据。添加非严格语
义可以使您能够流畅地处理由于性能原因而无法在急切的系统中表达的查询，并且可以跨越异步边界。时间
使事情变得复杂，而从多个角度来看（例如，并发）则使事情变得非常复杂，因此只要我们能够避免引入时
间依赖性（例如状态，可观察的影响等），我们就可以使系统推理变得更加容易。以简单，分离和痛苦的未
优化样式进行构建为以后进行全局优化打开了大门，并且使用驱动程序循环可以进行正交优化-每个都不会
引入脆性和复杂性，而脆性和复杂性是大多数优化技术的标志。

最后一点不能高估：保持简单。避免优化以简化为目标。通过找到正确的模型来努力实现简单性。探索许多
可能性。本书中的各章提供了充分的证据，表明非平凡的应用程序可以具有较小而紧密的内核。找到要构建
的应用程序的内核后，请努力防止复杂性污染它。构建用于附加功能的挂钩，并不惜一切代价维护抽象障碍
。很好地使用这些技术并不容易，但是它们可以帮助您解决其他棘手的问题。

致谢

非常感谢Amy Brown，Michael DiBernardo，Colin Lupton，Scott Rostrup，Michael Russo，Erin
Toliver和Leo Zovic对本章所做的宝贵贡献。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

 1. 最早的数据库设计之一是层次模型，该模型将项目分组为树形层次结构，并且仍用作IBM IMS产品（高
    速事务处理系统）的基础。在XML，文件系统和地理信息存储中也可以看到它的影响。由Charles
    Bachmann发明并由CODASYL标准化的网络模型通过允许多个父级，形成DAG而不是树来泛化分层模型。这
    些导航数据库模型在1960年代开始风行一时，并继续占据主导地位，直到性能提升使关系数据库在1980
    年代可用。↩

 2. Edgar F. Codd在IBM工作时就开发了关系数据库理论，但是Big Blue担心关系数据库会蚕食IMS的销售
    。尽管IBM最终构建了一个名为System R的研究原型，但它基于一种称为SEQUEL的新非关系语言，而不
    是Codd最初的Alpha语言。SEQUEL语言是Larry Ellison在发布前的会议论文的基础上由Larry Ellison
    复制到他的Oracle数据库中的，其名称更改为SQL，以避免商标争议。↩

 3. 该数据库开始于用于管理有向非循环图或DAG的库。它的名字“ Dagoba”原本打算在末尾带有一个无声的
    “ h”，以向这个虚构的虚构星球致敬，但是有一天读了一块巧克力棒的背面，我们发现sans-h版本是指
    默默地考虑事物之间的联系，这似乎更加合适。↩

 4. 本章的两个目的是讲授此过程，建立图形数据库并从中获得乐趣。↩

 5. 注意，我们将边建模为一对顶点。还要注意，这些对是有序的，因为我们正在使用数组。这意味着我们
    正在建模一个有向图，其中每个边都有一个起始顶点和一个终止顶点。我们的“点和线”视觉模型变成了
    “点和箭”模型。这增加了模型的复杂性，因为我们必须跟踪边的方向，但同时也允许我们提出更有趣的
    问题，例如“哪个顶点指向顶点3？”。或“哪个顶点的外边缘最多？” 如果需要对无向图进行建模，则可
    以为有向图中的每个现有边添加反向边。转向另一个方向可能很麻烦：模拟来自无向图的有向图。您能
    想到一种方法吗？↩

 6. 在另一个方向上它也松懈：所有函数都是可变参数，并且所有参数都可以通过arguments对象按位置使
    用，这几乎就像一个数组，但并不完全一样。（“可变参数”是说一个函数不定元数的一个奇特的方式。
    “一个函数不定元数”，是说它需要的变量数量可变的一种假想方式。）↩

 7. Array.isArray这里的检查是为了区分我们两个不同的用例，但是总的来说，我们将不会进行人们期望
    对生产代码进行的许多验证，而是将重点放在体系结构而不是垃圾箱上。↩

 8. 为什么我们不能只this.vertices.length在这里使用？↩

 9. 通常，由于深度复制而导致空间泄漏时，解决方案是使用路径复制的持久数据结构，该结构仅允许无突
    变更改 日志ñ日志⁡ñ多余的空间。但是问题仍然存在：如果宿主应用程序保留指向顶点数据的指针，那
    么它可以随时更改该数据，无论我们在数据库中施加了什么限制。唯一可行的解​​决方案是深度复制顶
    点，这会使我们的空间使用量增加一倍。Dagoba的原始用例涉及到被宿主应用程序视为不可变的顶点，
    这使我们能够避免此问题，但需要用户方面的一定程度的约束。↩

10. 我们可以根据Dagoba级别的配置参数，特定于图形的配置或某种启发式方法做出此决定。↩

11. 我们使用术语列表来指代需要推送和迭代操作的抽象数据结构。我们使用JavaScript的“数组”具体数据
    结构来满足列表抽象所需的API。从技术上讲，“边列表”和“边数组”都是正确的，因此我们在给定的时
    刻使用它取决于上下文：如果我们依赖JavaScript数组的特定细节（例如.length属性），我们将说“边
    缘”。否则，我们说“边缘列表”，以表明任何列表实现都足够。↩

12. 元组是另一个抽象数据结构，它比列表更受约束。特别是，元组具有固定的大小：在这种情况下，我们
    使用的是2元组（在数据结构研究人员的技术术语中也称为“对”）。对于将来的实现者来说，使用术语“
    所需的最受限制的抽象数据结构”是一个很好的选择。↩

13. 但是，寿命很短的垃圾是第二好的垃圾。↩

14. 对同一可变数据结构的两个引用就像一对对讲机一样，允许持有它们的人直接进行通信。这些对讲机可
    以在函数之间传递，并可以克隆以创建大量的对讲机。这完全颠覆了您的代码已经拥有的自然沟通渠道
    。在没有并发的系统中，您有时可以摆脱它，但会引入多线程或异步行为，所有对讲机叫都会成为真正
    的障碍。↩

15. 唯一性类型是用Clean语言清除的，并且与线性类型具有非线性关系，线性类型本身是子结构类型的子
    类型。↩

16. 大多数现代JS运行时都使用世代垃圾收集器，并且有意将这种语言与引擎的内存管理保持一定距离，以
    减少程序性不确定性的来源。↩

17. 将run()在查询结束调用解释并返回结果。↩

18. 自然地，skip鱼的重量和fat鱼的高度。根据Asgardian肉的密度，这可能会返回许多结果，或者根本没
    有结果。（或者只是Volstagg，如果我们允许莎士比亚杰克Kirby的方式进入我们的神殿。）↩

19. 有人会认为最好一直保持露骨。其他人则认为，一个好的隐式系统可以使代码更简洁，可读性更好，更
    少的样板并减少错误的表面积。我们都可以同意的一件事是，有效利用JavaScript的隐式强制要求需要
    记住许多非直觉的特殊情况，从而使其成为未入门者的雷区。↩

20. 您希望每个人返回什么？他们实际上返回了什么？↩

21. 在某些条件下，此特定查询可能会产生意外结果。你能想到什么吗？您如何修改它以处理这些情况？↩

22. 从技术上讲，我们需要使用非严格语义来实现解释器，这意味着它仅在被迫这样做时才进行评估。惰性
    评估是一种用于实现非严格性的技术。我们将两者混为一谈有点懒，所以我们只有在被迫这样做时才消
    除歧义。↩

23. 通过方法链，我们可以编写g.v('Thor').in().out().run()六行而不是六行的非流利JS来完成同一件事
    。↩

24. 我们称呼它是maybe_gremlin为了提醒自己，它可能是格林姆林，也可能是其他。同样是因为最初它不
    是隔物膜还是什么都没有。↩

25. 回想一下，done从-1开始，因此第一步的前任总是完成。↩

26. 或者，更明确地说，措辞不佳的查询不太可能产生指数级的下降。作为RDBMS的最终用户，查询质量的
    美感通常很不透明。↩

27. 请注意，我们保持优先级参数的域为开放状态，因此它可以是整数，有理数，负数甚至是Infinity或
    NaN之类的东西。↩

28. 您可以在本书的“可能”一章中了解有关依赖关系解决的更多信息。↩

29. 合适的术语是“无索引邻接”。↩

30. 尽管由于跨洲电报的到来以及美国内战的爆发仅运作了18个月，但今天仍被人们记住Pony Express在短
    短10天之内就将邮件陆续送达了海岸。↩

31. 对图数据库进行分片需要对图进行分区。即使对于像树和网格这样的简单图，最优图划分也是NP难的，
    而且好的近似值也具有指数渐近复杂性。↩

32. 在现代JavaScript引擎中，过滤列表的速度非常快-对于小的图形，由于基础数据结构和JIT编译方式的
    原因，幼稚的版本实际上比无索引的版本要快。尝试使用不同大小的图形，以查看两种方法如何缩放。
    ↩

33. 专家提示：给定一棵深树deep_tree，JSON.stringify(deep_tree, 0, 2)在JS控制台中运行是使其易于
    阅读的快速方法。↩

34. 不是太互连，但-你会喜欢边成正比的顶点数量增长的数量。换句话说，连接到顶点的边的平均数量不
    应随图形的大小而变化。我们考虑放入图形数据库中的大多数系统已经具有此属性：如果Loki再增加
    100,000个孙子，那么Thor顶点的度数将不会增加。↩

Google 翻译

原文

提供更好的翻译建议
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
