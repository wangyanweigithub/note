
<!-- vim-markdown-toc GFM -->

* [模式 37](#模式-37)
	* [简单工厂模式 40](#简单工厂模式-40)
	* [工厂方法 43](#工厂方法-43)
	* [策略模式 58](#策略模式-58)
	* [装饰器模式 68](#装饰器模式-68)
	* [代理模式 80](#代理模式-80)
	* [原型模式 97](#原型模式-97)
	* [模板方法模式 112](#模板方法模式-112)
	* [外观模式 155](#外观模式-155)
	* [建造者模式 175](#建造者模式-175)
	* [观察者模式 188](#观察者模式-188)
	* [抽象工厂模式 211](#抽象工厂模式-211)
	* [状态模式 213](#状态模式-213)
	* [适配器模式 215](#适配器模式-215)
	* [备忘录模式 217](#备忘录模式-217)
	* [组合模式 219](#组合模式-219)
	* [迭代器模式 221](#迭代器模式-221)
	* [单例模式 223](#单例模式-223)
	* [桥接模式 225](#桥接模式-225)
	* [命令模式 227](#命令模式-227)
	* [职责链模式 229](#职责链模式-229)
	* [中介模式 231](#中介模式-231)
	* [享元模式 233](#享元模式-233)
	* [解释器模式 235](#解释器模式-235)
	* [访问者模式 237](#访问者模式-237)
* [原则 239](#原则-239)
	* [单一职责原则 240](#单一职责原则-240)
	* [开放-封闭原则 249](#开放-封闭原则-249)
	* [依赖倒转原则 265](#依赖倒转原则-265)
	* [迪米特法则 272](#迪米特法则-272)
* [总结 275](#总结-275)

<!-- vim-markdown-toc -->
# 模式 37
> 之所以要加上抽象类,是因为在强类型语言中,是通过指向父类的指针指向派生类来实现多态的.

## 简单工厂模式 40
1. 通过一个字符串来生成一个类.然后使用者是一个指向父类的指针.实现多态.

## 工厂方法 43
> 定义一个用于创建对象的接口,让子类决定实例化哪一个类.工厂方法使一个类的实例化延迟到其子类.

1. 每个需要实例化类都有一个对应的工厂类/方法. 使用时先实例化类工厂对象,然后使用类工厂对象创建需要的对象.

2. 需要客户自己决定初始化哪一个工厂类.

3. 声明了很多个工厂类/工厂方法.

4. 工厂方法克服了简单工厂违背开放-封闭原则的缺点,又保持了封装对象创建过程的优点.

5. 工厂方法模式是简单工厂模式的进一步抽象和推广.由于使用了多态性,
工厂方法模式保持了简单工厂模式的优点,而又克服它的缺点.
但缺点是每加一个产品,就需要添加一个产品工厂类,增加了额外的开发量.

## 策略模式 58
> 它定义了算法家族,分别封装起来,让它们之间可以互相替换,此模式让算法的变化,不会影响到使用算法的客户

1. 上下文: 上下文中包含一个抽象算法类实例,通过改变这个属性,上下文可以改变具体的策略类.

2. 结构图:
	1. Context: 上下文,用一个ConcreteStrategy来配置,维护一个对strategy的对象的引用
	2. Strategy: 策略类,定义所有支持的算法的公共接口
	3. ConcreteStrategy: 具体策略类,封装了具体的算法行为,继承于Strategy

## 装饰器模式 68
> 动态地给一个对象添加一些额外的职责,就增加功能来说,装饰器模式比生成器模式更为灵活.

1. component是定义一个对象接口,可以给这些对象动态的添加职责.
2. concreteComponent是定义一个具体的对象,也可以对这个对象添加一些职责.
3. Decrator,装饰器抽象类,继承了Component,从外类来扩展Component类的功能.
但对于Component来说,是无需知道Decorator的存在的.

4. 总结:
	Decorator包含一个component对象,通过调用自己的同名方法时,
调用component对象的方法,然后在添加一些步骤.

## 代理模式 80
> 为其他对象提供一种代理以控制对这个对象的访问.

1. 代理模式的subject类和proxy类共用同样的接口.这样就在任何使用RealSubject的地方都可以使用proxy

2. proxy包含一个subject对象作为属性.

2. 使用场景:
	1. 远程代理,也就是为一个对象在不同的地址空间提供局部代表,
	这样可以隐藏一个对象存在于不同地址空间的事实.

	2. 虚拟代理, 是根据需要创建开销很大的对象,通过它来存放实例化需要很长时间的真实对象.

	3. 安全代理, 用来控制真实对象访问时的权限.

	4. 智能指针,是指当调用真实的对象时,代理处理另外一些事.

## 原型模式 97
> 用原型实例指向创建对象的种类,并且通过拷贝这些原型创建新的对象.

1. 原型模型其实就是从一个对象在创建另外一个可定制的对象,而且不需要知道任何创建细节.

2. 结构图:
	1. client: 指向一个prototype
	2. portotype: 原型类,声明一个clone自身的接口
	3. concretePrototype: 具体原型类,实现一个克隆自身的操作.

3. 一般在初始化的信息不发生变化的情况下,克隆是最好的办法.这既隐藏了对象创建的细节,
又对性能是大大的提高

4. 深拷贝/浅拷贝

## 模板方法模式 112
> 定义一个操作中的算法的骨架,而将一些步骤延迟到子类中.模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤.

1. 结构图:
	1. AbstractClass: 实现了一个模板方法,定义了算法的骨架,具体子类将重定义PrimitiveOperation
	以实现一个算法的步骤.
		1. TemplateMethod()
		2. PrimitiveOperation1()
		3. PrimitiveOperation2()

	
	2. ConcerteClass: 实现PrimitiveOperation以完成算法中与特定子类相关的步骤.
		1. PrimitiveOperation1()
		2. PrimitiveOperation2()

	3. ConcerteClass 继承自AbstractClass

2. AbstractClass
```
abstract class AbstractClass
{
	public abstract void PrimitiveOperation1();
	public abstract void PrimitiveOperation2();
	//一些抽象行为,放到子类去实现.

	public void TemplateMethod(){
		PrimitiveOperation1();
		PrimitiveOperation2();
		Console.WriteLine("");

		//模板方法,给出了逻辑的骨架,而逻辑的组成是一
		//些相应的抽象操作,它们都延迟到子类实现.
	}
}
```

3. concreteClass:
	实现了父类定义的一个或多个抽象方法,每一个AbstractClass都可以有任意多个concreteClass
与之对应,而每一个ConcreteClass都可以给出这些抽象方法(也就是顶级逻辑的组成步骤)的不同实现,
从而使得顶级逻辑的实现各不相同.

4. 模板方法模式是通过把不变行为搬移到超累,去除子类中的重复代码来体现它的优势.

## 外观模式 155
> 为子系统中的一组接口提供一个一致的界面,此模式定义了一个高层接口,这个接口使得这一子系统更容易使用.
> 类似于股票与基金

1. 结构图
	1. client
	2. Facade: 外观类,知道哪些子系统负责处理请求,将客户的请求代理给适当的子系统对象
		- MethodA()
		- MethodB()

	3. SubSystemOne, SubSystemTwo....: 子系统类集合,实现子系统的功能,处理Facade对象的指派的人物.
		注意子类中没有Facade的任何信息,既没有对Facade对象的引用.
		- MethodOne() ...

2. 使用场景
	1. 在设计初期阶段,应该要有意识地将不同的两个层分离
	2. 开发阶段,子系统往往因为不断的重构烟花而变得越来越复杂,增加外观模式可以提供一个简单的接口,减少它们之间的依赖.
	3. 维护一个遗留的大型系统时,可能这个系统已经非常难以维护和扩展,可以为新系统开发一个外观模式类,
	来提供设计粗超或高度复杂的遗留代码的比较清晰的简单接口.

## 建造者模式 175
> 将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示.

1. 结构图
	1. Builder: 为创建一个Product对象的各个部件指定的抽象接口
		- buildPart()

	2. ConcreteBuilder: 具体建造类,实现Builder接口,构造和装配各个部件

	3. Director: 指挥类,是构建一个使用Builder接口的对象,按照顺序调用builder中指定各个方法.

	4. Product: 具体产品.

## 观察者模式 188
> 定义了一宗一对多的依赖关系,让多个观察者对象同时监听某一个主题对象.这个主体对象在状态发生变
化时,会通知所有观察者对象,使它们能够自动更新自己.

1. 构造图:
	1. Subject类,它把所有对观察者对象的引用保存在一个聚集里,每个主题都可以有任何数量
	的观察者,抽象主题提供一个接口,可以增加和删除观察者对象.

	2. Observer类,抽象观察者,为所有的具体观察者定义一个接口,在得到主体的通知时更新自己.

	3. ConcreteObserber: 具体观察者,实现抽象观察者所要求的更新接口,以便使本身的状态
	与主题的状态相协调.

	4. conreteSubject: 具体主题,将有关状态存入具体观察者对象,在具体主题的内部状态改,
	变时,给所有登记过的观察者发出通知.

2. 应用场景
	1. 当一个对象的改变需要同时改变其他对象的时候,而且它不知道具体有多少对象有
	待改变时,应该考虑观察者模式.

3. 如果观察者的通知方法名称不同的话,可以使用事件委托(一个包装函数的类,统一调度),来
委托执行具体方法.

## 抽象工厂模式 211
> 提供一个创建一系列相关或相互依赖对象的接口,而无需指定他们具体的类.

1. 结构图:
	1. AbstractFactory: 抽象工接口,它里面应该包含所有的产品创建的抽象方法.
		- CreateProductA()
		- CreateProductB()

	2. ConcreteFactory1: 具体的工厂类,创建具有特定实现的产品对象

	3. AbstractProductA: 抽象产品,它们都有可能有两种不同的实现

	5. AbstractProductB: 抽象产品,它们都有可能有两种不同的实现

	4. ProductA1, ProductA2...: 对两个抽象产品的具体分类的实现

	6. ProductB1, ProductB2...: 对两个抽象产品的具体分类的实现

## 状态模式 213

## 适配器模式 215

## 备忘录模式 217

## 组合模式 219

## 迭代器模式 221

## 单例模式 223

## 桥接模式 225

## 命令模式 227

## 职责链模式 229

## 中介模式 231

## 享元模式 233

## 解释器模式 235

## 访问者模式 237

# 原则 239
## 单一职责原则 240
> 单一职责原则(SRP),就一个类而言,应该仅有一个引起它变化的原因.

1. 如果一个类承担过多的职责,就等于把这些职责耦合在一起,一个职责的变化可能会削弱或者抑制这
	个类完成其他职责的能力. 这种耦合会导致脆弱的设计,当发生变化时,设计会遭受到意想不到的破坏.

2. 软件设计真正要做的许多内容,就是发现职责并把那些职责相互分离:
	如果您呢个想到多于一个的动机去改变一个类,那么这个类就具有多于一个职责,就应该考虑类的职责分离.

## 开放-封闭原则 249
> 是说软件实体(类,模块,函数等等)应该可以扩展,但是不可以修改.

1. 无论模块是多么的"封闭",都会存在一些无法对之封闭的变化.既然不可能完全封闭,
设计人员必须对于他设计的模块应该对哪种变化封闭做出选择.他必须先猜测出最有
可能发生的变化种类,然后构造抽象来隔离那些变化.

2. 在我们最初编写代码使,假设变化不会发生,当变化发生时,我们就创建抽象来隔离以后发生的同类变化.

3. 面对需求,对程序的改动是通过增加新代码进行的,而不是更改现有的代码.这就是"开放-封闭原则的精神所在."

4. 我们希望的是在开发工作展开不就就知道可能发生的变化,查明可能发生的变化所等待的时间越长,要创建的抽象就越困难.

5. 开放-封闭原则是面向对象设计的核心所在.遵循这个原则可以带来面向对象技术所声称的巨大好处,也就是可维护,可扩展,可复用,灵活性好.
	开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象,然而,对于应用程序的每个部分都可以的进行抽象同样不是一个好的主意.拒绝不成熟的抽象和抽象本身一样重要.

## 依赖倒转原则 265
> 抽象不应该依赖细节,细节应该依赖与抽象.就是针对接口编程,不要对实现编程.

1. 里氏代换原则: 子类型必须能够替换掉它们的父类型.

2. 由于子类型的可替换性才使得使用父类类型的模块在无序修改的情况下就可以扩展.

## 迪米特法则 272
> 如果两个类不必彼此直接通信,那么这两个类就不应当发生直接的相互作用.如果一个类需要调用另一个类的某一个方法的话,可以通过第三者转发这个调用.

# 总结 275
