
<!-- vim-markdown-toc GFM -->

* [模式](#模式)
	* [简单工厂模式](#简单工厂模式)
	* [工厂方法](#工厂方法)
	* [策略模式](#策略模式)
	* [装饰器模式](#装饰器模式)
	* [代理模式](#代理模式)
	* [原型模式](#原型模式)
	* [模板方法模式](#模板方法模式)
	* [外观模式](#外观模式)
	* [建造者模式](#建造者模式)
	* [观察者模式](#观察者模式)
	* [抽象工厂模式](#抽象工厂模式)
	* [状态模式](#状态模式)
	* [适配器模式](#适配器模式)
	* [备忘录模式](#备忘录模式)
	* [组合模式](#组合模式)
	* [迭代器模式](#迭代器模式)
	* [单例模式](#单例模式)
	* [桥接模式](#桥接模式)
	* [命令模式](#命令模式)
	* [职责链模式](#职责链模式)
	* [中介模式](#中介模式)
	* [享元模式](#享元模式)
	* [解释器模式](#解释器模式)
	* [访问者模式](#访问者模式)
* [原则](#原则)
	* [单一职责原则](#单一职责原则)
	* [开放-封闭原则](#开放-封闭原则)
	* [依赖倒转原则](#依赖倒转原则)
	* [迪米特法则](#迪米特法则)
* [总结](#总结)

<!-- vim-markdown-toc -->
# 模式
> 之所以要加上抽象类,是因为在强类型语言中,是通过指向父类的指针指向派生类来实现多态的.

## 简单工厂模式
1. 通过一个字符串来生成一个类.然后使用者是一个指向父类的指针.实现多态.

## 工厂方法
> 定义一个用于创建对象的接口,让子类决定实例化哪一个类.工厂方法使一个类的实例化延迟到其子类.

1. 每个需要实例化类都有一个对应的工厂类/方法. 使用时先实例化类工厂对象,然后使用类工厂对象创建需要的对象.

2. 需要客户自己决定初始化哪一个工厂类.

3. 声明了很多个工厂类/工厂方法.

## 策略模式
> 它定义了算法家族,分别封装起来,让它们之间可以互相替换,此模式让算法的变化,不会影响到使用算法的客户.

1. 抽象算法类,和具体算法类
2. 上下文:
	上下文中包含一个抽象算法类实例,通过改变这个属性,上下文可以改变具体的策略类.

## 装饰器模式
> 动态地给一个对象添加一些额外的职责,就增加功能来说,装饰器模式比生成器模式更为灵活.

1. component是定义一个对象接口,可以给这些对象动态的添加职责.
2. concreteComponent是定义一个具体的对象,也可以对这个对象添加一些职责.
3. Decrator,装饰器抽象类,继承了Component,从外类来扩展Component类的功能.
但对于Component来说,是无需知道Decorator的存在的.

4. 总结:
	Decorator包含一个component对象,通过调用自己的同名方法时,
调用component对象的方法,然后在添加一些步骤.

## 代理模式
> 为其他对象提供一种代理以控制对这个对象的访问.

1. 代理模式的subject类和proxy类共用同样的接口.这样就在任何使用RealSubject的地方都可以使用proxy

2. proxy包含一个subject对象作为属性.

2. 使用场景:
	1. 远程代理,也就是为一个对象在不同的地址空间提供局部代表,
	这样可以隐藏一个对象存在于不同地址空间的事实.

	2. 虚拟代理, 是根据需要创建开销很大的对象,通过它来存放实例化需要很长时间的真实对象.

	3. 安全代理, 用来控制真实对象访问时的权限.

	4. 智能指针,是指当调用真实的对象时,代理处理另外一些事.

## 原型模式
> 用原型实例指向创建对象的种类,并且通过拷贝这些原型创建新的对象.

1. 原型模型其实就是从一个对象在创建另外一个可定制的对象,而且不需要知道任何创建细节.

2. 深拷贝/浅拷贝

3. 对象自己定义clone方法.


## 模板方法模式

## 外观模式

## 建造者模式

## 观察者模式

## 抽象工厂模式

## 状态模式

## 适配器模式

## 备忘录模式

## 组合模式

## 迭代器模式

## 单例模式

## 桥接模式

## 命令模式

## 职责链模式

## 中介模式

## 享元模式

## 解释器模式

## 访问者模式




# 原则
## 单一职责原则

## 开放-封闭原则

## 依赖倒转原则

## 迪米特法则

# 总结
