## 柔性数组/零长度数组
### 内存分页机制
1. 最小存储单位是一个字节（1B），最小管理单位是一页（4KB）

2. getpagesize()可以获取当前内存页的大小。

3. 硬盘也是如此（硬盘上称为Block块）：即使一个.txt文件中只有一个“a”字母，
其大小为1B而其占用大小为4K。

4. 第一次malloc(0)时一次性映射33个内存页。不管第一次malloc是多少，都分配至少33个页。
即使malloc(1)、malloc(4)都是分配了33个内存页。

5. malloc分配的额外数据信息：
	1. malloc(sizeof(int))申请了4字节，系统却给它33页，

	2. 而malloc()给变量分配给变量内存时，除了数据区域外，还额外需要保存一些信息。
	底层有一个双向链表保存额外信息。

	3. malloc()给指针了12个字节，其中4个字节存放数据，另外8个存放其他信息或者空闲，
	如果将12个字节中前（低位）几个字节清空或者进行修改，free就可能出错，因为free只有首地址
	不能释放，还得需要额外附加信息（如malloc分配的长度）。
	（低八位是附加数据，高四位是int型数据）

6. 所以malloc返回的指针是一个const的指针，不能改变指针本身。

7. ![内存6](内存6.png)
	1. 如果我们将低八位的数据进行清空或者修改（修改任意个字节），free就有可能失败，测试如下： 
	2. 代码:p-4 还是正确的，p-5出现段错误。
	```
		#include<stdio.h>
		#include<stdlib.h>
		
		int main(){
			int *p = malloc(sizeof(int));
			*(p-5) = 3;
			printf("hello");
			free(p);
			return 0;
		}
	```

### C语言0长度数组(可变数组/柔性数组)
1. [柔性数组详解](https://blog.csdn.net/gatieme/article/details/64131322)

#### 概念
1. GUN/GCC在标准的C/C++基础上做了实用性扩展,零长度数组(Arrays of length Zero)就是其中一
个知名的扩展

2. 柔性数组/0长度数组
	1. 用途: 长度为0的数组的主要用途是为了满足需要变长的结构体

	2. 用法:
		- <font color=red>必须: 在一个结构体的最后</font>,申明一个长度为0的数组,
		就可以使得这个结构体是可变长的

		- <font color=green>对于编译器来说,此时长度为0的数组并不占用空间,因为数组名本身不
		占空间,它只是一个偏移量,数组名这个符号本身代表了一个不可修改的地址常量.</font>

#### 变长结构体
1. 代码:
```
struct buffer {
	int len;
	char data[0];
} 
```

#### 0长度数组不占用存储空间/绑定struct 末尾原理
1. Programming Abstraction in c: arr is defined to be identical to &arr[0].它只是一个符号,
绑定到了arr[0]的地址.而指针是申请了8个字节的空间,保存了一个地址值的.

2. 通过汇编查看数组名和指针的区别:
	- 对于cahr s[0]来说,汇编代码用了addq指令,addq $4, %rax

	- 对于char* s来说,汇编代码用了movq指令,movq 8(%rax), %rax

3. addq 对 %rax + sizeof(struct str),即str结构的末尾是char s[0]的地址,这一步只是拿到了其
地址,而movq则是把地址里的内容放进去,因此有时也翻译做leap指令

4. <font color=red>这是最重要的地方:0长度数组名绑定的地址是struct 结构体的末尾,
这样,才可以使用malloc申请大空间,使用数组保存另外的信息</font>

#### 地址优化
> 注意:0长度数组是GUN c的扩展,不被任何标准库认可,那么一些巧妙编写的诡异代码,其执行结果
就是依赖于编译器和优化器策略的实现.

1. 比如程序中有两个0长度数组,他们地址被优化到一处

2. 编译器对于相同字符串常量,往往地址也是优化到一处,减少空间占用.
